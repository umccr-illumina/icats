/**
 * ICA Rest API
 * This API can be used to interact with Illumina Connected Analytics.<br> <p> Authentication to the  API can be done in multiple ways:<br> <ul><li>For the entire API, except for the POST /tokens endpoint: API-key + JWT</li> <li>Only for the POST /tokens endpoint: API-key + Basic Authentication</li></ul> </p> <p> <b>API-key</b><br> API keys are managed within the Illumina portal where you can manage your profile after you have logged on. The API-key has to be provided in the X-API-Key header parameter when executing API calls to ICA. In the background, a JWT will be requested at the IDP of Illumina to create a session. A good practice is to not use the API-key for every API call, but to first generate a JWT and to use that for authentication in subsequent calls.<br> </p> <p> <b>JWT</b><br> To avoid using an API-key for each call, we recommend to request a JWT via the POST /tokens endpoint  using this API-key. The JWT will expire after a pre-configured period specified by a tenant administrator through the IAM console in the Illumina portal. The JWT is the preferred way for authentication.<br>A not yet expired, still valid JWT could be refreshed using the POST /tokens:refresh endpoint.<br> </p> <p> <b>Basic Authentication</b><br> Basic authentication is only supported by the POST /tokens endpoint for generating a JWT. Use \"Basic base64encoded(emailaddress:password)\" in the \"Authorization\" header parameter for this authentication method. In case having access to multiple tenants using the same email-address, also provide the \"tenant\" request parameter to indicate what tenant you would like to request a JWT for. </p>
 *
 * The version of the OpenAPI document: 3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { Configuration } from './configuration';
import { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { RequestArgs, BaseAPI } from './base';
/**
 *
 * @export
 * @interface AWSDetails
 */
export interface AWSDetails {
    /**
     * The name of the s3 bucket
     * @type {string}
     * @memberof AWSDetails
     */
    'bucketName': string;
    /**
     * Key prefix within the bucket for ICA to operate within. Data may only be created having this prefix and the given credentials will only give access to it. If not set, default is to allow operation on the full bucket. No leading slash, and must end with a trailing slash.
     * @type {string}
     * @memberof AWSDetails
     */
    'keyPrefix'?: string | null;
    /**
     * Used to specify the type of server-side encryption (SSE) to be used on the object provider. This value is used to determine the Amazon S3 header \"x-amz-server-side-encryption\" value. For example, specify \"AES256\" for SSE-S3, or \"AWS:KMS\" for SSE-KMS. By default if none is specified, \"AES256\" will be used.
     * @type {string}
     * @memberof AWSDetails
     */
    'serverSideEncryptionAlgorithm'?: string | null;
    /**
     * Used to specify the server-side encryption key that might be associated with the specified server-side encryption algorithm. This value can be the AWS KMS arn key, to be used for the Amazon S3 header \"x-amz-server-side-encryption-aws-kms-key-id\" value. Value will be ignored if encryption is \"AES256\".
     * @type {string}
     * @memberof AWSDetails
     */
    'serverSideEncryptionKey'?: string | null;
}
/**
 *
 * @export
 * @interface ActivationCodeDetail
 */
export interface ActivationCodeDetail {
    /**
     *
     * @type {string}
     * @memberof ActivationCodeDetail
     */
    'id': string;
    /**
     * The allowed slot within this code, empty means unlimited
     * @type {number}
     * @memberof ActivationCodeDetail
     */
    'allowedSlots'?: number | null;
    /**
     * Indicates how many slots can are used.
     * @type {number}
     * @memberof ActivationCodeDetail
     */
    'usedSlots'?: number | null;
    /**
     * The slots that where moved to another activation code
     * @type {number}
     * @memberof ActivationCodeDetail
     */
    'movedSlots'?: number | null;
    /**
     * The assigned allowed slot within this code, empty means unlimited
     * @type {number}
     * @memberof ActivationCodeDetail
     */
    'originalSlots'?: number | null;
    /**
     *
     * @type {PipelineBundle}
     * @memberof ActivationCodeDetail
     */
    'pipelineBundle': PipelineBundle;
    /**
     *
     * @type {Array<ActivationCodeDetailUsage>}
     * @memberof ActivationCodeDetail
     */
    'usages': Array<ActivationCodeDetailUsage>;
}
/**
 *
 * @export
 * @interface ActivationCodeDetailList
 */
export interface ActivationCodeDetailList {
    /**
     *
     * @type {Array<ActivationCodeDetail>}
     * @memberof ActivationCodeDetailList
     */
    'items': Array<ActivationCodeDetail>;
}
/**
 *
 * @export
 * @interface ActivationCodeDetailUsage
 */
export interface ActivationCodeDetailUsage {
    /**
     *
     * @type {Project}
     * @memberof ActivationCodeDetailUsage
     */
    'project'?: Project;
    /**
     * Indicates how many slots can are used
     * @type {number}
     * @memberof ActivationCodeDetailUsage
     */
    'usedSlots'?: number | null;
    /**
     * Indicates how many slots can be used
     * @type {number}
     * @memberof ActivationCodeDetailUsage
     */
    'allowedSlots'?: number | null;
}
/**
 *
 * @export
 * @interface Analysis
 */
export interface Analysis {
    /**
     *
     * @type {string}
     * @memberof Analysis
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Analysis
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof Analysis
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof Analysis
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof Analysis
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof Analysis
     */
    'tenantName'?: string | null;
    /**
     * The unique reference of the analysis
     * @type {string}
     * @memberof Analysis
     */
    'reference': string;
    /**
     * The user reference of the analysis
     * @type {string}
     * @memberof Analysis
     */
    'userReference': string;
    /**
     *
     * @type {Pipeline}
     * @memberof Analysis
     */
    'pipeline': Pipeline;
    /**
     * The status of the analysis
     * @type {string}
     * @memberof Analysis
     */
    'status': AnalysisStatusEnum;
    /**
     * When the analysis was started
     * @type {string}
     * @memberof Analysis
     */
    'startDate'?: string | null;
    /**
     * When the analysis was finished
     * @type {string}
     * @memberof Analysis
     */
    'endDate'?: string | null;
    /**
     * The summary of the analysis
     * @type {string}
     * @memberof Analysis
     */
    'summary'?: string | null;
    /**
     *
     * @type {AnalysisStorage}
     * @memberof Analysis
     */
    'analysisStorage'?: AnalysisStorage;
    /**
     *
     * @type {AnalysisTag}
     * @memberof Analysis
     */
    'tags': AnalysisTag;
}
export declare const AnalysisStatusEnum: {
    readonly Requested: "REQUESTED";
    readonly Awaitinginput: "AWAITINGINPUT";
    readonly Inprogress: "INPROGRESS";
    readonly Succeeded: "SUCCEEDED";
    readonly Failed: "FAILED";
    readonly Failedfinal: "FAILEDFINAL";
    readonly Aborted: "ABORTED";
};
export declare type AnalysisStatusEnum = typeof AnalysisStatusEnum[keyof typeof AnalysisStatusEnum];
/**
 *
 * @export
 * @interface AnalysisData
 */
export interface AnalysisData {
    /**
     * The id of the file/folder.
     * @type {string}
     * @memberof AnalysisData
     */
    'dataId': string;
    /**
     *
     * @type {DataFormat}
     * @memberof AnalysisData
     */
    'format': DataFormat | null;
    /**
     * The name of the file/folder as it was processed by the analysis.
     * @type {string}
     * @memberof AnalysisData
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof AnalysisData
     */
    'dataType': AnalysisDataDataTypeEnum;
}
export declare const AnalysisDataDataTypeEnum: {
    readonly File: "FILE";
    readonly Folder: "FOLDER";
};
export declare type AnalysisDataDataTypeEnum = typeof AnalysisDataDataTypeEnum[keyof typeof AnalysisDataDataTypeEnum];
/**
 *
 * @export
 * @interface AnalysisDataInput
 */
export interface AnalysisDataInput {
    /**
     *
     * @type {string}
     * @memberof AnalysisDataInput
     */
    'parameterCode': string;
    /**
     *
     * @type {Array<string>}
     * @memberof AnalysisDataInput
     */
    'dataIds'?: Array<string> | null;
}
/**
 *
 * @export
 * @interface AnalysisInput
 */
export interface AnalysisInput {
    /**
     * The name of the input-parameter.
     * @type {string}
     * @memberof AnalysisInput
     */
    'code': string;
    /**
     * The analysis-data used as input by the analysis.
     * @type {Array<AnalysisData>}
     * @memberof AnalysisInput
     */
    'analysisData'?: Array<AnalysisData> | null;
}
/**
 *
 * @export
 * @interface AnalysisInputList
 */
export interface AnalysisInputList {
    /**
     *
     * @type {Array<AnalysisInput>}
     * @memberof AnalysisInputList
     */
    'items': Array<AnalysisInput>;
}
/**
 *
 * @export
 * @interface AnalysisOutput
 */
export interface AnalysisOutput {
    /**
     * The name of the output-parameter.
     * @type {string}
     * @memberof AnalysisOutput
     */
    'code': string;
    /**
     *
     * @type {Array<AnalysisData>}
     * @memberof AnalysisOutput
     */
    'data'?: Array<AnalysisData>;
}
/**
 *
 * @export
 * @interface AnalysisOutputList
 */
export interface AnalysisOutputList {
    /**
     *
     * @type {Array<AnalysisOutput>}
     * @memberof AnalysisOutputList
     */
    'items': Array<AnalysisOutput>;
}
/**
 *
 * @export
 * @interface AnalysisPagedList
 */
export interface AnalysisPagedList {
    /**
     *
     * @type {Array<Analysis>}
     * @memberof AnalysisPagedList
     */
    'items': Array<Analysis>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof AnalysisPagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof AnalysisPagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof AnalysisPagedList
     */
    'totalItemCount'?: number | null;
}
/**
 *
 * @export
 * @interface AnalysisParameter
 */
export interface AnalysisParameter {
    /**
     *
     * @type {string}
     * @memberof AnalysisParameter
     */
    'code'?: string;
    /**
     *
     * @type {string}
     * @memberof AnalysisParameter
     */
    'value'?: string;
}
/**
 *
 * @export
 * @interface AnalysisRawOutput
 */
export interface AnalysisRawOutput {
    /**
     * The raw output of the analysis.
     * @type {string}
     * @memberof AnalysisRawOutput
     */
    'rawOutput': string;
}
/**
 *
 * @export
 * @interface AnalysisReferenceDataParameter
 */
export interface AnalysisReferenceDataParameter {
    /**
     *
     * @type {string}
     * @memberof AnalysisReferenceDataParameter
     */
    'parameterCode'?: string;
    /**
     *
     * @type {string}
     * @memberof AnalysisReferenceDataParameter
     */
    'referenceDataId'?: string;
}
/**
 *
 * @export
 * @interface AnalysisStep
 */
export interface AnalysisStep {
    /**
     *
     * @type {string}
     * @memberof AnalysisStep
     */
    'id': string;
    /**
     * The status of the analysis step
     * @type {string}
     * @memberof AnalysisStep
     */
    'status': AnalysisStepStatusEnum;
    /**
     * When the analysis step was queued
     * @type {string}
     * @memberof AnalysisStep
     */
    'queueDate'?: string | null;
    /**
     * When the analysis step was started
     * @type {string}
     * @memberof AnalysisStep
     */
    'startDate'?: string | null;
    /**
     * When the analysis step was finished
     * @type {string}
     * @memberof AnalysisStep
     */
    'endDate'?: string | null;
    /**
     * Indicates which kind of step was executed
     * @type {boolean}
     * @memberof AnalysisStep
     */
    'technical': boolean;
}
export declare const AnalysisStepStatusEnum: {
    readonly Failed: "FAILED";
    readonly Done: "DONE";
    readonly Running: "RUNNING";
    readonly Interrupted: "INTERRUPTED";
    readonly Aborted: "ABORTED";
    readonly Waiting: "WAITING";
};
export declare type AnalysisStepStatusEnum = typeof AnalysisStepStatusEnum[keyof typeof AnalysisStepStatusEnum];
/**
 *
 * @export
 * @interface AnalysisStepList
 */
export interface AnalysisStepList {
    /**
     *
     * @type {Array<AnalysisStep>}
     * @memberof AnalysisStepList
     */
    'items': Array<AnalysisStep>;
}
/**
 *
 * @export
 * @interface AnalysisStorage
 */
export interface AnalysisStorage {
    /**
     *
     * @type {string}
     * @memberof AnalysisStorage
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof AnalysisStorage
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof AnalysisStorage
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof AnalysisStorage
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof AnalysisStorage
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof AnalysisStorage
     */
    'tenantName'?: string | null;
    /**
     * The name of the storage option
     * @type {string}
     * @memberof AnalysisStorage
     */
    'name': string;
    /**
     * The description about the storage option
     * @type {string}
     * @memberof AnalysisStorage
     */
    'description'?: string | null;
}
/**
 *
 * @export
 * @interface AnalysisStorageList
 */
export interface AnalysisStorageList {
    /**
     *
     * @type {Array<AnalysisStorage>}
     * @memberof AnalysisStorageList
     */
    'items': Array<AnalysisStorage>;
}
/**
 *
 * @export
 * @interface AnalysisTag
 */
export interface AnalysisTag {
    /**
     * Technical tags
     * @type {Array<string>}
     * @memberof AnalysisTag
     */
    'technicalTags': Array<string>;
    /**
     * User tags
     * @type {Array<string>}
     * @memberof AnalysisTag
     */
    'userTags': Array<string>;
    /**
     * Reference tags
     * @type {Array<string>}
     * @memberof AnalysisTag
     */
    'referenceTags': Array<string>;
}
/**
 *
 * @export
 * @interface Application
 */
export interface Application {
    /**
     *
     * @type {string}
     * @memberof Application
     */
    'id': string;
    /**
     * The unique name identifying the application
     * @type {string}
     * @memberof Application
     */
    'name': string;
    /**
     * The type of the application
     * @type {string}
     * @memberof Application
     */
    'type': ApplicationTypeEnum;
    /**
     * The display name of the application
     * @type {string}
     * @memberof Application
     */
    'displayName'?: string | null;
}
export declare const ApplicationTypeEnum: {
    readonly Main: "MAIN";
    readonly Websolution: "WEBSOLUTION";
    readonly External: "EXTERNAL";
};
export declare type ApplicationTypeEnum = typeof ApplicationTypeEnum[keyof typeof ApplicationTypeEnum];
/**
 * The credentials that are required when the type of the Storage Credential being updated is AWS
 * @export
 * @interface AwsCredentials
 */
export interface AwsCredentials {
    /**
     * The access key found in aws console
     * @type {string}
     * @memberof AwsCredentials
     */
    'accessKeyId': string;
    /**
     * The secret access key found in aws console
     * @type {string}
     * @memberof AwsCredentials
     */
    'secretAccessKey': string;
}
/**
 * In case of AWS S3 stored data, this will contain the credentials for uploading or downloading the data.
 * @export
 * @interface AwsTempCredentials
 */
export interface AwsTempCredentials {
    /**
     * The S3 access key.
     * @type {string}
     * @memberof AwsTempCredentials
     */
    'accessKey': string;
    /**
     * The S3 secret key.
     * @type {string}
     * @memberof AwsTempCredentials
     */
    'secretKey': string;
    /**
     * The S3 session token.
     * @type {string}
     * @memberof AwsTempCredentials
     */
    'sessionToken': string;
    /**
     * The S3 region.
     * @type {string}
     * @memberof AwsTempCredentials
     */
    'region': string;
    /**
     * The S3 bucket name.
     * @type {string}
     * @memberof AwsTempCredentials
     */
    'bucket': string;
    /**
     * The S3 object prefix these temporary credentials will give access to.
     * @type {string}
     * @memberof AwsTempCredentials
     */
    'objectPrefix': string;
    /**
     * Used to specify the type of server-side encryption (SSE) to be used on the object provider. This value is used to determine the Amazon S3 header \"x-amz-server-side-encryption\" value. For example, specify \"AES256\" for SSE-S3, or \"AWS:KMS\" for SSE-KMS. By default if none is specified, \"AES256\" will be used.
     * @type {string}
     * @memberof AwsTempCredentials
     */
    'serverSideEncryptionAlgorithm'?: string | null;
    /**
     * Used to specify the server-side encryption key that might be associated with the specified server-side encryption algorithm. This value can be the AWS KMS arn key, to be used for the Amazon S3 header \"x-amz-server-side-encryption-aws-kms-key-id\" value. Value will be ignored if encryption is \"AES256\"
     * @type {string}
     * @memberof AwsTempCredentials
     */
    'serverSideEncryptionKey'?: string | null;
}
/**
 *
 * @export
 * @interface BaseConnection
 */
export interface BaseConnection {
    /**
     * Specifies the supported snowflake authenticator to use. Currently \'oauth\' only is supported
     * @type {string}
     * @memberof BaseConnection
     */
    'authenticator': string;
    /**
     * Specifies the OAuth token to use for authentication
     * @type {string}
     * @memberof BaseConnection
     */
    'accessToken': string;
    /**
     * snowflake dns name. Usually something like \'<<account>>.snowflakecomputing.com\'
     * @type {string}
     * @memberof BaseConnection
     */
    'dnsName': string;
    /**
     * Specifies the user principal name. This is required for some snowflake client (snowSQL for instance)
     * @type {string}
     * @memberof BaseConnection
     */
    'userPrincipalName': string;
    /**
     * Specifies the database name bound to the project specified
     * @type {string}
     * @memberof BaseConnection
     */
    'databaseName': string;
    /**
     * Specifies the schema name bound to the project specified
     * @type {string}
     * @memberof BaseConnection
     */
    'schemaName': string;
    /**
     * Specifies the warehouse name bound to the project specified
     * @type {string}
     * @memberof BaseConnection
     */
    'warehouseName': string;
    /**
     * Specifies the role name bound to the project specified
     * @type {string}
     * @memberof BaseConnection
     */
    'roleName': string;
}
/**
 *
 * @export
 * @interface BaseJob
 */
export interface BaseJob {
    /**
     *
     * @type {string}
     * @memberof BaseJob
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof BaseJob
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof BaseJob
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof BaseJob
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof BaseJob
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof BaseJob
     */
    'tenantName'?: string | null;
    /**
     * A short description of the base job
     * @type {string}
     * @memberof BaseJob
     */
    'description'?: string | null;
    /**
     *
     * @type {ProjectBaseTable}
     * @memberof BaseJob
     */
    'table'?: ProjectBaseTable | null;
    /**
     * The type of the job
     * @type {string}
     * @memberof BaseJob
     */
    'type': BaseJobTypeEnum;
    /**
     * The status of the job
     * @type {string}
     * @memberof BaseJob
     */
    'status': BaseJobStatusEnum;
    /**
     * The duration of the job expressed in milliseconds
     * @type {number}
     * @memberof BaseJob
     */
    'overallDuration'?: number | null;
    /**
     * Detailed description of the job
     * @type {string}
     * @memberof BaseJob
     */
    'details'?: string | null;
    /**
     * Bytes billed
     * @type {number}
     * @memberof BaseJob
     */
    'bytesBilled'?: number | null;
}
export declare const BaseJobTypeEnum: {
    readonly Copytable: "COPYTABLE";
    readonly Exporttable: "EXPORTTABLE";
    readonly Createtable: "CREATETABLE";
    readonly Executequery: "EXECUTEQUERY";
    readonly Loaddata: "LOADDATA";
    readonly Preparedata: "PREPAREDATA";
};
export declare type BaseJobTypeEnum = typeof BaseJobTypeEnum[keyof typeof BaseJobTypeEnum];
export declare const BaseJobStatusEnum: {
    readonly Created: "CREATED";
    readonly Succeeded: "SUCCEEDED";
    readonly Failed: "FAILED";
    readonly Pending: "PENDING";
    readonly Inprogress: "INPROGRESS";
    readonly Aborted: "ABORTED";
};
export declare type BaseJobStatusEnum = typeof BaseJobStatusEnum[keyof typeof BaseJobStatusEnum];
/**
 *
 * @export
 * @interface BaseJobList
 */
export interface BaseJobList {
    /**
     *
     * @type {Array<BaseJob>}
     * @memberof BaseJobList
     */
    'items': Array<BaseJob>;
}
/**
 *
 * @export
 * @interface Bundle
 */
export interface Bundle {
    /**
     *
     * @type {string}
     * @memberof Bundle
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Bundle
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof Bundle
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof Bundle
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof Bundle
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof Bundle
     */
    'tenantName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof Bundle
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof Bundle
     */
    'shortDescription'?: string | null;
    /**
     *
     * @type {Region}
     * @memberof Bundle
     */
    'region': Region;
    /**
     *
     * @type {MetadataModel}
     * @memberof Bundle
     */
    'metadataModel'?: MetadataModel | null;
    /**
     *
     * @type {string}
     * @memberof Bundle
     */
    'releaseVersion': string;
    /**
     *
     * @type {string}
     * @memberof Bundle
     */
    'versionComment'?: string | null;
    /**
     *
     * @type {string}
     * @memberof Bundle
     */
    'status': BundleStatusEnum;
    /**
     * category tags as string array
     * @type {Array<string>}
     * @memberof Bundle
     */
    'categories'?: Array<string> | null;
    /**
     *
     * @type {Links}
     * @memberof Bundle
     */
    'links'?: Links | null;
}
export declare const BundleStatusEnum: {
    readonly Draft: "DRAFT";
    readonly Released: "RELEASED";
    readonly Deprecated: "DEPRECATED";
};
export declare type BundleStatusEnum = typeof BundleStatusEnum[keyof typeof BundleStatusEnum];
/**
 *
 * @export
 * @interface BundleData
 */
export interface BundleData {
    /**
     *
     * @type {Data}
     * @memberof BundleData
     */
    'data': Data;
    /**
     *
     * @type {string}
     * @memberof BundleData
     */
    'bundleId': string;
}
/**
 *
 * @export
 * @interface BundleDataPagedList
 */
export interface BundleDataPagedList {
    /**
     *
     * @type {Array<BundleData>}
     * @memberof BundleDataPagedList
     */
    'items': Array<BundleData>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof BundleDataPagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof BundleDataPagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof BundleDataPagedList
     */
    'totalItemCount'?: number | null;
}
/**
 *
 * @export
 * @interface BundleList
 */
export interface BundleList {
    /**
     *
     * @type {Array<Bundle>}
     * @memberof BundleList
     */
    'items': Array<Bundle>;
}
/**
 *
 * @export
 * @interface BundlePagedList
 */
export interface BundlePagedList {
    /**
     *
     * @type {Array<Bundle>}
     * @memberof BundlePagedList
     */
    'items': Array<Bundle>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof BundlePagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof BundlePagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof BundlePagedList
     */
    'totalItemCount'?: number | null;
}
/**
 *
 * @export
 * @interface BundlePipeline
 */
export interface BundlePipeline {
    /**
     *
     * @type {Pipeline}
     * @memberof BundlePipeline
     */
    'pipeline': Pipeline;
    /**
     *
     * @type {string}
     * @memberof BundlePipeline
     */
    'bundleId': string;
}
/**
 *
 * @export
 * @interface BundlePipelineList
 */
export interface BundlePipelineList {
    /**
     *
     * @type {Array<BundlePipeline>}
     * @memberof BundlePipelineList
     */
    'items': Array<BundlePipeline>;
}
/**
 *
 * @export
 * @interface BundleSample
 */
export interface BundleSample {
    /**
     *
     * @type {Sample}
     * @memberof BundleSample
     */
    'sample': Sample;
    /**
     *
     * @type {string}
     * @memberof BundleSample
     */
    'bundleId': string;
}
/**
 *
 * @export
 * @interface BundleSamplePagedList
 */
export interface BundleSamplePagedList {
    /**
     *
     * @type {Array<BundleSample>}
     * @memberof BundleSamplePagedList
     */
    'items': Array<BundleSample>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof BundleSamplePagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof BundleSamplePagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof BundleSamplePagedList
     */
    'totalItemCount'?: number | null;
}
/**
 *
 * @export
 * @interface BundleTool
 */
export interface BundleTool {
    /**
     *
     * @type {CWLToolDefinition}
     * @memberof BundleTool
     */
    'cwlToolDefinition': CWLToolDefinition;
}
/**
 *
 * @export
 * @interface BundleToolsList
 */
export interface BundleToolsList {
    /**
     *
     * @type {Array<BundleTool>}
     * @memberof BundleToolsList
     */
    'items': Array<BundleTool>;
}
/**
 *
 * @export
 * @interface CWLToolDefinition
 */
export interface CWLToolDefinition {
    /**
     *
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'tenantName'?: string | null;
    /**
     * Name of the tool definition
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'name': string;
    /**
     * Description of the tool definition
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'description'?: string | null;
    /**
     * Status of the tool definition
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'status': CWLToolDefinitionStatusEnum;
    /**
     * version comment of the tool definition
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'versionComment'?: string | null;
    /**
     * release version of the tool definition
     * @type {number}
     * @memberof CWLToolDefinition
     */
    'releaseVersion'?: number | null;
    /**
     *
     * @type {Link}
     * @memberof CWLToolDefinition
     */
    'links'?: Link;
    /**
     * category tags as string array
     * @type {Array<string>}
     * @memberof CWLToolDefinition
     */
    'categories'?: Array<string> | null;
}
export declare const CWLToolDefinitionStatusEnum: {
    readonly Draft: "DRAFT";
    readonly Released: "RELEASED";
    readonly Deprecated: "DEPRECATED";
    readonly Releasecandidate: "RELEASECANDIDATE";
    readonly Building: "BUILDING";
    readonly Buildfailed: "BUILDFAILED";
};
export declare type CWLToolDefinitionStatusEnum = typeof CWLToolDefinitionStatusEnum[keyof typeof CWLToolDefinitionStatusEnum];
/**
 *
 * @export
 * @interface CompleteFolderUploadSession
 */
export interface CompleteFolderUploadSession {
    /**
     * The number of expected uploaded files within this session.
     * @type {number}
     * @memberof CompleteFolderUploadSession
     */
    'numberOfExpectedUploadedFiles': number;
}
/**
 *
 * @export
 * @interface Connector
 */
export interface Connector {
    /**
     *
     * @type {string}
     * @memberof Connector
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Connector
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof Connector
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof Connector
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof Connector
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof Connector
     */
    'tenantName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof Connector
     */
    'code': string;
    /**
     *
     * @type {boolean}
     * @memberof Connector
     */
    'active': boolean;
    /**
     * Indicates if the connector is connected or not. This is cached so even when the connector is no longer connected, for a short time this still may return true.
     * @type {boolean}
     * @memberof Connector
     */
    'connected': boolean;
    /**
     * Technical code to be used for processing.
     * @type {string}
     * @memberof Connector
     */
    'technicalCode': string;
    /**
     * The key provided via other channels to initialize the installation.
     * @type {string}
     * @memberof Connector
     */
    'initializationKey'?: string | null;
    /**
     *
     * @type {Country}
     * @memberof Connector
     */
    'country'?: Country | null;
    /**
     *
     * @type {string}
     * @memberof Connector
     */
    'addressLine1'?: string | null;
    /**
     *
     * @type {string}
     * @memberof Connector
     */
    'addressLine2'?: string | null;
    /**
     *
     * @type {string}
     * @memberof Connector
     */
    'addressLine3'?: string | null;
    /**
     *
     * @type {string}
     * @memberof Connector
     */
    'postalCode'?: string | null;
    /**
     *
     * @type {string}
     * @memberof Connector
     */
    'city'?: string | null;
    /**
     *
     * @type {string}
     * @memberof Connector
     */
    'state'?: string | null;
    /**
     * The general description of the connector instance including its purpose.
     * @type {string}
     * @memberof Connector
     */
    'description'?: string | null;
    /**
     * The mode the connector runs in.
     * @type {string}
     * @memberof Connector
     */
    'mode': ConnectorModeEnum;
    /**
     * The maximum bandwidth defined in MB per second.
     * @type {number}
     * @memberof Connector
     */
    'maxBandwidth'?: number | null;
    /**
     * The maximum amount of concurrent transfers that this connector can execute.
     * @type {number}
     * @memberof Connector
     */
    'maxConcurrentTransfers'?: number | null;
    /**
     * The target OS of the original connector installer.
     * @type {string}
     * @memberof Connector
     */
    'os': ConnectorOsEnum;
    /**
     *
     * @type {string}
     * @memberof Connector
     */
    'installationStatus': ConnectorInstallationStatusEnum;
    /**
     *
     * @type {boolean}
     * @memberof Connector
     */
    'newConnectorVersionAvailable': boolean;
}
export declare const ConnectorModeEnum: {
    readonly Download: "DOWNLOAD";
    readonly Upload: "UPLOAD";
    readonly Both: "BOTH";
    readonly None: "NONE";
};
export declare type ConnectorModeEnum = typeof ConnectorModeEnum[keyof typeof ConnectorModeEnum];
export declare const ConnectorOsEnum: {
    readonly Windows: "WINDOWS";
    readonly Linux: "LINUX";
    readonly Osx: "OSX";
};
export declare type ConnectorOsEnum = typeof ConnectorOsEnum[keyof typeof ConnectorOsEnum];
export declare const ConnectorInstallationStatusEnum: {
    readonly PendingInstallation: "PENDING_INSTALLATION";
    readonly Installed: "INSTALLED";
    readonly Error: "ERROR";
    readonly Unknown: "UNKNOWN";
    readonly Cancelled: "CANCELLED";
};
export declare type ConnectorInstallationStatusEnum = typeof ConnectorInstallationStatusEnum[keyof typeof ConnectorInstallationStatusEnum];
/**
 *
 * @export
 * @interface ConnectorList
 */
export interface ConnectorList {
    /**
     *
     * @type {Array<Connector>}
     * @memberof ConnectorList
     */
    'items': Array<Connector>;
}
/**
 *
 * @export
 * @interface Country
 */
export interface Country {
    /**
     *
     * @type {string}
     * @memberof Country
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Country
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof Country
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof Country
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof Country
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof Country
     */
    'tenantName'?: string | null;
    /**
     * The country code as defined by ISO.
     * @type {string}
     * @memberof Country
     */
    'code': string;
    /**
     * The full name of the country.
     * @type {string}
     * @memberof Country
     */
    'name': string;
    /**
     * The region where the country belong to.
     * @type {string}
     * @memberof Country
     */
    'region': string;
}
/**
 *
 * @export
 * @interface CreateBundle
 */
export interface CreateBundle {
    /**
     *
     * @type {string}
     * @memberof CreateBundle
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CreateBundle
     */
    'shortDescription'?: string | null;
    /**
     *
     * @type {string}
     * @memberof CreateBundle
     */
    'bundleReleaseVersion': string;
    /**
     *
     * @type {string}
     * @memberof CreateBundle
     */
    'bundleVersionComment'?: string | null;
    /**
     *
     * @type {string}
     * @memberof CreateBundle
     */
    'regionId': string;
    /**
     *
     * @type {string}
     * @memberof CreateBundle
     */
    'metadataModelId'?: string | null;
    /**
     *
     * @type {string}
     * @memberof CreateBundle
     */
    'bundleStatus': CreateBundleBundleStatusEnum;
    /**
     * category tags as string array
     * @type {Array<string>}
     * @memberof CreateBundle
     */
    'categories': Array<string>;
    /**
     *
     * @type {Links}
     * @memberof CreateBundle
     */
    'links'?: Links | null;
}
export declare const CreateBundleBundleStatusEnum: {
    readonly Draft: "DRAFT";
    readonly Released: "RELEASED";
    readonly Deprecated: "DEPRECATED";
};
export declare type CreateBundleBundleStatusEnum = typeof CreateBundleBundleStatusEnum[keyof typeof CreateBundleBundleStatusEnum];
/**
 *
 * @export
 * @interface CreateConnector
 */
export interface CreateConnector {
    /**
     *
     * @type {string}
     * @memberof CreateConnector
     */
    'code': string;
    /**
     *
     * @type {boolean}
     * @memberof CreateConnector
     */
    'active': boolean;
    /**
     * ID of the country. If not provided then the country of the tenant will be used.
     * @type {string}
     * @memberof CreateConnector
     */
    'countryId'?: string | null;
    /**
     *
     * @type {string}
     * @memberof CreateConnector
     */
    'addressLine1'?: string | null;
    /**
     *
     * @type {string}
     * @memberof CreateConnector
     */
    'addressLine2'?: string | null;
    /**
     *
     * @type {string}
     * @memberof CreateConnector
     */
    'addressLine3'?: string | null;
    /**
     *
     * @type {string}
     * @memberof CreateConnector
     */
    'postalCode'?: string | null;
    /**
     *
     * @type {string}
     * @memberof CreateConnector
     */
    'city'?: string | null;
    /**
     *
     * @type {string}
     * @memberof CreateConnector
     */
    'state'?: string | null;
    /**
     * The general description of the connector instance including its purpose.
     * @type {string}
     * @memberof CreateConnector
     */
    'description'?: string | null;
    /**
     * The mode the connector runs in.
     * @type {string}
     * @memberof CreateConnector
     */
    'mode': CreateConnectorModeEnum;
    /**
     * The maximum bandwidth defined in MB per second.
     * @type {number}
     * @memberof CreateConnector
     */
    'maxBandwidth'?: number | null;
    /**
     * The maximum amount of concurrent transfers that this connector can execute.
     * @type {number}
     * @memberof CreateConnector
     */
    'maxConcurrentTransfers'?: number | null;
    /**
     * The target OS of the original connector installer.
     * @type {string}
     * @memberof CreateConnector
     */
    'os': CreateConnectorOsEnum;
}
export declare const CreateConnectorModeEnum: {
    readonly Download: "DOWNLOAD";
    readonly Upload: "UPLOAD";
    readonly Both: "BOTH";
    readonly None: "NONE";
};
export declare type CreateConnectorModeEnum = typeof CreateConnectorModeEnum[keyof typeof CreateConnectorModeEnum];
export declare const CreateConnectorOsEnum: {
    readonly Windows: "WINDOWS";
    readonly Linux: "LINUX";
    readonly Osx: "OSX";
};
export declare type CreateConnectorOsEnum = typeof CreateConnectorOsEnum[keyof typeof CreateConnectorOsEnum];
/**
 *
 * @export
 * @interface CreateCustomEvent
 */
export interface CreateCustomEvent {
    /**
     * The event code that should match a custom subscription.
     * @type {string}
     * @memberof CreateCustomEvent
     */
    'code': string;
    /**
     * The content that will be forwarded to the configured custom subscription destinations.
     * @type {object}
     * @memberof CreateCustomEvent
     */
    'content': object;
}
/**
 *
 * @export
 * @interface CreateCustomNotificationSubscription
 */
export interface CreateCustomNotificationSubscription {
    /**
     * The custom event code to subscribe to
     * @type {string}
     * @memberof CreateCustomNotificationSubscription
     */
    'customEventCode': string;
    /**
     * To be used when a notification applies to specific conditions.
     * @type {string}
     * @memberof CreateCustomNotificationSubscription
     */
    'filterExpression'?: string | null;
    /**
     * Should this subscription be enabled or not?
     * @type {boolean}
     * @memberof CreateCustomNotificationSubscription
     */
    'enabled': boolean;
    /**
     * The id of the notification channel used to send on
     * @type {string}
     * @memberof CreateCustomNotificationSubscription
     */
    'notificationChannelId': string;
}
/**
 *
 * @export
 * @interface CreateCwlAnalysis
 */
export interface CreateCwlAnalysis {
    /**
     * The user-reference of the analysis. This should be something meaningful for the user.
     * @type {string}
     * @memberof CreateCwlAnalysis
     */
    'userReference': string;
    /**
     * The pipeline for which an analysis will be created.
     * @type {string}
     * @memberof CreateCwlAnalysis
     */
    'pipelineId': string;
    /**
     *
     * @type {AnalysisTag}
     * @memberof CreateCwlAnalysis
     */
    'tags': AnalysisTag;
    /**
     * Indicates under which activation code the pipeline is executed.
     * @type {string}
     * @memberof CreateCwlAnalysis
     */
    'activationCodeDetailId': string;
    /**
     * The id of the storage to use for the analysis.
     * @type {string}
     * @memberof CreateCwlAnalysis
     */
    'analysisStorageId'?: string | null;
    /**
     *
     * @type {CwlAnalysisInput}
     * @memberof CreateCwlAnalysis
     */
    'analysisInput': CwlAnalysisInput;
}
/**
 *
 * @export
 * @interface CreateData
 */
export interface CreateData {
    /**
     * The name of the file/folder as how it will be created.
     * @type {string}
     * @memberof CreateData
     */
    'name': string;
    /**
     * The id of the folder you want to create this new data in. Alternatively, the folderPath attribute could be used as well for this.
     * @type {string}
     * @memberof CreateData
     */
    'folderId'?: string | null;
    /**
     * The absolute path of the folder you want to create this new data in. Alternatively, the folderId attribute could be used as well for this. In case the folder path does not yet exist, it will be automatically created.
     * @type {string}
     * @memberof CreateData
     */
    'folderPath'?: string | null;
    /**
     * The code of the format you would like to assign at creation time. This is only allowed for file data. If not specified, auto format assignment will be done.
     * @type {string}
     * @memberof CreateData
     */
    'formatCode'?: string | null;
    /**
     *
     * @type {string}
     * @memberof CreateData
     */
    'dataType': CreateDataDataTypeEnum;
}
export declare const CreateDataDataTypeEnum: {
    readonly File: "FILE";
    readonly Folder: "FOLDER";
};
export declare type CreateDataDataTypeEnum = typeof CreateDataDataTypeEnum[keyof typeof CreateDataDataTypeEnum];
/**
 *
 * @export
 * @interface CreateDownloadRule
 */
export interface CreateDownloadRule {
    /**
     *
     * @type {string}
     * @memberof CreateDownloadRule
     */
    'code': string;
    /**
     *
     * @type {boolean}
     * @memberof CreateDownloadRule
     */
    'active'?: boolean | null;
    /**
     *
     * @type {string}
     * @memberof CreateDownloadRule
     */
    'description'?: string | null;
    /**
     * Defines the order of the rule.
     * @type {number}
     * @memberof CreateDownloadRule
     */
    'sequence': number;
    /**
     * Regular expression to filter which format this rule applies to.
     * @type {string}
     * @memberof CreateDownloadRule
     */
    'formatCode'?: string | null;
    /**
     * Regular expression to filter which project this rule applies to.
     * @type {string}
     * @memberof CreateDownloadRule
     */
    'projectName'?: string | null;
    /**
     * The local folder where to write the data.
     * @type {string}
     * @memberof CreateDownloadRule
     */
    'targetLocalFolder': string;
    /**
     * Will allow the filename to be modified including a set of variables
     * @type {string}
     * @memberof CreateDownloadRule
     */
    'fileNameExpression'?: string | null;
}
/**
 *
 * @export
 * @interface CreateNextflowAnalysis
 */
export interface CreateNextflowAnalysis {
    /**
     * The user-reference of the analysis. This should be something meaningful for the user.
     * @type {string}
     * @memberof CreateNextflowAnalysis
     */
    'userReference': string;
    /**
     * The pipeline for which an analysis will be created.
     * @type {string}
     * @memberof CreateNextflowAnalysis
     */
    'pipelineId': string;
    /**
     *
     * @type {AnalysisTag}
     * @memberof CreateNextflowAnalysis
     */
    'tags': AnalysisTag;
    /**
     * Indicates under which activation code the pipeline is executed.
     * @type {string}
     * @memberof CreateNextflowAnalysis
     */
    'activationCodeDetailId': string;
    /**
     * The id of the storage to use for the analysis.
     * @type {string}
     * @memberof CreateNextflowAnalysis
     */
    'analysisStorageId'?: string | null;
    /**
     *
     * @type {NextflowAnalysisInput}
     * @memberof CreateNextflowAnalysis
     */
    'analysisInput': NextflowAnalysisInput;
}
/**
 *
 * @export
 * @interface CreateNotificationChannel
 */
export interface CreateNotificationChannel {
    /**
     * Should this channel be enabled or not?
     * @type {boolean}
     * @memberof CreateNotificationChannel
     */
    'enabled': boolean;
    /**
     * The type of delivery target (MAIL, SQS, SNS, HTTP, ...)
     * @type {string}
     * @memberof CreateNotificationChannel
     */
    'type': CreateNotificationChannelTypeEnum;
    /**
     * The address where to send a notification to (email address, url, ...)
     * @type {string}
     * @memberof CreateNotificationChannel
     */
    'address': string;
}
export declare const CreateNotificationChannelTypeEnum: {
    readonly Mail: "MAIL";
    readonly Sqs: "SQS";
    readonly Sns: "SNS";
    readonly Http: "HTTP";
};
export declare type CreateNotificationChannelTypeEnum = typeof CreateNotificationChannelTypeEnum[keyof typeof CreateNotificationChannelTypeEnum];
/**
 *
 * @export
 * @interface CreateNotificationSubscription
 */
export interface CreateNotificationSubscription {
    /**
     * The event code to subscribe to
     * @type {string}
     * @memberof CreateNotificationSubscription
     */
    'eventCode': string;
    /**
     * To be used when a notification applies to specific conditions.
     * @type {string}
     * @memberof CreateNotificationSubscription
     */
    'filterExpression'?: string | null;
    /**
     * Should this subscription be enabled or not?
     * @type {boolean}
     * @memberof CreateNotificationSubscription
     */
    'enabled': boolean;
    /**
     * The ID of the notification channel used to send on
     * @type {string}
     * @memberof CreateNotificationSubscription
     */
    'notificationChannelId': string;
}
/**
 *
 * @export
 * @interface CreateProject
 */
export interface CreateProject {
    /**
     *
     * @type {string}
     * @memberof CreateProject
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CreateProject
     */
    'shortDescription'?: string | null;
    /**
     * Information about the project. Note that the value of this field can be arbitrary large.
     * @type {string}
     * @memberof CreateProject
     */
    'information'?: string | null;
    /**
     * Owner of the project. Defaults to the current user.
     * @type {string}
     * @memberof CreateProject
     */
    'projectOwnerId'?: string | null;
    /**
     * The region of the project. All data and pipeline executions will reside in this region.
     * @type {string}
     * @memberof CreateProject
     */
    'regionId': string;
    /**
     * The billing mode of the project. It determines who pays for the costs linked to the project.
     * @type {string}
     * @memberof CreateProject
     */
    'billingMode': CreateProjectBillingModeEnum;
    /**
     * Indicates whether the Data and Samples created in this Project can be linked to other Projects.
     * @type {boolean}
     * @memberof CreateProject
     */
    'dataSharingEnabled': boolean;
    /**
     *
     * @type {ProjectTag}
     * @memberof CreateProject
     */
    'tags'?: ProjectTag;
    /**
     *
     * @type {string}
     * @memberof CreateProject
     */
    'storageBundleId': string;
    /**
     *
     * @type {string}
     * @memberof CreateProject
     */
    'metadataModelId'?: string | null;
    /**
     * An optional storage configuration id to have self managed storage.
     * @type {string}
     * @memberof CreateProject
     */
    'storageConfigurationId'?: string | null;
    /**
     * Required when specifying a storageConfigurationId. The subfolder determines the object prefix of your self managed storage.
     * @type {string}
     * @memberof CreateProject
     */
    'storageConfigurationSubfolder'?: string | null;
}
export declare const CreateProjectBillingModeEnum: {
    readonly Project: "PROJECT";
    readonly Tenant: "TENANT";
};
export declare type CreateProjectBillingModeEnum = typeof CreateProjectBillingModeEnum[keyof typeof CreateProjectBillingModeEnum];
/**
 *
 * @export
 * @interface CreateProjectPermission
 */
export interface CreateProjectPermission {
    /**
     *
     * @type {string}
     * @memberof CreateProjectPermission
     */
    'roleProject': CreateProjectPermissionRoleProjectEnum;
    /**
     *
     * @type {string}
     * @memberof CreateProjectPermission
     */
    'roleFlow': CreateProjectPermissionRoleFlowEnum;
    /**
     *
     * @type {string}
     * @memberof CreateProjectPermission
     */
    'roleBase': CreateProjectPermissionRoleBaseEnum;
    /**
     *
     * @type {string}
     * @memberof CreateProjectPermission
     */
    'roleBench': CreateProjectPermissionRoleBenchEnum;
    /**
     * How users are invited to the project
     * @type {string}
     * @memberof CreateProjectPermission
     */
    'membershipType': CreateProjectPermissionMembershipTypeEnum;
    /**
     * the id of the user that should be given access, required when membershipType is USER
     * @type {string}
     * @memberof CreateProjectPermission
     */
    'userId'?: string | null;
    /**
     * The email to invite a user on, required when membershipType is EMAIL
     * @type {string}
     * @memberof CreateProjectPermission
     */
    'emailAddress'?: string | null;
    /**
     * the id of the workgroup to give access, required when membershipType is WORKGROUP
     * @type {string}
     * @memberof CreateProjectPermission
     */
    'workgroupId'?: string | null;
    /**
     * Indicates if uploading data is allowed or not.
     * @type {boolean}
     * @memberof CreateProjectPermission
     */
    'uploadAllowed': boolean;
    /**
     * Indicates if downloading data is allowed or not.
     * @type {boolean}
     * @memberof CreateProjectPermission
     */
    'downloadAllowed': boolean;
}
export declare const CreateProjectPermissionRoleProjectEnum: {
    readonly None: "NONE";
    readonly Viewer: "VIEWER";
    readonly Contributor: "CONTRIBUTOR";
    readonly Administrator: "ADMINISTRATOR";
    readonly DataProvider: "DATA_PROVIDER";
};
export declare type CreateProjectPermissionRoleProjectEnum = typeof CreateProjectPermissionRoleProjectEnum[keyof typeof CreateProjectPermissionRoleProjectEnum];
export declare const CreateProjectPermissionRoleFlowEnum: {
    readonly None: "NONE";
    readonly Viewer: "VIEWER";
    readonly Contributor: "CONTRIBUTOR";
};
export declare type CreateProjectPermissionRoleFlowEnum = typeof CreateProjectPermissionRoleFlowEnum[keyof typeof CreateProjectPermissionRoleFlowEnum];
export declare const CreateProjectPermissionRoleBaseEnum: {
    readonly None: "NONE";
    readonly Viewer: "VIEWER";
    readonly Contributor: "CONTRIBUTOR";
};
export declare type CreateProjectPermissionRoleBaseEnum = typeof CreateProjectPermissionRoleBaseEnum[keyof typeof CreateProjectPermissionRoleBaseEnum];
export declare const CreateProjectPermissionRoleBenchEnum: {
    readonly None: "NONE";
    readonly Contributor: "CONTRIBUTOR";
};
export declare type CreateProjectPermissionRoleBenchEnum = typeof CreateProjectPermissionRoleBenchEnum[keyof typeof CreateProjectPermissionRoleBenchEnum];
export declare const CreateProjectPermissionMembershipTypeEnum: {
    readonly User: "USER";
    readonly Email: "EMAIL";
    readonly Workgroup: "WORKGROUP";
};
export declare type CreateProjectPermissionMembershipTypeEnum = typeof CreateProjectPermissionMembershipTypeEnum[keyof typeof CreateProjectPermissionMembershipTypeEnum];
/**
 *
 * @export
 * @interface CreateSample
 */
export interface CreateSample {
    /**
     * The name of the sample.
     * @type {string}
     * @memberof CreateSample
     */
    'name': string;
    /**
     * The description of the sample.
     * @type {string}
     * @memberof CreateSample
     */
    'description'?: string | null;
    /**
     *
     * @type {SampleTag}
     * @memberof CreateSample
     */
    'tags'?: SampleTag;
}
/**
 *
 * @export
 * @interface CreateStorageConfiguration
 */
export interface CreateStorageConfiguration {
    /**
     * The name of the configuration
     * @type {string}
     * @memberof CreateStorageConfiguration
     */
    'name': string;
    /**
     * An optional description
     * @type {string}
     * @memberof CreateStorageConfiguration
     */
    'description'?: string | null;
    /**
     * The id of the storage credential
     * @type {string}
     * @memberof CreateStorageConfiguration
     */
    'storageCredentialId': string;
    /**
     * The type of configuration
     * @type {string}
     * @memberof CreateStorageConfiguration
     */
    'type': CreateStorageConfigurationTypeEnum;
    /**
     *
     * @type {AWSDetails}
     * @memberof CreateStorageConfiguration
     */
    'awsDetails'?: AWSDetails | null;
    /**
     * The id of the region where the bucket will be located
     * @type {string}
     * @memberof CreateStorageConfiguration
     */
    'regionId': string;
}
export declare const CreateStorageConfigurationTypeEnum: {
    readonly AwsS3: "AWS_S3";
};
export declare type CreateStorageConfigurationTypeEnum = typeof CreateStorageConfigurationTypeEnum[keyof typeof CreateStorageConfigurationTypeEnum];
/**
 *
 * @export
 * @interface CreateStorageCredential
 */
export interface CreateStorageCredential {
    /**
     * The name of the credentials
     * @type {string}
     * @memberof CreateStorageCredential
     */
    'name': string;
    /**
     * The type of the credentials
     * @type {string}
     * @memberof CreateStorageCredential
     */
    'type': CreateStorageCredentialTypeEnum;
    /**
     *
     * @type {AwsCredentials}
     * @memberof CreateStorageCredential
     */
    'awsCredentials'?: AwsCredentials | null;
}
export declare const CreateStorageCredentialTypeEnum: {
    readonly AwsUser: "AWS_USER";
};
export declare type CreateStorageCredentialTypeEnum = typeof CreateStorageCredentialTypeEnum[keyof typeof CreateStorageCredentialTypeEnum];
/**
 *
 * @export
 * @interface CreateTemporaryCredentials
 */
export interface CreateTemporaryCredentials {
    /**
     * The format in which temporary credentials have to be returned. If not provided, temporary credentials will be returned in a cloud specific format.
     * @type {string}
     * @memberof CreateTemporaryCredentials
     */
    'credentialsFormat'?: CreateTemporaryCredentialsCredentialsFormatEnum;
}
export declare const CreateTemporaryCredentialsCredentialsFormatEnum: {
    readonly Rclone: "RCLONE";
};
export declare type CreateTemporaryCredentialsCredentialsFormatEnum = typeof CreateTemporaryCredentialsCredentialsFormatEnum[keyof typeof CreateTemporaryCredentialsCredentialsFormatEnum];
/**
 *
 * @export
 * @interface CreateUploadRule
 */
export interface CreateUploadRule {
    /**
     *
     * @type {string}
     * @memberof CreateUploadRule
     */
    'code': string;
    /**
     *
     * @type {boolean}
     * @memberof CreateUploadRule
     */
    'active'?: boolean | null;
    /**
     *
     * @type {string}
     * @memberof CreateUploadRule
     */
    'description'?: string | null;
    /**
     * The local folder to monitor. Files in this folder on your local environment will be uploaded to the specified project. Only files matching the filePattern will be uploaded.
     * @type {string}
     * @memberof CreateUploadRule
     */
    'localFolder': string;
    /**
     * The regular expression to match a file name. eg: to match all files use \'.*\'
     * @type {string}
     * @memberof CreateUploadRule
     */
    'filePattern': string;
    /**
     * The format which will be assigned to the uploaded data. If not specified, an auto-detection of the format will be done.
     * @type {string}
     * @memberof CreateUploadRule
     */
    'dataFormatId'?: string | null;
    /**
     * The project to which the data will be uploaded.
     * @type {string}
     * @memberof CreateUploadRule
     */
    'projectId': string;
}
/**
 *
 * @export
 * @interface CustomNotificationSubscription
 */
export interface CustomNotificationSubscription {
    /**
     *
     * @type {string}
     * @memberof CustomNotificationSubscription
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof CustomNotificationSubscription
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof CustomNotificationSubscription
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof CustomNotificationSubscription
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof CustomNotificationSubscription
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof CustomNotificationSubscription
     */
    'tenantName'?: string | null;
    /**
     * The custom event code to subscribe to
     * @type {string}
     * @memberof CustomNotificationSubscription
     */
    'customEventCode': string;
    /**
     * To be used when a notification applies to specific conditions.
     * @type {string}
     * @memberof CustomNotificationSubscription
     */
    'filterExpression'?: string | null;
    /**
     * Should this subscription be enabled or not?
     * @type {boolean}
     * @memberof CustomNotificationSubscription
     */
    'enabled': boolean;
    /**
     *
     * @type {NotificationChannel}
     * @memberof CustomNotificationSubscription
     */
    'notificationChannel': NotificationChannel;
}
/**
 *
 * @export
 * @interface CustomNotificationSubscriptionList
 */
export interface CustomNotificationSubscriptionList {
    /**
     *
     * @type {Array<CustomNotificationSubscription>}
     * @memberof CustomNotificationSubscriptionList
     */
    'items': Array<CustomNotificationSubscription>;
}
/**
 * @type CwlAnalysisInput
 * This object contains a \"oneOf\" construct. With the \"objectType\" attribute you can specify which object type you want to provide. Use \"STRUCTURED\" for type \"CreateAnalysisStructuredInput\" or use \"JSON\" for type \"CreateAnalysisJsonInput\".
 * @export
 */
export declare type CwlAnalysisInput = CwlAnalysisJsonInput | CwlAnalysisStructuredInput;
/**
 *
 * @export
 * @interface CwlAnalysisJsonInput
 */
export interface CwlAnalysisJsonInput {
    /**
     *
     * @type {string}
     * @memberof CwlAnalysisJsonInput
     */
    'objectType': CwlAnalysisJsonInputObjectTypeEnum;
    /**
     * Contains the input JSON, as an escaped JSON String.
     * @type {string}
     * @memberof CwlAnalysisJsonInput
     */
    'inputJson': string;
    /**
     *
     * @type {Array<string>}
     * @memberof CwlAnalysisJsonInput
     */
    'dataIds'?: Array<string> | null;
}
export declare const CwlAnalysisJsonInputObjectTypeEnum: {
    readonly Structured: "STRUCTURED";
    readonly Json: "JSON";
};
export declare type CwlAnalysisJsonInputObjectTypeEnum = typeof CwlAnalysisJsonInputObjectTypeEnum[keyof typeof CwlAnalysisJsonInputObjectTypeEnum];
/**
 *
 * @export
 * @interface CwlAnalysisStructuredInput
 */
export interface CwlAnalysisStructuredInput {
    /**
     *
     * @type {string}
     * @memberof CwlAnalysisStructuredInput
     */
    'objectType': CwlAnalysisStructuredInputObjectTypeEnum;
    /**
     *
     * @type {Array<AnalysisDataInput>}
     * @memberof CwlAnalysisStructuredInput
     */
    'inputs': Array<AnalysisDataInput>;
    /**
     *
     * @type {Array<AnalysisParameter>}
     * @memberof CwlAnalysisStructuredInput
     */
    'parameters'?: Array<AnalysisParameter> | null;
    /**
     *
     * @type {Array<AnalysisReferenceDataParameter>}
     * @memberof CwlAnalysisStructuredInput
     */
    'referenceDataParameters'?: Array<AnalysisReferenceDataParameter> | null;
}
export declare const CwlAnalysisStructuredInputObjectTypeEnum: {
    readonly Structured: "STRUCTURED";
    readonly Json: "JSON";
};
export declare type CwlAnalysisStructuredInputObjectTypeEnum = typeof CwlAnalysisStructuredInputObjectTypeEnum[keyof typeof CwlAnalysisStructuredInputObjectTypeEnum];
/**
 *
 * @export
 * @interface CwlToolDefinitionList
 */
export interface CwlToolDefinitionList {
    /**
     *
     * @type {Array<CWLToolDefinition>}
     * @memberof CwlToolDefinitionList
     */
    'items': Array<CWLToolDefinition>;
}
/**
 *
 * @export
 * @interface Data
 */
export interface Data {
    /**
     * The id of the file/folder as it was uploaded.
     * @type {string}
     * @memberof Data
     */
    'id': string;
    /**
     *
     * @type {DataDetails}
     * @memberof Data
     */
    'details'?: DataDetails | null;
}
/**
 * The details of this data. This object is optional because it is possible that these details are deleted.
 * @export
 * @interface DataDetails
 */
export interface DataDetails {
    /**
     *
     * @type {string}
     * @memberof DataDetails
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof DataDetails
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof DataDetails
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof DataDetails
     */
    'tenantName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof DataDetails
     */
    'owningProjectId': string;
    /**
     * The name of the file/folder as it was uploaded.
     * @type {string}
     * @memberof DataDetails
     */
    'name': string;
    /**
     * The user friendly path of the parent of this data.
     * @type {string}
     * @memberof DataDetails
     */
    'path'?: string | null;
    /**
     * The size of the file in bytes. Folders do not have a size.
     * @type {number}
     * @memberof DataDetails
     */
    'fileSizeInBytes'?: number | null;
    /**
     *
     * @type {string}
     * @memberof DataDetails
     */
    'status': DataDetailsStatusEnum;
    /**
     *
     * @type {DataTag}
     * @memberof DataDetails
     */
    'tags': DataTag;
    /**
     *
     * @type {DataFormat}
     * @memberof DataDetails
     */
    'format'?: DataFormat | null;
    /**
     *
     * @type {string}
     * @memberof DataDetails
     */
    'dataType': DataDetailsDataTypeEnum;
    /**
     * The file\'s ETag, as received from the cloud provider. Not to be confused with the ETag reponse header of this API.
     * @type {string}
     * @memberof DataDetails
     */
    'objectETag'?: string | null;
    /**
     * Specifies when the data object was stored for the first time
     * @type {string}
     * @memberof DataDetails
     */
    'storedForTheFirstTimeAt'?: string | null;
    /**
     *
     * @type {Region}
     * @memberof DataDetails
     */
    'region'?: Region;
    /**
     * Specifies when the data object will be archived.
     * @type {string}
     * @memberof DataDetails
     */
    'willBeArchivedAt'?: string | null;
    /**
     * Specifies when the data object will be deleted.
     * @type {string}
     * @memberof DataDetails
     */
    'willBeDeletedAt'?: string | null;
}
export declare const DataDetailsStatusEnum: {
    readonly Partial: "PARTIAL";
    readonly Available: "AVAILABLE";
    readonly Archiving: "ARCHIVING";
    readonly Archived: "ARCHIVED";
    readonly Unarchiving: "UNARCHIVING";
    readonly Deleting: "DELETING";
};
export declare type DataDetailsStatusEnum = typeof DataDetailsStatusEnum[keyof typeof DataDetailsStatusEnum];
export declare const DataDetailsDataTypeEnum: {
    readonly File: "FILE";
    readonly Folder: "FOLDER";
};
export declare type DataDetailsDataTypeEnum = typeof DataDetailsDataTypeEnum[keyof typeof DataDetailsDataTypeEnum];
/**
 *
 * @export
 * @interface DataFormat
 */
export interface DataFormat {
    /**
     *
     * @type {string}
     * @memberof DataFormat
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof DataFormat
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof DataFormat
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof DataFormat
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof DataFormat
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof DataFormat
     */
    'tenantName'?: string | null;
    /**
     * The code of the format. For example: FASTQ, BAM, ...
     * @type {string}
     * @memberof DataFormat
     */
    'code': string;
    /**
     *
     * @type {string}
     * @memberof DataFormat
     */
    'description'?: string | null;
    /**
     *
     * @type {string}
     * @memberof DataFormat
     */
    'mimeType'?: string | null;
}
/**
 *
 * @export
 * @interface DataFormatPagedList
 */
export interface DataFormatPagedList {
    /**
     *
     * @type {Array<DataFormat>}
     * @memberof DataFormatPagedList
     */
    'items': Array<DataFormat>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof DataFormatPagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof DataFormatPagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof DataFormatPagedList
     */
    'totalItemCount'?: number | null;
}
/**
 *
 * @export
 * @interface DataList
 */
export interface DataList {
    /**
     *
     * @type {Array<Data>}
     * @memberof DataList
     */
    'items': Array<Data>;
}
/**
 *
 * @export
 * @interface DataPagedList
 */
export interface DataPagedList {
    /**
     *
     * @type {Array<Data>}
     * @memberof DataPagedList
     */
    'items': Array<Data>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof DataPagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof DataPagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof DataPagedList
     */
    'totalItemCount'?: number | null;
}
/**
 *
 * @export
 * @interface DataTag
 */
export interface DataTag {
    /**
     *
     * @type {Array<string>}
     * @memberof DataTag
     */
    'technicalTags'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof DataTag
     */
    'userTags'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof DataTag
     */
    'connectorTags'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof DataTag
     */
    'runInTags'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof DataTag
     */
    'runOutTags'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof DataTag
     */
    'referenceTags'?: Array<string>;
}
/**
 *
 * @export
 * @interface DataTransfer
 */
export interface DataTransfer {
    /**
     *
     * @type {string}
     * @memberof DataTransfer
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof DataTransfer
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof DataTransfer
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof DataTransfer
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof DataTransfer
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof DataTransfer
     */
    'tenantName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof DataTransfer
     */
    'reference': string;
    /**
     *
     * @type {string}
     * @memberof DataTransfer
     */
    'direction': DataTransferDirectionEnum;
    /**
     *
     * @type {Connector}
     * @memberof DataTransfer
     */
    'connector'?: Connector | null;
    /**
     *
     * @type {string}
     * @memberof DataTransfer
     */
    'protocol'?: DataTransferProtocolEnum;
    /**
     * The data transferred so far in bytes.
     * @type {number}
     * @memberof DataTransfer
     */
    'dataTransferred': number;
    /**
     *
     * @type {string}
     * @memberof DataTransfer
     */
    'status': DataTransferStatusEnum;
    /**
     * A message explaining the reason why the transfer is in the current status.
     * @type {string}
     * @memberof DataTransfer
     */
    'statusMessage'?: string | null;
    /**
     * The overall duration of of the transfer defined in seconds.
     * @type {number}
     * @memberof DataTransfer
     */
    'duration'?: number | null;
    /**
     *
     * @type {Project}
     * @memberof DataTransfer
     */
    'project'?: Project;
    /**
     *
     * @type {Data}
     * @memberof DataTransfer
     */
    'data': Data;
}
export declare const DataTransferDirectionEnum: {
    readonly Upload: "UPLOAD";
    readonly Download: "DOWNLOAD";
    readonly Import: "IMPORT";
};
export declare type DataTransferDirectionEnum = typeof DataTransferDirectionEnum[keyof typeof DataTransferDirectionEnum];
export declare const DataTransferProtocolEnum: {
    readonly Https: "HTTPS";
};
export declare type DataTransferProtocolEnum = typeof DataTransferProtocolEnum[keyof typeof DataTransferProtocolEnum];
export declare const DataTransferStatusEnum: {
    readonly Requested: "REQUESTED";
    readonly Ongoing: "ONGOING";
    readonly Succeeded: "SUCCEEDED";
    readonly Failed: "FAILED";
    readonly Aborted: "ABORTED";
    readonly Abortrequested: "ABORTREQUESTED";
    readonly Scheduled: "SCHEDULED";
};
export declare type DataTransferStatusEnum = typeof DataTransferStatusEnum[keyof typeof DataTransferStatusEnum];
/**
 *
 * @export
 * @interface DataTransfers
 */
export interface DataTransfers {
    /**
     *
     * @type {Array<DataTransfer>}
     * @memberof DataTransfers
     */
    'dataTransfers': Array<DataTransfer>;
}
/**
 *
 * @export
 * @interface Download
 */
export interface Download {
    /**
     * A pre-signed url which is temporarily available for downloading the data.
     * @type {string}
     * @memberof Download
     */
    'url': string;
}
/**
 *
 * @export
 * @interface DownloadRule
 */
export interface DownloadRule {
    /**
     *
     * @type {string}
     * @memberof DownloadRule
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof DownloadRule
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof DownloadRule
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof DownloadRule
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof DownloadRule
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof DownloadRule
     */
    'tenantName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof DownloadRule
     */
    'code': string;
    /**
     *
     * @type {boolean}
     * @memberof DownloadRule
     */
    'active'?: boolean | null;
    /**
     *
     * @type {string}
     * @memberof DownloadRule
     */
    'description'?: string | null;
    /**
     * Defines the order of the rule.
     * @type {number}
     * @memberof DownloadRule
     */
    'sequence': number;
    /**
     * Regular expression to select which format this rule applies to.
     * @type {string}
     * @memberof DownloadRule
     */
    'formatCode'?: string | null;
    /**
     * Regular expression to select which project this rule applies to.
     * @type {string}
     * @memberof DownloadRule
     */
    'projectName'?: string | null;
    /**
     * The local folder where to write the data.
     * @type {string}
     * @memberof DownloadRule
     */
    'targetLocalFolder': string;
    /**
     * Will allow the filename to be modified including a set of variables
     * @type {string}
     * @memberof DownloadRule
     */
    'fileNameExpression'?: string | null;
}
/**
 *
 * @export
 * @interface DownloadRuleList
 */
export interface DownloadRuleList {
    /**
     *
     * @type {Array<DownloadRule>}
     * @memberof DownloadRuleList
     */
    'items': Array<DownloadRule>;
}
/**
 *
 * @export
 * @interface EventCode
 */
export interface EventCode {
    /**
     * The event code that can be used for creating event subscriptions
     * @type {string}
     * @memberof EventCode
     */
    'eventCode': string;
    /**
     * A short description about the event code
     * @type {string}
     * @memberof EventCode
     */
    'description': string;
}
/**
 *
 * @export
 * @interface EventCodeList
 */
export interface EventCodeList {
    /**
     *
     * @type {Array<EventCode>}
     * @memberof EventCodeList
     */
    'items': Array<EventCode>;
}
/**
 *
 * @export
 * @interface EventLog
 */
export interface EventLog {
    /**
     *
     * @type {string}
     * @memberof EventLog
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof EventLog
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof EventLog
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof EventLog
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof EventLog
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof EventLog
     */
    'tenantName'?: string | null;
    /**
     * The code of the event
     * @type {string}
     * @memberof EventLog
     */
    'code': string;
    /**
     * The details of the event
     * @type {string}
     * @memberof EventLog
     */
    'description': string;
    /**
     * The type of the event
     * @type {string}
     * @memberof EventLog
     */
    'eventTypeCategory': EventLogEventTypeCategoryEnum;
    /**
     *
     * @type {string}
     * @memberof EventLog
     */
    'userId': string;
}
export declare const EventLogEventTypeCategoryEnum: {
    readonly Error: "ERROR";
    readonly Warn: "WARN";
    readonly Info: "INFO";
};
export declare type EventLogEventTypeCategoryEnum = typeof EventLogEventTypeCategoryEnum[keyof typeof EventLogEventTypeCategoryEnum];
/**
 *
 * @export
 * @interface EventLogList
 */
export interface EventLogList {
    /**
     *
     * @type {Array<EventLog>}
     * @memberof EventLogList
     */
    'items': Array<EventLog>;
}
/**
 *
 * @export
 * @interface ExecutionConfiguration
 */
export interface ExecutionConfiguration {
    /**
     * The name of the configuration
     * @type {string}
     * @memberof ExecutionConfiguration
     */
    'name': string;
    /**
     * Whether the configuration has multiple values
     * @type {boolean}
     * @memberof ExecutionConfiguration
     */
    'multiValue': boolean;
    /**
     * The configuration values
     * @type {Array<string>}
     * @memberof ExecutionConfiguration
     */
    'values': Array<string>;
}
/**
 *
 * @export
 * @interface ExecutionConfigurationList
 */
export interface ExecutionConfigurationList {
    /**
     *
     * @type {Array<ExecutionConfiguration>}
     * @memberof ExecutionConfigurationList
     */
    'items': Array<ExecutionConfiguration>;
}
/**
 *
 * @export
 * @interface Field
 */
export interface Field {
    /**
     *
     * @type {string}
     * @memberof Field
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Field
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof Field
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof Field
     */
    'fieldType'?: FieldFieldTypeEnum;
    /**
     *
     * @type {boolean}
     * @memberof Field
     */
    'required'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Field
     */
    'multivalued'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Field
     */
    'filledByPipeline'?: boolean;
    /**
     *
     * @type {Array<Field>}
     * @memberof Field
     */
    'fields'?: Array<Field>;
    /**
     *
     * @type {Array<string>}
     * @memberof Field
     */
    'enumerationValues'?: Array<string>;
}
export declare const FieldFieldTypeEnum: {
    readonly Text: "TEXT";
    readonly Numeric: "NUMERIC";
    readonly Boolean: "BOOLEAN";
    readonly Date: "DATE";
    readonly Enumeration: "ENUMERATION";
    readonly Fieldgroup: "FIELDGROUP";
    readonly PipelineReference: "PIPELINE_REFERENCE";
};
export declare type FieldFieldTypeEnum = typeof FieldFieldTypeEnum[keyof typeof FieldFieldTypeEnum];
/**
 * The field ID to be updated. Either the field ID or field name is required.
 * @export
 * @interface FieldId
 */
export interface FieldId {
    /**
     *
     * @type {string}
     * @memberof FieldId
     */
    'id': string;
}
/**
 *
 * @export
 * @interface FieldList
 */
export interface FieldList {
    /**
     *
     * @type {Array<Field>}
     * @memberof FieldList
     */
    'items': Array<Field>;
}
/**
 *
 * @export
 * @interface FindProjectSamples
 */
export interface FindProjectSamples {
    /**
     * Adds a condition on a string field.
     * @type {Array<FindSampleCondition>}
     * @memberof FindProjectSamples
     */
    'conditions': Array<FindSampleCondition>;
    /**
     * Adds a condition on a date metadate field. If both the dateBefore and dateAfter parameter are null it will return any sample that has no value for the date field.
     * @type {Array<FindSampleDateCondition>}
     * @memberof FindProjectSamples
     */
    'dateConditions': Array<FindSampleDateCondition>;
    /**
     * Adds a condition on a number metadata field. If both the lowerBoundary and upperBoundary parameter are null it will return any sample that has no value for the number field.
     * @type {Array<FindSampleNumberCondition>}
     * @memberof FindProjectSamples
     */
    'numberConditions': Array<FindSampleNumberCondition>;
    /**
     * Adds a condition on a boolean field.
     * @type {Array<FindSampleBooleanCondition>}
     * @memberof FindProjectSamples
     */
    'booleanConditions': Array<FindSampleBooleanCondition>;
    /**
     * Adds a fuzzy matching condition for the text on all string fields of the sample i.e. on both the fixed fields (name, description) as any metadata text field.
     * @type {string}
     * @memberof FindProjectSamples
     */
    'fullTextSearchString'?: string | null;
    /**
     * Indicates whether deleted samples should be included.
     * @type {boolean}
     * @memberof FindProjectSamples
     */
    'includeDeleted'?: boolean | null;
    /**
     * The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @type {Array<string>}
     * @memberof FindProjectSamples
     */
    'userTags'?: Array<string> | null;
    /**
     * How the usertags are filtered.
     * @type {string}
     * @memberof FindProjectSamples
     */
    'userTagMatchMode'?: FindProjectSamplesUserTagMatchModeEnum;
    /**
     * The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @type {Array<string>}
     * @memberof FindProjectSamples
     */
    'runInputTags'?: Array<string> | null;
    /**
     * How the runInputTags are filtered.
     * @type {string}
     * @memberof FindProjectSamples
     */
    'runInputTagMatchMode'?: FindProjectSamplesRunInputTagMatchModeEnum;
    /**
     * The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @type {Array<string>}
     * @memberof FindProjectSamples
     */
    'connectorTags'?: Array<string> | null;
    /**
     * How the connectorTags are filtered.
     * @type {string}
     * @memberof FindProjectSamples
     */
    'connectorTagMatchMode'?: FindProjectSamplesConnectorTagMatchModeEnum;
    /**
     * The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @type {Array<string>}
     * @memberof FindProjectSamples
     */
    'techTags'?: Array<string> | null;
    /**
     * How the technicalTags are filtered.
     * @type {string}
     * @memberof FindProjectSamples
     */
    'techTagMatchMode'?: FindProjectSamplesTechTagMatchModeEnum;
}
export declare const FindProjectSamplesUserTagMatchModeEnum: {
    readonly Exact: "EXACT";
    readonly Exclude: "EXCLUDE";
    readonly Fuzzy: "FUZZY";
};
export declare type FindProjectSamplesUserTagMatchModeEnum = typeof FindProjectSamplesUserTagMatchModeEnum[keyof typeof FindProjectSamplesUserTagMatchModeEnum];
export declare const FindProjectSamplesRunInputTagMatchModeEnum: {
    readonly Exact: "EXACT";
    readonly Exclude: "EXCLUDE";
    readonly Fuzzy: "FUZZY";
};
export declare type FindProjectSamplesRunInputTagMatchModeEnum = typeof FindProjectSamplesRunInputTagMatchModeEnum[keyof typeof FindProjectSamplesRunInputTagMatchModeEnum];
export declare const FindProjectSamplesConnectorTagMatchModeEnum: {
    readonly Exact: "EXACT";
    readonly Exclude: "EXCLUDE";
    readonly Fuzzy: "FUZZY";
};
export declare type FindProjectSamplesConnectorTagMatchModeEnum = typeof FindProjectSamplesConnectorTagMatchModeEnum[keyof typeof FindProjectSamplesConnectorTagMatchModeEnum];
export declare const FindProjectSamplesTechTagMatchModeEnum: {
    readonly Exact: "EXACT";
    readonly Exclude: "EXCLUDE";
    readonly Fuzzy: "FUZZY";
};
export declare type FindProjectSamplesTechTagMatchModeEnum = typeof FindProjectSamplesTechTagMatchModeEnum[keyof typeof FindProjectSamplesTechTagMatchModeEnum];
/**
 * Adds a condition on a boolean field.
 * @export
 * @interface FindSampleBooleanCondition
 */
export interface FindSampleBooleanCondition {
    /**
     *
     * @type {Field}
     * @memberof FindSampleBooleanCondition
     */
    'metadataField'?: Field;
    /**
     *
     * @type {string}
     * @memberof FindSampleBooleanCondition
     */
    'field'?: string | null;
    /**
     *
     * @type {string}
     * @memberof FindSampleBooleanCondition
     */
    'value'?: string | null;
}
/**
 * Adds a condition on a string field.
 * @export
 * @interface FindSampleCondition
 */
export interface FindSampleCondition {
    /**
     *
     * @type {FieldId}
     * @memberof FindSampleCondition
     */
    'metadataField'?: FieldId | null;
    /**
     *
     * @type {string}
     * @memberof FindSampleCondition
     */
    'field'?: string | null;
    /**
     * Defines how the value will be matched.
     * @type {string}
     * @memberof FindSampleCondition
     */
    'matchMode'?: FindSampleConditionMatchModeEnum;
    /**
     *
     * @type {Set<string>}
     * @memberof FindSampleCondition
     */
    'values': Set<string>;
}
export declare const FindSampleConditionMatchModeEnum: {
    readonly Exact: "EXACT";
    readonly Exclude: "EXCLUDE";
    readonly Fuzzy: "FUZZY";
};
export declare type FindSampleConditionMatchModeEnum = typeof FindSampleConditionMatchModeEnum[keyof typeof FindSampleConditionMatchModeEnum];
/**
 * Adds a condition on a date metadate field. If both the dateBefore and dateAfter parameter are null it will return any sample that has no value for the date field.
 * @export
 * @interface FindSampleDateCondition
 */
export interface FindSampleDateCondition {
    /**
     *
     * @type {FieldId}
     * @memberof FindSampleDateCondition
     */
    'metadataField'?: FieldId | null;
    /**
     *
     * @type {string}
     * @memberof FindSampleDateCondition
     */
    'field'?: string | null;
    /**
     *
     * @type {string}
     * @memberof FindSampleDateCondition
     */
    'beforeDate'?: string | null;
    /**
     *
     * @type {string}
     * @memberof FindSampleDateCondition
     */
    'afterDate'?: string | null;
}
/**
 * Adds a condition on a number metadata field. If both the lowerBoundary and upperBoundary parameter are null it will return any sample that has no value for the number field.
 * @export
 * @interface FindSampleNumberCondition
 */
export interface FindSampleNumberCondition {
    /**
     *
     * @type {FieldId}
     * @memberof FindSampleNumberCondition
     */
    'metadataField'?: FieldId | null;
    /**
     *
     * @type {string}
     * @memberof FindSampleNumberCondition
     */
    'field'?: string | null;
    /**
     *
     * @type {string}
     * @memberof FindSampleNumberCondition
     */
    'lowerBound'?: string | null;
    /**
     *
     * @type {string}
     * @memberof FindSampleNumberCondition
     */
    'upperBound'?: string | null;
}
/**
 *
 * @export
 * @interface FolderUploadSession
 */
export interface FolderUploadSession {
    /**
     * The id of the folder upload session.
     * @type {string}
     * @memberof FolderUploadSession
     */
    'id': string;
    /**
     * The time the folder upload session was created.
     * @type {string}
     * @memberof FolderUploadSession
     */
    'timeCreated': string;
    /**
     * The status of the folder upload session.
     * @type {string}
     * @memberof FolderUploadSession
     */
    'status': FolderUploadSessionStatusEnum;
    /**
     * The time the folder upload session will expire as it is only temporarily valid.
     * @type {string}
     * @memberof FolderUploadSession
     */
    'timeSessionExpires': string;
    /**
     * The time the folder upload session completed.
     * @type {string}
     * @memberof FolderUploadSession
     */
    'timeCompleted'?: string | null;
    /**
     * The time the folder upload session was closed.
     * @type {string}
     * @memberof FolderUploadSession
     */
    'timeClosed'?: string | null;
    /**
     *
     * @type {TempCredentials}
     * @memberof FolderUploadSession
     */
    'tempCredentials'?: TempCredentials | null;
}
export declare const FolderUploadSessionStatusEnum: {
    readonly Open: "OPEN";
    readonly Closed: "CLOSED";
    readonly Completed: "COMPLETED";
};
export declare type FolderUploadSessionStatusEnum = typeof FolderUploadSessionStatusEnum[keyof typeof FolderUploadSessionStatusEnum];
/**
 *
 * @export
 * @interface InlineView
 */
export interface InlineView {
    /**
     * A pre-signed url which is temporarily available for inline viewing the data.
     * @type {string}
     * @memberof InlineView
     */
    'url': string;
}
/**
 *
 * @export
 * @interface InputParameter
 */
export interface InputParameter {
    /**
     * The ID of the parameter
     * @type {string}
     * @memberof InputParameter
     */
    'id': string;
    /**
     * The code of the parameter
     * @type {string}
     * @memberof InputParameter
     */
    'code': string;
    /**
     * Indicates whether this parameter is required
     * @type {boolean}
     * @memberof InputParameter
     */
    'required': boolean;
    /**
     * Indicates whether multiple values are allowed for this parameter
     * @type {boolean}
     * @memberof InputParameter
     */
    'multiValue': boolean;
}
/**
 *
 * @export
 * @interface InputParameterList
 */
export interface InputParameterList {
    /**
     *
     * @type {Array<InputParameter>}
     * @memberof InputParameterList
     */
    'items': Array<InputParameter>;
}
/**
 *
 * @export
 * @interface InputPart
 */
export interface InputPart {
    /**
     *
     * @type {{ [key: string]: Array<string>; }}
     * @memberof InputPart
     */
    'headers'?: {
        [key: string]: Array<string>;
    };
    /**
     *
     * @type {InputPartMediaType}
     * @memberof InputPart
     */
    'mediaType'?: InputPartMediaType;
    /**
     *
     * @type {string}
     * @memberof InputPart
     */
    'bodyAsString'?: string;
    /**
     *
     * @type {boolean}
     * @memberof InputPart
     */
    'contentTypeFromMessage'?: boolean;
}
/**
 *
 * @export
 * @interface InputPartMediaType
 */
export interface InputPartMediaType {
    /**
     *
     * @type {string}
     * @memberof InputPartMediaType
     */
    'type'?: string;
    /**
     *
     * @type {string}
     * @memberof InputPartMediaType
     */
    'subtype'?: string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof InputPartMediaType
     */
    'parameters'?: {
        [key: string]: string;
    };
    /**
     *
     * @type {boolean}
     * @memberof InputPartMediaType
     */
    'wildcardType'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof InputPartMediaType
     */
    'wildcardSubtype'?: boolean;
}
/**
 *
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * The name of the link
     * @type {string}
     * @memberof Link
     */
    'name': string;
    /**
     * The url of the link
     * @type {string}
     * @memberof Link
     */
    'url': string;
}
/**
 *
 * @export
 * @interface Links
 */
export interface Links {
    /**
     *
     * @type {Array<Link>}
     * @memberof Links
     */
    'links'?: Array<Link>;
    /**
     *
     * @type {Array<Link>}
     * @memberof Links
     */
    'licenses'?: Array<Link>;
    /**
     *
     * @type {Array<Link>}
     * @memberof Links
     */
    'homepages'?: Array<Link>;
    /**
     *
     * @type {Array<Link>}
     * @memberof Links
     */
    'publications'?: Array<Link>;
}
/**
 *
 * @export
 * @interface LoadDataInBaseRequest
 */
export interface LoadDataInBaseRequest {
    /**
     * Enable to accept rows that are missing trailing optional columns. Missing values will be treated as nulls.
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'allowJaggedRows'?: boolean | null;
    /**
     * Enable to include newlines contained in quoted data sections in the cells value. When disabled, newlines will signal a new row
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'allowQuotedNewlines'?: boolean | null;
    /**
     * ID of the data to load into the table
     * @type {string}
     * @memberof LoadDataInBaseRequest
     */
    'dataId': string;
    /**
     * field delimiter
     * @type {string}
     * @memberof LoadDataInBaseRequest
     */
    'delimiter'?: string | null;
    /**
     * Encoding
     * @type {string}
     * @memberof LoadDataInBaseRequest
     */
    'encoding'?: LoadDataInBaseRequestEncodingEnum;
    /**
     * When false (default): the data will not be loaded if it was already previously loaded to table ; when true, the data will be loaded even if already loaded in the past
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'forceLoad'?: boolean | null;
    /**
     * number of rows to skip (usually for headers)
     * @type {number}
     * @memberof LoadDataInBaseRequest
     */
    'headerRowsToSkip'?: number | null;
    /**
     * When enabled, rows with extra column values that do not match the schema will be ignored and will not be loaded into the table
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'ignoreUnknownValues'?: boolean;
    /**
     * Include references
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'includeReferences'?: boolean | null;
    /**
     * Include Data Reference
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'includeDataReference'?: boolean | null;
    /**
     * Include Sample Reference
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'includeSampleReference'?: boolean | null;
    /**
     * Include Pipeline Reference
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'includePipelineReference'?: boolean | null;
    /**
     * Include Pipeline Execution Reference
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'includePipelineExecutionReference'?: boolean | null;
    /**
     * Include Tenant Reference
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'includeTenantReference'?: boolean | null;
    /**
     * Specifies a string that represents a null value in a CSV/TSV file.
     * @type {string}
     * @memberof LoadDataInBaseRequest
     */
    'nullMarker'?: string | null;
    /**
     * The maximum number of bad records that Base can ignore when running the job
     * @type {number}
     * @memberof LoadDataInBaseRequest
     */
    'numberOfErrorsAllowed'?: number | null;
    /**
     * The value that is used to quote data sections in a CSV/TSV file
     * @type {string}
     * @memberof LoadDataInBaseRequest
     */
    'quote'?: string | null;
    /**
     * specifies how to write data in the table.
     * @type {string}
     * @memberof LoadDataInBaseRequest
     */
    'writePreference'?: LoadDataInBaseRequestWritePreferenceEnum;
}
export declare const LoadDataInBaseRequestEncodingEnum: {
    readonly Utf8: "UTF8";
    readonly Iso88591: "ISO88591";
};
export declare type LoadDataInBaseRequestEncodingEnum = typeof LoadDataInBaseRequestEncodingEnum[keyof typeof LoadDataInBaseRequestEncodingEnum];
export declare const LoadDataInBaseRequestWritePreferenceEnum: {
    readonly Writeifempty: "WRITEIFEMPTY";
    readonly Appendtotable: "APPENDTOTABLE";
    readonly Overwritetable: "OVERWRITETABLE";
};
export declare type LoadDataInBaseRequestWritePreferenceEnum = typeof LoadDataInBaseRequestWritePreferenceEnum[keyof typeof LoadDataInBaseRequestWritePreferenceEnum];
/**
 * The metadata of the sample
 * @export
 * @interface MetadataField
 */
export interface MetadataField {
    /**
     *
     * @type {string}
     * @memberof MetadataField
     */
    'id': string;
    /**
     *
     * @type {number}
     * @memberof MetadataField
     */
    'index'?: number;
    /**
     *
     * @type {string}
     * @memberof MetadataField
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof MetadataField
     */
    'fieldType'?: MetadataFieldFieldTypeEnum;
    /**
     *
     * @type {Array<string>}
     * @memberof MetadataField
     */
    'values'?: Array<string>;
    /**
     *
     * @type {Array<MetadataField>}
     * @memberof MetadataField
     */
    'groupValues'?: Array<MetadataField>;
}
export declare const MetadataFieldFieldTypeEnum: {
    readonly Text: "TEXT";
    readonly Numeric: "NUMERIC";
    readonly Boolean: "BOOLEAN";
    readonly Date: "DATE";
    readonly Group: "GROUP";
};
export declare type MetadataFieldFieldTypeEnum = typeof MetadataFieldFieldTypeEnum[keyof typeof MetadataFieldFieldTypeEnum];
/**
 *
 * @export
 * @interface MetadataModel
 */
export interface MetadataModel {
    /**
     *
     * @type {string}
     * @memberof MetadataModel
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof MetadataModel
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof MetadataModel
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof MetadataModel
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof MetadataModel
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof MetadataModel
     */
    'tenantName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof MetadataModel
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof MetadataModel
     */
    'description'?: string | null;
    /**
     *
     * @type {string}
     * @memberof MetadataModel
     */
    'state': MetadataModelStateEnum;
    /**
     *
     * @type {string}
     * @memberof MetadataModel
     */
    'parentModelId'?: string | null;
}
export declare const MetadataModelStateEnum: {
    readonly Draft: "DRAFT";
    readonly Published: "PUBLISHED";
};
export declare type MetadataModelStateEnum = typeof MetadataModelStateEnum[keyof typeof MetadataModelStateEnum];
/**
 *
 * @export
 * @interface MetadataModelList
 */
export interface MetadataModelList {
    /**
     *
     * @type {Array<MetadataModel>}
     * @memberof MetadataModelList
     */
    'items': Array<MetadataModel>;
}
/**
 *
 * @export
 * @interface Model
 */
export interface Model {
    /**
     *
     * @type {string}
     * @memberof Model
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Model
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof Model
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof Model
     */
    'state'?: ModelStateEnum;
    /**
     *
     * @type {Array<Model>}
     * @memberof Model
     */
    'models'?: Array<Model>;
    /**
     *
     * @type {Array<Field>}
     * @memberof Model
     */
    'fields'?: Array<Field>;
}
export declare const ModelStateEnum: {
    readonly Draft: "DRAFT";
    readonly Published: "PUBLISHED";
};
export declare type ModelStateEnum = typeof ModelStateEnum[keyof typeof ModelStateEnum];
/**
 *
 * @export
 * @interface MultipartFormDataInput
 */
export interface MultipartFormDataInput {
    /**
     *
     * @type {{ [key: string]: InputPart; }}
     * @memberof MultipartFormDataInput
     */
    'formData'?: {
        [key: string]: InputPart;
    };
    /**
     *
     * @type {{ [key: string]: Array<InputPart>; }}
     * @memberof MultipartFormDataInput
     */
    'formDataMap'?: {
        [key: string]: Array<InputPart>;
    };
    /**
     *
     * @type {Array<InputPart>}
     * @memberof MultipartFormDataInput
     */
    'parts'?: Array<InputPart>;
    /**
     *
     * @type {string}
     * @memberof MultipartFormDataInput
     */
    'preamble'?: string;
}
/**
 *
 * @export
 * @interface NextflowAnalysisInput
 */
export interface NextflowAnalysisInput {
    /**
     *
     * @type {Array<AnalysisDataInput>}
     * @memberof NextflowAnalysisInput
     */
    'inputs': Array<AnalysisDataInput>;
    /**
     *
     * @type {Array<AnalysisParameter>}
     * @memberof NextflowAnalysisInput
     */
    'parameters'?: Array<AnalysisParameter> | null;
    /**
     *
     * @type {Array<AnalysisReferenceDataParameter>}
     * @memberof NextflowAnalysisInput
     */
    'referenceDataParameters'?: Array<AnalysisReferenceDataParameter> | null;
}
/**
 *
 * @export
 * @interface NotificationChannel
 */
export interface NotificationChannel {
    /**
     *
     * @type {string}
     * @memberof NotificationChannel
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof NotificationChannel
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof NotificationChannel
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof NotificationChannel
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof NotificationChannel
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof NotificationChannel
     */
    'tenantName'?: string | null;
    /**
     * Should this channel be enabled or not?
     * @type {boolean}
     * @memberof NotificationChannel
     */
    'enabled': boolean;
    /**
     * The type of delivery target (MAIL, SQS, SNS, HTTP, ...)
     * @type {string}
     * @memberof NotificationChannel
     */
    'type': NotificationChannelTypeEnum;
    /**
     * The address where to send a notification to (email address, url, ...)
     * @type {string}
     * @memberof NotificationChannel
     */
    'address': string;
}
export declare const NotificationChannelTypeEnum: {
    readonly Mail: "MAIL";
    readonly Sqs: "SQS";
    readonly Sns: "SNS";
    readonly Http: "HTTP";
};
export declare type NotificationChannelTypeEnum = typeof NotificationChannelTypeEnum[keyof typeof NotificationChannelTypeEnum];
/**
 *
 * @export
 * @interface NotificationChannelList
 */
export interface NotificationChannelList {
    /**
     *
     * @type {Array<NotificationChannel>}
     * @memberof NotificationChannelList
     */
    'items': Array<NotificationChannel>;
}
/**
 *
 * @export
 * @interface NotificationSubscription
 */
export interface NotificationSubscription {
    /**
     *
     * @type {string}
     * @memberof NotificationSubscription
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof NotificationSubscription
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof NotificationSubscription
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof NotificationSubscription
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof NotificationSubscription
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof NotificationSubscription
     */
    'tenantName'?: string | null;
    /**
     * The event code to subscribe to
     * @type {string}
     * @memberof NotificationSubscription
     */
    'eventCode': string;
    /**
     * To be used when a notification applies to specific conditions.
     * @type {string}
     * @memberof NotificationSubscription
     */
    'filterExpression'?: string | null;
    /**
     * Should this subscription be enabled or not?
     * @type {boolean}
     * @memberof NotificationSubscription
     */
    'enabled': boolean;
    /**
     *
     * @type {NotificationChannel}
     * @memberof NotificationSubscription
     */
    'notificationChannel': NotificationChannel;
}
/**
 *
 * @export
 * @interface NotificationSubscriptionList
 */
export interface NotificationSubscriptionList {
    /**
     *
     * @type {Array<NotificationSubscription>}
     * @memberof NotificationSubscriptionList
     */
    'items': Array<NotificationSubscription>;
}
/**
 *
 * @export
 * @interface Pipeline
 */
export interface Pipeline {
    /**
     *
     * @type {string}
     * @memberof Pipeline
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Pipeline
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof Pipeline
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof Pipeline
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof Pipeline
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof Pipeline
     */
    'tenantName'?: string | null;
    /**
     * The code of the pipeline
     * @type {string}
     * @memberof Pipeline
     */
    'code': string;
    /**
     * The description of the pipeline
     * @type {string}
     * @memberof Pipeline
     */
    'description': string;
    /**
     * The language that is used by the pipeline
     * @type {string}
     * @memberof Pipeline
     */
    'language': PipelineLanguageEnum;
    /**
     *
     * @type {PipelineTag}
     * @memberof Pipeline
     */
    'pipelineTags': PipelineTag;
    /**
     *
     * @type {AnalysisStorage}
     * @memberof Pipeline
     */
    'analysisStorage': AnalysisStorage;
}
export declare const PipelineLanguageEnum: {
    readonly Cwl: "CWL";
    readonly Nextflow: "NEXTFLOW";
    readonly Unknown: "UNKNOWN";
};
export declare type PipelineLanguageEnum = typeof PipelineLanguageEnum[keyof typeof PipelineLanguageEnum];
/**
 *
 * @export
 * @interface PipelineBundle
 */
export interface PipelineBundle {
    /**
     *
     * @type {string}
     * @memberof PipelineBundle
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof PipelineBundle
     */
    'name': string;
    /**
     *
     * @type {number}
     * @memberof PipelineBundle
     */
    'maxNumberOfAllowedSlots'?: number | null;
    /**
     *
     * @type {Array<Pipeline>}
     * @memberof PipelineBundle
     */
    'activePipelines': Array<Pipeline>;
    /**
     *
     * @type {Array<Pipeline>}
     * @memberof PipelineBundle
     */
    'canceledPipelines': Array<Pipeline>;
    /**
     *
     * @type {Array<Pipeline>}
     * @memberof PipelineBundle
     */
    'retiredPipelines': Array<Pipeline>;
    /**
     *
     * @type {Array<Region>}
     * @memberof PipelineBundle
     */
    'regions': Array<Region>;
    /**
     *
     * @type {Array<AnalysisStorage>}
     * @memberof PipelineBundle
     */
    'analysisStorages': Array<AnalysisStorage>;
}
/**
 *
 * @export
 * @interface PipelineList
 */
export interface PipelineList {
    /**
     *
     * @type {Array<Pipeline>}
     * @memberof PipelineList
     */
    'items': Array<Pipeline>;
}
/**
 *
 * @export
 * @interface PipelineTag
 */
export interface PipelineTag {
    /**
     * Technical tags
     * @type {Array<string>}
     * @memberof PipelineTag
     */
    'technicalTags': Array<string>;
}
/**
 * RFC 7807 Problem object (https://tools.ietf.org/html/rfc7807)
 * @export
 * @interface Problem
 */
export interface Problem {
    /**
     *
     * @type {string}
     * @memberof Problem
     */
    'id'?: string;
    /**
     * A URI reference that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type. When this member is not present, its value is assumed to be \"about:blank\".
     * @type {string}
     * @memberof Problem
     */
    'type': string;
    /**
     * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation;
     * @type {string}
     * @memberof Problem
     */
    'title': string;
    /**
     * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
     * @type {number}
     * @memberof Problem
     */
    'status': number;
    /**
     * A human-readable explanation specific to this occurrence of the problem.
     * @type {string}
     * @memberof Problem
     */
    'detail'?: string;
    /**
     * A URI reference that identifies the specific occurrence of the problem.  It may or may not yield further information if dereferenced.
     * @type {string}
     * @memberof Problem
     */
    'instance'?: string;
    /**
     * Problem parameters for e.g. request body attribute validation. Not in scope of RFC 7807.
     * @type {{ [key: string]: string; }}
     * @memberof Problem
     */
    'parameters': {
        [key: string]: string;
    };
    /**
     *
     * @type {string}
     * @memberof Problem
     */
    'timestamp': string;
}
/**
 *
 * @export
 * @interface Project
 */
export interface Project {
    /**
     *
     * @type {string}
     * @memberof Project
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Project
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof Project
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof Project
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof Project
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof Project
     */
    'tenantName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * Indicates whether the project is active or hidden.
     * @type {boolean}
     * @memberof Project
     */
    'active': boolean;
    /**
     *
     * @type {string}
     * @memberof Project
     */
    'shortDescription'?: string | null;
    /**
     * Information about the project. Note that the value of this field can be arbitrary large.
     * @type {string}
     * @memberof Project
     */
    'information'?: string | null;
    /**
     *
     * @type {Region}
     * @memberof Project
     */
    'region': Region;
    /**
     * The billing mode of the project. It determines who pays for the costs linked to the project.
     * @type {string}
     * @memberof Project
     */
    'billingMode': ProjectBillingModeEnum;
    /**
     * Indicates whether the Data and Samples created in this Project can be linked to other Projects.
     * @type {boolean}
     * @memberof Project
     */
    'dataSharingEnabled'?: boolean | null;
    /**
     *
     * @type {ProjectTag}
     * @memberof Project
     */
    'tags': ProjectTag;
    /**
     *
     * @type {StorageBundle}
     * @memberof Project
     */
    'storageBundle'?: StorageBundle;
    /**
     *
     * @type {StorageConfiguration}
     * @memberof Project
     */
    'selfManagedStorageConfiguration'?: StorageConfiguration;
    /**
     *
     * @type {MetadataModel}
     * @memberof Project
     */
    'metadataModel'?: MetadataModel | null;
    /**
     *
     * @type {Application}
     * @memberof Project
     */
    'application'?: Application | null;
}
export declare const ProjectBillingModeEnum: {
    readonly Project: "PROJECT";
    readonly Tenant: "TENANT";
};
export declare type ProjectBillingModeEnum = typeof ProjectBillingModeEnum[keyof typeof ProjectBillingModeEnum];
/**
 *
 * @export
 * @interface ProjectBaseTable
 */
export interface ProjectBaseTable {
    /**
     *
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'tenantName'?: string | null;
    /**
     * The name of the table which should be used in writing queries
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'name': string;
    /**
     * The description of the table
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'description'?: string | null;
    /**
     * The type of the table
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'type': ProjectBaseTableTypeEnum;
    /**
     * The status of the table
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'status': ProjectBaseTableStatusEnum;
    /**
     * The number of record in the table
     * @type {number}
     * @memberof ProjectBaseTable
     */
    'numberOfRecords'?: number | null;
    /**
     * The amount of Data contained in this table in bytes
     * @type {number}
     * @memberof ProjectBaseTable
     */
    'dataSize'?: number | null;
}
export declare const ProjectBaseTableTypeEnum: {
    readonly Table: "TABLE";
    readonly View: "VIEW";
};
export declare type ProjectBaseTableTypeEnum = typeof ProjectBaseTableTypeEnum[keyof typeof ProjectBaseTableTypeEnum];
export declare const ProjectBaseTableStatusEnum: {
    readonly Available: "AVAILABLE";
    readonly Deleted: "DELETED";
    readonly Pending: "PENDING";
};
export declare type ProjectBaseTableStatusEnum = typeof ProjectBaseTableStatusEnum[keyof typeof ProjectBaseTableStatusEnum];
/**
 *
 * @export
 * @interface ProjectBaseTableList
 */
export interface ProjectBaseTableList {
    /**
     *
     * @type {Array<ProjectBaseTable>}
     * @memberof ProjectBaseTableList
     */
    'items': Array<ProjectBaseTable>;
}
/**
 *
 * @export
 * @interface ProjectData
 */
export interface ProjectData {
    /**
     *
     * @type {Data}
     * @memberof ProjectData
     */
    'data': Data;
    /**
     *
     * @type {string}
     * @memberof ProjectData
     */
    'projectId': string;
}
/**
 *
 * @export
 * @interface ProjectDataPagedList
 */
export interface ProjectDataPagedList {
    /**
     *
     * @type {Array<ProjectData>}
     * @memberof ProjectDataPagedList
     */
    'items': Array<ProjectData>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof ProjectDataPagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof ProjectDataPagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof ProjectDataPagedList
     */
    'totalItemCount'?: number | null;
}
/**
 *
 * @export
 * @interface ProjectList
 */
export interface ProjectList {
    /**
     *
     * @type {Array<Project>}
     * @memberof ProjectList
     */
    'items': Array<Project>;
}
/**
 *
 * @export
 * @interface ProjectPagedList
 */
export interface ProjectPagedList {
    /**
     *
     * @type {Array<Project>}
     * @memberof ProjectPagedList
     */
    'items': Array<Project>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof ProjectPagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof ProjectPagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof ProjectPagedList
     */
    'totalItemCount'?: number | null;
}
/**
 *
 * @export
 * @interface ProjectPermission
 */
export interface ProjectPermission {
    /**
     *
     * @type {string}
     * @memberof ProjectPermission
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof ProjectPermission
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof ProjectPermission
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof ProjectPermission
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof ProjectPermission
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof ProjectPermission
     */
    'tenantName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ProjectPermission
     */
    'roleProject': ProjectPermissionRoleProjectEnum;
    /**
     *
     * @type {string}
     * @memberof ProjectPermission
     */
    'roleFlow': ProjectPermissionRoleFlowEnum;
    /**
     *
     * @type {string}
     * @memberof ProjectPermission
     */
    'roleBase': ProjectPermissionRoleBaseEnum;
    /**
     *
     * @type {string}
     * @memberof ProjectPermission
     */
    'roleBench': ProjectPermissionRoleBenchEnum;
    /**
     *
     * @type {string}
     * @memberof ProjectPermission
     */
    'membershipType': ProjectPermissionMembershipTypeEnum;
    /**
     *
     * @type {User}
     * @memberof ProjectPermission
     */
    'user'?: User;
    /**
     * Only present when membershipType is EMAIL
     * @type {string}
     * @memberof ProjectPermission
     */
    'emailAddress'?: string | null;
    /**
     *
     * @type {Workgroup}
     * @memberof ProjectPermission
     */
    'workgroup'?: Workgroup;
    /**
     * Only present when membershipType is EMAIL
     * @type {boolean}
     * @memberof ProjectPermission
     */
    'invitationAccepted'?: boolean | null;
    /**
     * Only present when user is invited by EMAIL
     * @type {boolean}
     * @memberof ProjectPermission
     */
    'invitationRejected'?: boolean | null;
    /**
     *
     * @type {boolean}
     * @memberof ProjectPermission
     */
    'uploadAllowed': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ProjectPermission
     */
    'downloadAllowed': boolean;
}
export declare const ProjectPermissionRoleProjectEnum: {
    readonly None: "NONE";
    readonly Viewer: "VIEWER";
    readonly Contributor: "CONTRIBUTOR";
    readonly Administrator: "ADMINISTRATOR";
    readonly DataProvider: "DATA_PROVIDER";
};
export declare type ProjectPermissionRoleProjectEnum = typeof ProjectPermissionRoleProjectEnum[keyof typeof ProjectPermissionRoleProjectEnum];
export declare const ProjectPermissionRoleFlowEnum: {
    readonly None: "NONE";
    readonly Viewer: "VIEWER";
    readonly Contributor: "CONTRIBUTOR";
};
export declare type ProjectPermissionRoleFlowEnum = typeof ProjectPermissionRoleFlowEnum[keyof typeof ProjectPermissionRoleFlowEnum];
export declare const ProjectPermissionRoleBaseEnum: {
    readonly None: "NONE";
    readonly Viewer: "VIEWER";
    readonly Contributor: "CONTRIBUTOR";
};
export declare type ProjectPermissionRoleBaseEnum = typeof ProjectPermissionRoleBaseEnum[keyof typeof ProjectPermissionRoleBaseEnum];
export declare const ProjectPermissionRoleBenchEnum: {
    readonly None: "NONE";
    readonly Contributor: "CONTRIBUTOR";
};
export declare type ProjectPermissionRoleBenchEnum = typeof ProjectPermissionRoleBenchEnum[keyof typeof ProjectPermissionRoleBenchEnum];
export declare const ProjectPermissionMembershipTypeEnum: {
    readonly User: "USER";
    readonly Email: "EMAIL";
    readonly Workgroup: "WORKGROUP";
};
export declare type ProjectPermissionMembershipTypeEnum = typeof ProjectPermissionMembershipTypeEnum[keyof typeof ProjectPermissionMembershipTypeEnum];
/**
 *
 * @export
 * @interface ProjectPermissionList
 */
export interface ProjectPermissionList {
    /**
     *
     * @type {Array<ProjectPermission>}
     * @memberof ProjectPermissionList
     */
    'items': Array<ProjectPermission>;
}
/**
 *
 * @export
 * @interface ProjectPipeline
 */
export interface ProjectPipeline {
    /**
     *
     * @type {Pipeline}
     * @memberof ProjectPipeline
     */
    'pipeline': Pipeline;
    /**
     *
     * @type {string}
     * @memberof ProjectPipeline
     */
    'projectId': string;
    /**
     *
     * @type {BundleList}
     * @memberof ProjectPipeline
     */
    'bundleLinks': BundleList;
}
/**
 *
 * @export
 * @interface ProjectPipelineList
 */
export interface ProjectPipelineList {
    /**
     *
     * @type {Array<ProjectPipeline>}
     * @memberof ProjectPipelineList
     */
    'items': Array<ProjectPipeline>;
}
/**
 *
 * @export
 * @interface ProjectSample
 */
export interface ProjectSample {
    /**
     *
     * @type {Sample}
     * @memberof ProjectSample
     */
    'sample': Sample;
    /**
     *
     * @type {string}
     * @memberof ProjectSample
     */
    'projectId': string;
}
/**
 *
 * @export
 * @interface ProjectSamplePagedList
 */
export interface ProjectSamplePagedList {
    /**
     *
     * @type {Array<ProjectSample>}
     * @memberof ProjectSamplePagedList
     */
    'items': Array<ProjectSample>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof ProjectSamplePagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof ProjectSamplePagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof ProjectSamplePagedList
     */
    'totalItemCount'?: number | null;
}
/**
 *
 * @export
 * @interface ProjectTag
 */
export interface ProjectTag {
    /**
     *
     * @type {Array<string>}
     * @memberof ProjectTag
     */
    'technicalTags': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ProjectTag
     */
    'userTags': Array<string>;
}
/**
 * In case of providing the credentialsFormat = rclone, this will contain the credentials for uploading or downloading the data in rclone format.
 * @export
 * @interface RcloneTempCredentials
 */
export interface RcloneTempCredentials {
    /**
     * The config in key value format.
     * @type {{ [key: string]: string; }}
     * @memberof RcloneTempCredentials
     */
    'config': {
        [key: string]: string;
    };
    /**
     * The prefix of the file path.
     * @type {string}
     * @memberof RcloneTempCredentials
     */
    'filePathPrefix': string;
    /**
     * The type of the object storage.
     * @type {string}
     * @memberof RcloneTempCredentials
     */
    'storageType': string;
    /**
     * The timestamp when the credentials expire.
     * @type {string}
     * @memberof RcloneTempCredentials
     */
    'expirationTime': string;
    /**
     * The folder upload session id which can be used after upload to complete the upload session.
     * @type {string}
     * @memberof RcloneTempCredentials
     */
    'uploadSessionId'?: string | null;
}
/**
 *
 * @export
 * @interface ReferenceData
 */
export interface ReferenceData {
    /**
     *
     * @type {string}
     * @memberof ReferenceData
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof ReferenceData
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof ReferenceData
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof ReferenceData
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof ReferenceData
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof ReferenceData
     */
    'tenantName'?: string | null;
    /**
     * The name of the reference set
     * @type {string}
     * @memberof ReferenceData
     */
    'name': string;
    /**
     *
     * @type {Species}
     * @memberof ReferenceData
     */
    'species'?: Species | null;
    /**
     *
     * @type {DataFormat}
     * @memberof ReferenceData
     */
    'dataFormat'?: DataFormat | null;
    /**
     * The version of the reference set
     * @type {string}
     * @memberof ReferenceData
     */
    'version': string;
    /**
     *
     * @type {TypeList}
     * @memberof ReferenceData
     */
    'typeList': TypeList;
}
/**
 *
 * @export
 * @interface ReferenceDataList
 */
export interface ReferenceDataList {
    /**
     *
     * @type {Array<ReferenceData>}
     * @memberof ReferenceDataList
     */
    'items': Array<ReferenceData>;
}
/**
 *
 * @export
 * @interface ReferenceSet
 */
export interface ReferenceSet {
    /**
     *
     * @type {string}
     * @memberof ReferenceSet
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof ReferenceSet
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof ReferenceSet
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof ReferenceSet
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof ReferenceSet
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof ReferenceSet
     */
    'tenantName'?: string | null;
    /**
     * The name of the reference set
     * @type {string}
     * @memberof ReferenceSet
     */
    'name': string;
    /**
     *
     * @type {ReferenceDataList}
     * @memberof ReferenceSet
     */
    'referenceDataList': ReferenceDataList;
}
/**
 *
 * @export
 * @interface ReferenceSetList
 */
export interface ReferenceSetList {
    /**
     *
     * @type {Array<ReferenceSet>}
     * @memberof ReferenceSetList
     */
    'items': Array<ReferenceSet>;
}
/**
 *
 * @export
 * @interface Region
 */
export interface Region {
    /**
     *
     * @type {string}
     * @memberof Region
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Region
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof Region
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof Region
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof Region
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof Region
     */
    'tenantName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof Region
     */
    'code': string;
    /**
     *
     * @type {Country}
     * @memberof Region
     */
    'country': Country | null;
    /**
     *
     * @type {string}
     * @memberof Region
     */
    'cityName': string;
}
/**
 *
 * @export
 * @interface RegionList
 */
export interface RegionList {
    /**
     *
     * @type {Array<Region>}
     * @memberof RegionList
     */
    'items': Array<Region>;
}
/**
 *
 * @export
 * @interface Sample
 */
export interface Sample {
    /**
     *
     * @type {string}
     * @memberof Sample
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Sample
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof Sample
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof Sample
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof Sample
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof Sample
     */
    'tenantName'?: string | null;
    /**
     * The name of the sample
     * @type {string}
     * @memberof Sample
     */
    'name': string;
    /**
     * The description of the sample
     * @type {string}
     * @memberof Sample
     */
    'description'?: string | null;
    /**
     *
     * @type {SampleTag}
     * @memberof Sample
     */
    'tags': SampleTag;
    /**
     *
     * @type {Region}
     * @memberof Sample
     */
    'region': Region;
    /**
     *
     * @type {string}
     * @memberof Sample
     */
    'status': SampleStatusEnum;
    /**
     * Whether the metadata is valid
     * @type {boolean}
     * @memberof Sample
     */
    'metadataValid': boolean;
    /**
     * The metadata of the sample
     * @type {Array<MetadataField>}
     * @memberof Sample
     */
    'metadata': Array<MetadataField>;
}
export declare const SampleStatusEnum: {
    readonly Deleted: "DELETED";
    readonly Available: "AVAILABLE";
    readonly Partial: "PARTIAL";
};
export declare type SampleStatusEnum = typeof SampleStatusEnum[keyof typeof SampleStatusEnum];
/**
 *
 * @export
 * @interface SampleHistory
 */
export interface SampleHistory {
    /**
     * When the change was made
     * @type {string}
     * @memberof SampleHistory
     */
    'occurredAt': string;
    /**
     * The user that made the change
     * @type {string}
     * @memberof SampleHistory
     */
    'user'?: string | null;
    /**
     * In which execution context the change was made
     * @type {string}
     * @memberof SampleHistory
     */
    'run'?: string | null;
    /**
     * In which context the change was made
     * @type {string}
     * @memberof SampleHistory
     */
    'source': string;
    /**
     * What was changed
     * @type {string}
     * @memberof SampleHistory
     */
    'text': string;
    /**
     * In which project context the change was made
     * @type {string}
     * @memberof SampleHistory
     */
    'project'?: string | null;
    /**
     * In which model context the change was made
     * @type {number}
     * @memberof SampleHistory
     */
    'model'?: number | null;
}
/**
 *
 * @export
 * @interface SampleHistoryList
 */
export interface SampleHistoryList {
    /**
     *
     * @type {Array<SampleHistory>}
     * @memberof SampleHistoryList
     */
    'items': Array<SampleHistory>;
}
/**
 *
 * @export
 * @interface SamplePagedList
 */
export interface SamplePagedList {
    /**
     *
     * @type {Array<Sample>}
     * @memberof SamplePagedList
     */
    'items': Array<Sample>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof SamplePagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof SamplePagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof SamplePagedList
     */
    'totalItemCount'?: number | null;
}
/**
 *
 * @export
 * @interface SampleTag
 */
export interface SampleTag {
    /**
     *
     * @type {Array<string>}
     * @memberof SampleTag
     */
    'technicalTags': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SampleTag
     */
    'userTags': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SampleTag
     */
    'connectorTags': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SampleTag
     */
    'runInTags': Array<string>;
}
/**
 *
 * @export
 * @interface ScheduleDownload
 */
export interface ScheduleDownload {
    /**
     *
     * @type {string}
     * @memberof ScheduleDownload
     */
    'connectorId'?: string;
    /**
     *
     * @type {string}
     * @memberof ScheduleDownload
     */
    'protocol'?: ScheduleDownloadProtocolEnum;
    /**
     *
     * @type {string}
     * @memberof ScheduleDownload
     */
    'localPath'?: string;
    /**
     *
     * @type {boolean}
     * @memberof ScheduleDownload
     */
    'disableHashing'?: boolean;
}
export declare const ScheduleDownloadProtocolEnum: {
    readonly Https: "HTTPS";
};
export declare type ScheduleDownloadProtocolEnum = typeof ScheduleDownloadProtocolEnum[keyof typeof ScheduleDownloadProtocolEnum];
/**
 *
 * @export
 * @interface SearchMatchingActivationCodesForCwlAnalysis
 */
export interface SearchMatchingActivationCodesForCwlAnalysis {
    /**
     *
     * @type {string}
     * @memberof SearchMatchingActivationCodesForCwlAnalysis
     */
    'projectId': string;
    /**
     *
     * @type {string}
     * @memberof SearchMatchingActivationCodesForCwlAnalysis
     */
    'pipelineId': string;
    /**
     *
     * @type {CwlAnalysisInput}
     * @memberof SearchMatchingActivationCodesForCwlAnalysis
     */
    'analysisInput': CwlAnalysisInput;
}
/**
 *
 * @export
 * @interface SearchMatchingActivationCodesForNextflowAnalysis
 */
export interface SearchMatchingActivationCodesForNextflowAnalysis {
    /**
     *
     * @type {string}
     * @memberof SearchMatchingActivationCodesForNextflowAnalysis
     */
    'projectId': string;
    /**
     *
     * @type {string}
     * @memberof SearchMatchingActivationCodesForNextflowAnalysis
     */
    'pipelineId': string;
    /**
     *
     * @type {NextflowAnalysisInput}
     * @memberof SearchMatchingActivationCodesForNextflowAnalysis
     */
    'analysisInput': NextflowAnalysisInput;
}
/**
 *
 * @export
 * @interface Species
 */
export interface Species {
    /**
     *
     * @type {string}
     * @memberof Species
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Species
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof Species
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof Species
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof Species
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof Species
     */
    'tenantName'?: string | null;
    /**
     * The name of the species
     * @type {string}
     * @memberof Species
     */
    'name': string;
}
/**
 *
 * @export
 * @interface StorageBundle
 */
export interface StorageBundle {
    /**
     *
     * @type {string}
     * @memberof StorageBundle
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof StorageBundle
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof StorageBundle
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof StorageBundle
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof StorageBundle
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof StorageBundle
     */
    'tenantName'?: string | null;
    /**
     * The name of the storage bundle
     * @type {string}
     * @memberof StorageBundle
     */
    'bundleName': string;
    /**
     * The name of the parent entitlement
     * @type {string}
     * @memberof StorageBundle
     */
    'entitlementName': string;
    /**
     *
     * @type {Region}
     * @memberof StorageBundle
     */
    'region': Region;
}
/**
 *
 * @export
 * @interface StorageBundleList
 */
export interface StorageBundleList {
    /**
     *
     * @type {Array<StorageBundle>}
     * @memberof StorageBundleList
     */
    'items': Array<StorageBundle>;
}
/**
 *
 * @export
 * @interface StorageConfiguration
 */
export interface StorageConfiguration {
    /**
     *
     * @type {string}
     * @memberof StorageConfiguration
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof StorageConfiguration
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof StorageConfiguration
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof StorageConfiguration
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof StorageConfiguration
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof StorageConfiguration
     */
    'tenantName'?: string | null;
    /**
     * The name of the storage configuration
     * @type {string}
     * @memberof StorageConfiguration
     */
    'name': string;
    /**
     * An optional description
     * @type {string}
     * @memberof StorageConfiguration
     */
    'description'?: string | null;
    /**
     *
     * @type {string}
     * @memberof StorageConfiguration
     */
    'type': StorageConfigurationTypeEnum;
    /**
     *
     * @type {string}
     * @memberof StorageConfiguration
     */
    'status': StorageConfigurationStatusEnum;
    /**
     * An optional error message when something went wrong with the configuration
     * @type {string}
     * @memberof StorageConfiguration
     */
    'errorMessage'?: string | null;
    /**
     *
     * @type {Region}
     * @memberof StorageConfiguration
     */
    'region': Region;
    /**
     * An indication if this is the default in region for new projects
     * @type {boolean}
     * @memberof StorageConfiguration
     */
    'isDefault': boolean;
}
export declare const StorageConfigurationTypeEnum: {
    readonly AwsS3: "AWS_S3";
};
export declare type StorageConfigurationTypeEnum = typeof StorageConfigurationTypeEnum[keyof typeof StorageConfigurationTypeEnum];
export declare const StorageConfigurationStatusEnum: {
    readonly Initializing: "INITIALIZING";
    readonly Ok: "OK";
    readonly Error: "ERROR";
};
export declare type StorageConfigurationStatusEnum = typeof StorageConfigurationStatusEnum[keyof typeof StorageConfigurationStatusEnum];
/**
 * Contains the specific provider details
 * @export
 * @interface StorageConfigurationDetails
 */
export interface StorageConfigurationDetails {
    /**
     *
     * @type {AWSDetails}
     * @memberof StorageConfigurationDetails
     */
    'awsS3'?: AWSDetails | null;
}
/**
 *
 * @export
 * @interface StorageConfigurationWithDetails
 */
export interface StorageConfigurationWithDetails {
    /**
     *
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'tenantName'?: string | null;
    /**
     * The name of the storage configuration
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'name': string;
    /**
     * An optional description
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'description'?: string | null;
    /**
     *
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'type': StorageConfigurationWithDetailsTypeEnum;
    /**
     *
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'status': StorageConfigurationWithDetailsStatusEnum;
    /**
     * An optional error message when something went wrong with the configuration
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'errorMessage'?: string | null;
    /**
     *
     * @type {Region}
     * @memberof StorageConfigurationWithDetails
     */
    'region': Region;
    /**
     * An indication if this is the default in region for new projects
     * @type {boolean}
     * @memberof StorageConfigurationWithDetails
     */
    'isDefault': boolean;
    /**
     *
     * @type {StorageConfigurationDetails}
     * @memberof StorageConfigurationWithDetails
     */
    'storageConfigurationDetails': StorageConfigurationDetails;
}
export declare const StorageConfigurationWithDetailsTypeEnum: {
    readonly AwsS3: "AWS_S3";
};
export declare type StorageConfigurationWithDetailsTypeEnum = typeof StorageConfigurationWithDetailsTypeEnum[keyof typeof StorageConfigurationWithDetailsTypeEnum];
export declare const StorageConfigurationWithDetailsStatusEnum: {
    readonly Initializing: "INITIALIZING";
    readonly Ok: "OK";
    readonly Error: "ERROR";
};
export declare type StorageConfigurationWithDetailsStatusEnum = typeof StorageConfigurationWithDetailsStatusEnum[keyof typeof StorageConfigurationWithDetailsStatusEnum];
/**
 *
 * @export
 * @interface StorageConfigurationWithDetailsList
 */
export interface StorageConfigurationWithDetailsList {
    /**
     *
     * @type {Array<StorageConfigurationWithDetails>}
     * @memberof StorageConfigurationWithDetailsList
     */
    'items': Array<StorageConfigurationWithDetails>;
}
/**
 *
 * @export
 * @interface StorageCredential
 */
export interface StorageCredential {
    /**
     *
     * @type {string}
     * @memberof StorageCredential
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof StorageCredential
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof StorageCredential
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof StorageCredential
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof StorageCredential
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof StorageCredential
     */
    'tenantName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof StorageCredential
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof StorageCredential
     */
    'type': StorageCredentialTypeEnum;
}
export declare const StorageCredentialTypeEnum: {
    readonly AwsUser: "AWS_USER";
};
export declare type StorageCredentialTypeEnum = typeof StorageCredentialTypeEnum[keyof typeof StorageCredentialTypeEnum];
/**
 *
 * @export
 * @interface StorageCredentialList
 */
export interface StorageCredentialList {
    /**
     *
     * @type {Array<StorageCredential>}
     * @memberof StorageCredentialList
     */
    'items': Array<StorageCredential>;
}
/**
 *
 * @export
 * @interface TempCredentials
 */
export interface TempCredentials {
    /**
     *
     * @type {AwsTempCredentials}
     * @memberof TempCredentials
     */
    'awsTempCredentials'?: AwsTempCredentials | null;
    /**
     *
     * @type {RcloneTempCredentials}
     * @memberof TempCredentials
     */
    'rcloneTempCredentials'?: RcloneTempCredentials | null;
}
/**
 *
 * @export
 * @interface Token
 */
export interface Token {
    /**
     *
     * @type {string}
     * @memberof Token
     */
    'token'?: string;
}
/**
 *
 * @export
 * @interface Type
 */
export interface Type {
    /**
     *
     * @type {string}
     * @memberof Type
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Type
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof Type
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof Type
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof Type
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof Type
     */
    'tenantName'?: string | null;
    /**
     * The name of the reference data type
     * @type {string}
     * @memberof Type
     */
    'name': string;
}
/**
 *
 * @export
 * @interface TypeList
 */
export interface TypeList {
    /**
     *
     * @type {Array<Type>}
     * @memberof TypeList
     */
    'items': Array<Type>;
}
/**
 *
 * @export
 * @interface UpdateMetadata
 */
export interface UpdateMetadata {
    /**
     * List of metadata fields to be updated
     * @type {Array<UpdateSingleMetadataField>}
     * @memberof UpdateMetadata
     */
    'updateSingleMetadataFields'?: Array<UpdateSingleMetadataField> | null;
    /**
     * List of metadata field groups to be updated
     * @type {Array<UpdateMetadataFieldGroup>}
     * @memberof UpdateMetadata
     */
    'updateMetadataFieldGroups'?: Array<UpdateMetadataFieldGroup> | null;
}
/**
 * List of metadata field groups to be updated
 * @export
 * @interface UpdateMetadataFieldGroup
 */
export interface UpdateMetadataFieldGroup {
    /**
     *
     * @type {FieldId}
     * @memberof UpdateMetadataFieldGroup
     */
    'fieldId'?: FieldId | null;
    /**
     * The field name to be updated. Either the field ID or field name is required.
     * @type {string}
     * @memberof UpdateMetadataFieldGroup
     */
    'fieldName'?: string | null;
    /**
     * Which metadata row index to update
     * @type {number}
     * @memberof UpdateMetadataFieldGroup
     */
    'index': number;
    /**
     * List of metadata fields to be updated
     * @type {Array<UpdateSingleMetadataField>}
     * @memberof UpdateMetadataFieldGroup
     */
    'updateSingleMetadataFields': Array<UpdateSingleMetadataField>;
}
/**
 * List of metadata fields to be updated
 * @export
 * @interface UpdateSingleMetadataField
 */
export interface UpdateSingleMetadataField {
    /**
     *
     * @type {FieldId}
     * @memberof UpdateSingleMetadataField
     */
    'fieldId'?: FieldId | null;
    /**
     * The field name to be updated. Either the field ID or field name is required.
     * @type {string}
     * @memberof UpdateSingleMetadataField
     */
    'fieldName'?: string | null;
    /**
     * The updated value(s)
     * @type {Array<string>}
     * @memberof UpdateSingleMetadataField
     */
    'values'?: Array<string>;
}
/**
 *
 * @export
 * @interface UpdateStorageCredentialSecrets
 */
export interface UpdateStorageCredentialSecrets {
    /**
     *
     * @type {AwsCredentials}
     * @memberof UpdateStorageCredentialSecrets
     */
    'awsCredentials'?: AwsCredentials | null;
}
/**
 *
 * @export
 * @interface Upload
 */
export interface Upload {
    /**
     * A pre-signed url which is temporarily available for uploading the data.
     * @type {string}
     * @memberof Upload
     */
    'url': string;
}
/**
 *
 * @export
 * @interface UploadRule
 */
export interface UploadRule {
    /**
     *
     * @type {string}
     * @memberof UploadRule
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof UploadRule
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof UploadRule
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof UploadRule
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof UploadRule
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof UploadRule
     */
    'tenantName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UploadRule
     */
    'code': string;
    /**
     *
     * @type {boolean}
     * @memberof UploadRule
     */
    'active'?: boolean | null;
    /**
     *
     * @type {string}
     * @memberof UploadRule
     */
    'description'?: string | null;
    /**
     * The local folder to monitor. Files in this folder on your local environment will be uploaded to the specified project. Only files matching the filePattern will be uploaded.
     * @type {string}
     * @memberof UploadRule
     */
    'localFolder': string;
    /**
     * The regular expression to match a file name. eg: to match all files use \'.*\'
     * @type {string}
     * @memberof UploadRule
     */
    'filePattern': string;
    /**
     *
     * @type {DataFormat}
     * @memberof UploadRule
     */
    'dataFormat'?: DataFormat | null;
    /**
     *
     * @type {Project}
     * @memberof UploadRule
     */
    'project': Project;
}
/**
 *
 * @export
 * @interface UploadRuleList
 */
export interface UploadRuleList {
    /**
     *
     * @type {Array<UploadRule>}
     * @memberof UploadRuleList
     */
    'items': Array<UploadRule>;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     *
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'timeModified': string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'tenantId': string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'tenantName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'firstname'?: string | null;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'lastname'?: string | null;
    /**
     *
     * @type {boolean}
     * @memberof User
     */
    'active': boolean;
    /**
     *
     * @type {boolean}
     * @memberof User
     */
    'tenantAdministrator': boolean;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'jobTitle'?: string | null;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'greeting'?: UserGreetingEnum;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'mobilePhoneNumber'?: string | null;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'phoneNumber'?: string | null;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'faxNumber'?: string | null;
    /**
     *
     * @type {boolean}
     * @memberof User
     */
    'emailVerified': boolean;
    /**
     *
     * @type {boolean}
     * @memberof User
     */
    'twoFactorAuthentication': boolean;
    /**
     *
     * @type {Country}
     * @memberof User
     */
    'country'?: Country | null;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'addressLine1'?: string | null;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'addressLine2'?: string | null;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'addressLine3'?: string | null;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'postalCode'?: string | null;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'city'?: string | null;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'state'?: string | null;
}
export declare const UserGreetingEnum: {
    readonly Mr: "MR";
    readonly Mrs: "MRS";
    readonly Ms: "MS";
    readonly Miss: "MISS";
    readonly Dr: "DR";
    readonly Hr: "HR";
    readonly Sr: "SR";
};
export declare type UserGreetingEnum = typeof UserGreetingEnum[keyof typeof UserGreetingEnum];
/**
 *
 * @export
 * @interface UserList
 */
export interface UserList {
    /**
     *
     * @type {Array<User>}
     * @memberof UserList
     */
    'items': Array<User>;
}
/**
 *
 * @export
 * @interface Workgroup
 */
export interface Workgroup {
    /**
     *
     * @type {string}
     * @memberof Workgroup
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Workgroup
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof Workgroup
     */
    'description': string;
}
/**
 *
 * @export
 * @interface WorkgroupList
 */
export interface WorkgroupList {
    /**
     *
     * @type {Array<Workgroup>}
     * @memberof WorkgroupList
     */
    'items': Array<Workgroup>;
}
/**
 * AnalysisStorageApi - axios parameter creator
 * @export
 */
export declare const AnalysisStorageApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve the list of analysis storage options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysisStorageOptions: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AnalysisStorageApi - functional programming interface
 * @export
 */
export declare const AnalysisStorageApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve the list of analysis storage options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysisStorageOptions(options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<AnalysisStorageList>>;
};
/**
 * AnalysisStorageApi - factory interface
 * @export
 */
export declare const AnalysisStorageApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Retrieve the list of analysis storage options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysisStorageOptions(options?: any): AxiosPromise<AnalysisStorageList>;
};
/**
 * AnalysisStorageApi - object-oriented interface
 * @export
 * @class AnalysisStorageApi
 * @extends {BaseAPI}
 */
export declare class AnalysisStorageApi extends BaseAPI {
    /**
     *
     * @summary Retrieve the list of analysis storage options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysisStorageApi
     */
    getAnalysisStorageOptions(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AnalysisStorageList, any>>;
}
/**
 * BundleApi - axios parameter creator
 * @export
 */
export declare const BundleApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a new bundle
     * @param {CreateBundle} [createBundle]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBundle: (createBundle?: CreateBundle | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a bundle.
     * @param {string} bundleId The ID of the bundle to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundle: (bundleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of bundles.
     * @param {string} [search] Search
     * @param {string} [userTags] User tags to filter on
     * @param {string} [technicalTags] Technical tags to filter on
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundles: (search?: string | undefined, userTags?: string | undefined, technicalTags?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary release a bundle
     * @param {string} bundleId The ID of the bundle to release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    releaseBundle: (bundleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * BundleApi - functional programming interface
 * @export
 */
export declare const BundleApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a new bundle
     * @param {CreateBundle} [createBundle]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBundle(createBundle?: CreateBundle | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Bundle>>;
    /**
     *
     * @summary Retrieve a bundle.
     * @param {string} bundleId The ID of the bundle to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundle(bundleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Bundle>>;
    /**
     *
     * @summary Retrieve a list of bundles.
     * @param {string} [search] Search
     * @param {string} [userTags] User tags to filter on
     * @param {string} [technicalTags] Technical tags to filter on
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundles(search?: string | undefined, userTags?: string | undefined, technicalTags?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<BundlePagedList>>;
    /**
     *
     * @summary release a bundle
     * @param {string} bundleId The ID of the bundle to release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    releaseBundle(bundleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
};
/**
 * BundleApi - factory interface
 * @export
 */
export declare const BundleApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Create a new bundle
     * @param {CreateBundle} [createBundle]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBundle(createBundle?: CreateBundle | undefined, options?: any): AxiosPromise<Bundle>;
    /**
     *
     * @summary Retrieve a bundle.
     * @param {string} bundleId The ID of the bundle to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundle(bundleId: string, options?: any): AxiosPromise<Bundle>;
    /**
     *
     * @summary Retrieve a list of bundles.
     * @param {string} [search] Search
     * @param {string} [userTags] User tags to filter on
     * @param {string} [technicalTags] Technical tags to filter on
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundles(search?: string | undefined, userTags?: string | undefined, technicalTags?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: any): AxiosPromise<BundlePagedList>;
    /**
     *
     * @summary release a bundle
     * @param {string} bundleId The ID of the bundle to release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    releaseBundle(bundleId: string, options?: any): AxiosPromise<void>;
};
/**
 * BundleApi - object-oriented interface
 * @export
 * @class BundleApi
 * @extends {BaseAPI}
 */
export declare class BundleApi extends BaseAPI {
    /**
     *
     * @summary Create a new bundle
     * @param {CreateBundle} [createBundle]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    createBundle(createBundle?: CreateBundle, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Bundle, any>>;
    /**
     *
     * @summary Retrieve a bundle.
     * @param {string} bundleId The ID of the bundle to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    getBundle(bundleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Bundle, any>>;
    /**
     *
     * @summary Retrieve a list of bundles.
     * @param {string} [search] Search
     * @param {string} [userTags] User tags to filter on
     * @param {string} [technicalTags] Technical tags to filter on
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    getBundles(search?: string, userTags?: string, technicalTags?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BundlePagedList, any>>;
    /**
     *
     * @summary release a bundle
     * @param {string} bundleId The ID of the bundle to release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    releaseBundle(bundleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * BundleDataApi - axios parameter creator
 * @export
 */
export declare const BundleDataApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve the list of bundle data.
     * @param {string} bundleId
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {string} [id] The ids to filter on. This will always match exact.
     * @param {string} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {string} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'} [status] The statuses to filter on.
     * @param {string} [formatId] The IDs of the formats to filter on.
     * @param {string} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {string} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {string} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {string} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {string} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {string} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {string} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {string} [notLinkedToSample] When set to true only date that is unlinked to a sample will be returned.  This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundleData: (bundleId: string, fullText?: string | undefined, id?: string | undefined, filename?: string | undefined, filenameMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, filePath?: string | undefined, filePathMatchMode?: "STARTS_WITH_CASE_INSENSITIVE" | "FULL_CASE_INSENSITIVE" | undefined, status?: "PARTIAL" | "AVAILABLE" | "ARCHIVING" | "ARCHIVED" | "UNARCHIVING" | "DELETING" | undefined, formatId?: string | undefined, formatCode?: string | undefined, type?: "FILE" | "FOLDER" | undefined, parentFolderId?: string | undefined, parentFolderPath?: string | undefined, creationDateAfter?: string | undefined, creationDateBefore?: string | undefined, statusDateAfter?: string | undefined, statusDateBefore?: string | undefined, userTag?: string | undefined, userTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runInputTag?: string | undefined, runInputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runOutputTag?: string | undefined, runOutputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, connectorTag?: string | undefined, connectorTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, technicalTag?: string | undefined, technicalTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, notInRun?: string | undefined, notLinkedToSample?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Link data to this bundle.
     * @param {string} bundleId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkDataToBundle: (bundleId: string, dataId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Unlink data from this bundle.
     * @param {string} bundleId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkDataFromBundle: (bundleId: string, dataId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * BundleDataApi - functional programming interface
 * @export
 */
export declare const BundleDataApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve the list of bundle data.
     * @param {string} bundleId
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {string} [id] The ids to filter on. This will always match exact.
     * @param {string} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {string} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'} [status] The statuses to filter on.
     * @param {string} [formatId] The IDs of the formats to filter on.
     * @param {string} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {string} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {string} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {string} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {string} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {string} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {string} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {string} [notLinkedToSample] When set to true only date that is unlinked to a sample will be returned.  This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundleData(bundleId: string, fullText?: string | undefined, id?: string | undefined, filename?: string | undefined, filenameMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, filePath?: string | undefined, filePathMatchMode?: "STARTS_WITH_CASE_INSENSITIVE" | "FULL_CASE_INSENSITIVE" | undefined, status?: "PARTIAL" | "AVAILABLE" | "ARCHIVING" | "ARCHIVED" | "UNARCHIVING" | "DELETING" | undefined, formatId?: string | undefined, formatCode?: string | undefined, type?: "FILE" | "FOLDER" | undefined, parentFolderId?: string | undefined, parentFolderPath?: string | undefined, creationDateAfter?: string | undefined, creationDateBefore?: string | undefined, statusDateAfter?: string | undefined, statusDateBefore?: string | undefined, userTag?: string | undefined, userTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runInputTag?: string | undefined, runInputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runOutputTag?: string | undefined, runOutputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, connectorTag?: string | undefined, connectorTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, technicalTag?: string | undefined, technicalTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, notInRun?: string | undefined, notLinkedToSample?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<BundleDataPagedList>>;
    /**
     *
     * @summary Link data to this bundle.
     * @param {string} bundleId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkDataToBundle(bundleId: string, dataId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Unlink data from this bundle.
     * @param {string} bundleId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkDataFromBundle(bundleId: string, dataId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
};
/**
 * BundleDataApi - factory interface
 * @export
 */
export declare const BundleDataApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Retrieve the list of bundle data.
     * @param {string} bundleId
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {string} [id] The ids to filter on. This will always match exact.
     * @param {string} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {string} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'} [status] The statuses to filter on.
     * @param {string} [formatId] The IDs of the formats to filter on.
     * @param {string} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {string} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {string} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {string} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {string} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {string} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {string} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {string} [notLinkedToSample] When set to true only date that is unlinked to a sample will be returned.  This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundleData(bundleId: string, fullText?: string | undefined, id?: string | undefined, filename?: string | undefined, filenameMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, filePath?: string | undefined, filePathMatchMode?: "STARTS_WITH_CASE_INSENSITIVE" | "FULL_CASE_INSENSITIVE" | undefined, status?: "PARTIAL" | "AVAILABLE" | "ARCHIVING" | "ARCHIVED" | "UNARCHIVING" | "DELETING" | undefined, formatId?: string | undefined, formatCode?: string | undefined, type?: "FILE" | "FOLDER" | undefined, parentFolderId?: string | undefined, parentFolderPath?: string | undefined, creationDateAfter?: string | undefined, creationDateBefore?: string | undefined, statusDateAfter?: string | undefined, statusDateBefore?: string | undefined, userTag?: string | undefined, userTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runInputTag?: string | undefined, runInputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runOutputTag?: string | undefined, runOutputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, connectorTag?: string | undefined, connectorTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, technicalTag?: string | undefined, technicalTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, notInRun?: string | undefined, notLinkedToSample?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: any): AxiosPromise<BundleDataPagedList>;
    /**
     *
     * @summary Link data to this bundle.
     * @param {string} bundleId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkDataToBundle(bundleId: string, dataId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Unlink data from this bundle.
     * @param {string} bundleId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkDataFromBundle(bundleId: string, dataId: string, options?: any): AxiosPromise<void>;
};
/**
 * BundleDataApi - object-oriented interface
 * @export
 * @class BundleDataApi
 * @extends {BaseAPI}
 */
export declare class BundleDataApi extends BaseAPI {
    /**
     *
     * @summary Retrieve the list of bundle data.
     * @param {string} bundleId
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {string} [id] The ids to filter on. This will always match exact.
     * @param {string} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {string} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'} [status] The statuses to filter on.
     * @param {string} [formatId] The IDs of the formats to filter on.
     * @param {string} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {string} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {string} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {string} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {string} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {string} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {string} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {string} [notLinkedToSample] When set to true only date that is unlinked to a sample will be returned.  This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleDataApi
     */
    getBundleData(bundleId: string, fullText?: string, id?: string, filename?: string, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: string, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: 'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING', formatId?: string, formatCode?: string, type?: 'FILE' | 'FOLDER', parentFolderId?: string, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: string, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: string, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: string, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: string, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: string, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: string, notLinkedToSample?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BundleDataPagedList, any>>;
    /**
     *
     * @summary Link data to this bundle.
     * @param {string} bundleId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleDataApi
     */
    linkDataToBundle(bundleId: string, dataId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Unlink data from this bundle.
     * @param {string} bundleId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleDataApi
     */
    unlinkDataFromBundle(bundleId: string, dataId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * BundlePipelineApi - axios parameter creator
 * @export
 */
export declare const BundlePipelineApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a list of bundle pipelines.
     * @param {string} bundleId The ID of the bundle to retrieve pipelines for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundlePipelines: (bundleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Link a pipeline to a bundle.
     * @param {string} bundleId The ID of the bundle
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkPipelineToBundle: (bundleId: string, pipelineId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Unlink a pipeline from a bundle.
     * @param {string} bundleId The ID of the bundle
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkPipelineFromBundle: (bundleId: string, pipelineId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * BundlePipelineApi - functional programming interface
 * @export
 */
export declare const BundlePipelineApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a list of bundle pipelines.
     * @param {string} bundleId The ID of the bundle to retrieve pipelines for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundlePipelines(bundleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<BundlePipelineList>>;
    /**
     *
     * @summary Link a pipeline to a bundle.
     * @param {string} bundleId The ID of the bundle
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkPipelineToBundle(bundleId: string, pipelineId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Unlink a pipeline from a bundle.
     * @param {string} bundleId The ID of the bundle
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkPipelineFromBundle(bundleId: string, pipelineId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
};
/**
 * BundlePipelineApi - factory interface
 * @export
 */
export declare const BundlePipelineApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Retrieve a list of bundle pipelines.
     * @param {string} bundleId The ID of the bundle to retrieve pipelines for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundlePipelines(bundleId: string, options?: any): AxiosPromise<BundlePipelineList>;
    /**
     *
     * @summary Link a pipeline to a bundle.
     * @param {string} bundleId The ID of the bundle
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkPipelineToBundle(bundleId: string, pipelineId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Unlink a pipeline from a bundle.
     * @param {string} bundleId The ID of the bundle
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkPipelineFromBundle(bundleId: string, pipelineId: string, options?: any): AxiosPromise<void>;
};
/**
 * BundlePipelineApi - object-oriented interface
 * @export
 * @class BundlePipelineApi
 * @extends {BaseAPI}
 */
export declare class BundlePipelineApi extends BaseAPI {
    /**
     *
     * @summary Retrieve a list of bundle pipelines.
     * @param {string} bundleId The ID of the bundle to retrieve pipelines for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundlePipelineApi
     */
    getBundlePipelines(bundleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BundlePipelineList, any>>;
    /**
     *
     * @summary Link a pipeline to a bundle.
     * @param {string} bundleId The ID of the bundle
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundlePipelineApi
     */
    linkPipelineToBundle(bundleId: string, pipelineId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Unlink a pipeline from a bundle.
     * @param {string} bundleId The ID of the bundle
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundlePipelineApi
     */
    unlinkPipelineFromBundle(bundleId: string, pipelineId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * BundleSampleApi - axios parameter creator
 * @export
 */
export declare const BundleSampleApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a list of bundle samples.
     * @param {string} bundleId The ID of the bundle to get bundle samples from
     * @param {string} [search] To search through multiple fields of data.
     * @param {string} [userTags] The user tags to filter on.
     * @param {string} [technicalTags] The technical tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundleSamples: (bundleId: string, search?: string | undefined, userTags?: string | undefined, technicalTags?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Link a sample to a bundle.
     * @param {string} bundleId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkSampleToBundle: (bundleId: string, sampleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Unlink a sample from a bundle.
     * @param {string} bundleId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkSampleFromBundle: (bundleId: string, sampleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * BundleSampleApi - functional programming interface
 * @export
 */
export declare const BundleSampleApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a list of bundle samples.
     * @param {string} bundleId The ID of the bundle to get bundle samples from
     * @param {string} [search] To search through multiple fields of data.
     * @param {string} [userTags] The user tags to filter on.
     * @param {string} [technicalTags] The technical tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundleSamples(bundleId: string, search?: string | undefined, userTags?: string | undefined, technicalTags?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<BundleSamplePagedList>>;
    /**
     *
     * @summary Link a sample to a bundle.
     * @param {string} bundleId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkSampleToBundle(bundleId: string, sampleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Unlink a sample from a bundle.
     * @param {string} bundleId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkSampleFromBundle(bundleId: string, sampleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
};
/**
 * BundleSampleApi - factory interface
 * @export
 */
export declare const BundleSampleApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Retrieve a list of bundle samples.
     * @param {string} bundleId The ID of the bundle to get bundle samples from
     * @param {string} [search] To search through multiple fields of data.
     * @param {string} [userTags] The user tags to filter on.
     * @param {string} [technicalTags] The technical tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundleSamples(bundleId: string, search?: string | undefined, userTags?: string | undefined, technicalTags?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: any): AxiosPromise<BundleSamplePagedList>;
    /**
     *
     * @summary Link a sample to a bundle.
     * @param {string} bundleId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkSampleToBundle(bundleId: string, sampleId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Unlink a sample from a bundle.
     * @param {string} bundleId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkSampleFromBundle(bundleId: string, sampleId: string, options?: any): AxiosPromise<void>;
};
/**
 * BundleSampleApi - object-oriented interface
 * @export
 * @class BundleSampleApi
 * @extends {BaseAPI}
 */
export declare class BundleSampleApi extends BaseAPI {
    /**
     *
     * @summary Retrieve a list of bundle samples.
     * @param {string} bundleId The ID of the bundle to get bundle samples from
     * @param {string} [search] To search through multiple fields of data.
     * @param {string} [userTags] The user tags to filter on.
     * @param {string} [technicalTags] The technical tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleSampleApi
     */
    getBundleSamples(bundleId: string, search?: string, userTags?: string, technicalTags?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BundleSamplePagedList, any>>;
    /**
     *
     * @summary Link a sample to a bundle.
     * @param {string} bundleId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleSampleApi
     */
    linkSampleToBundle(bundleId: string, sampleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Unlink a sample from a bundle.
     * @param {string} bundleId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleSampleApi
     */
    unlinkSampleFromBundle(bundleId: string, sampleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * BundleToolApi - axios parameter creator
 * @export
 */
export declare const BundleToolApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a list of bundle tools.
     * @param {string} bundleId The ID of the bundle to get tools from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundleTools: (bundleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of tools eligible for linking to the bundle.
     * @param {string} bundleId The ID of the bundle to get the eligible tools for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getToolsEligibleForLinkingToBundle: (bundleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Link a tool to a bundle
     * @param {string} bundleId The ID of the bundle to link the tool to
     * @param {string} toolId The ID of the tool to link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkToolToBundle: (bundleId: string, toolId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Unlink a tool from this bundle.
     * @param {string} bundleId
     * @param {string} toolId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkToolFromBundle: (bundleId: string, toolId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * BundleToolApi - functional programming interface
 * @export
 */
export declare const BundleToolApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a list of bundle tools.
     * @param {string} bundleId The ID of the bundle to get tools from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundleTools(bundleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<BundleToolsList>>;
    /**
     *
     * @summary Retrieve a list of tools eligible for linking to the bundle.
     * @param {string} bundleId The ID of the bundle to get the eligible tools for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getToolsEligibleForLinkingToBundle(bundleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<CwlToolDefinitionList>>;
    /**
     *
     * @summary Link a tool to a bundle
     * @param {string} bundleId The ID of the bundle to link the tool to
     * @param {string} toolId The ID of the tool to link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkToolToBundle(bundleId: string, toolId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Unlink a tool from this bundle.
     * @param {string} bundleId
     * @param {string} toolId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkToolFromBundle(bundleId: string, toolId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
};
/**
 * BundleToolApi - factory interface
 * @export
 */
export declare const BundleToolApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Retrieve a list of bundle tools.
     * @param {string} bundleId The ID of the bundle to get tools from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundleTools(bundleId: string, options?: any): AxiosPromise<BundleToolsList>;
    /**
     *
     * @summary Retrieve a list of tools eligible for linking to the bundle.
     * @param {string} bundleId The ID of the bundle to get the eligible tools for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getToolsEligibleForLinkingToBundle(bundleId: string, options?: any): AxiosPromise<CwlToolDefinitionList>;
    /**
     *
     * @summary Link a tool to a bundle
     * @param {string} bundleId The ID of the bundle to link the tool to
     * @param {string} toolId The ID of the tool to link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkToolToBundle(bundleId: string, toolId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Unlink a tool from this bundle.
     * @param {string} bundleId
     * @param {string} toolId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkToolFromBundle(bundleId: string, toolId: string, options?: any): AxiosPromise<void>;
};
/**
 * BundleToolApi - object-oriented interface
 * @export
 * @class BundleToolApi
 * @extends {BaseAPI}
 */
export declare class BundleToolApi extends BaseAPI {
    /**
     *
     * @summary Retrieve a list of bundle tools.
     * @param {string} bundleId The ID of the bundle to get tools from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleToolApi
     */
    getBundleTools(bundleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BundleToolsList, any>>;
    /**
     *
     * @summary Retrieve a list of tools eligible for linking to the bundle.
     * @param {string} bundleId The ID of the bundle to get the eligible tools for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleToolApi
     */
    getToolsEligibleForLinkingToBundle(bundleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<CwlToolDefinitionList, any>>;
    /**
     *
     * @summary Link a tool to a bundle
     * @param {string} bundleId The ID of the bundle to link the tool to
     * @param {string} toolId The ID of the tool to link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleToolApi
     */
    linkToolToBundle(bundleId: string, toolId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Unlink a tool from this bundle.
     * @param {string} bundleId
     * @param {string} toolId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleToolApi
     */
    unlinkToolFromBundle(bundleId: string, toolId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * ConnectorApi - axios parameter creator
 * @export
 */
export declare const ConnectorApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Endpoint for cancelling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Cancel a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelConnector: (connectorId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Create a connector.
     * @param {CreateConnector} [createConnector] The connector to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConnector: (createConnector?: CreateConnector | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Create a download rule.
     * @param {string} connectorId
     * @param {CreateDownloadRule} [createDownloadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDownloadRule: (connectorId: string, createDownloadRule?: CreateDownloadRule | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Create an upload rule.
     * @param {string} connectorId
     * @param {CreateUploadRule} [createUploadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUploadRule: (connectorId: string, createUploadRule?: CreateUploadRule | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete a download rule.
     * @param {string} connectorId
     * @param {string} downloadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDownloadRule: (connectorId: string, downloadRuleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete an upload rule.
     * @param {string} connectorId
     * @param {string} uploadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUploadRule: (connectorId: string, uploadRuleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint for disabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Disable a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableConnector: (connectorId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint for enabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Enable a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableConnector: (connectorId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnector: (connectorId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of connectors.
     * @param {boolean} [activeOnly] When true only the active connectors will be returned. When false (default value) all connectors wil be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectors: (activeOnly?: boolean | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a download rule.
     * @param {string} connectorId
     * @param {string} downloadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDownloadRule: (connectorId: string, downloadRuleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of download rules.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDownloadRules: (connectorId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve an upload rule.
     * @param {string} connectorId
     * @param {string} uploadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadRule: (connectorId: string, uploadRuleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of upload rules.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadRules: (connectorId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fields which can be updated:  - code  - active  - description  - sequence  - formatCode  - projectName  - targetLocalFolder  - protocol  - fileNameExpression  - disableHashing
     * @summary Update a download rule.
     * @param {string} connectorId
     * @param {string} downloadRuleId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {DownloadRule} [downloadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDownloadRule: (connectorId: string, downloadRuleId: string, ifMatch?: string | undefined, downloadRule?: DownloadRule | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fields which can be updated:  - code  - active  - description  - localFolder  - filePattern  - dataFormat
     * @summary Update an upload rule.
     * @param {string} connectorId
     * @param {string} uploadRuleId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {UploadRule} [uploadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUploadRule: (connectorId: string, uploadRuleId: string, ifMatch?: string | undefined, uploadRule?: UploadRule | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ConnectorApi - functional programming interface
 * @export
 */
export declare const ConnectorApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Endpoint for cancelling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Cancel a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelConnector(connectorId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Create a connector.
     * @param {CreateConnector} [createConnector] The connector to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConnector(createConnector?: CreateConnector | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Connector>>;
    /**
     *
     * @summary Create a download rule.
     * @param {string} connectorId
     * @param {CreateDownloadRule} [createDownloadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDownloadRule(connectorId: string, createDownloadRule?: CreateDownloadRule | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<DownloadRule>>;
    /**
     *
     * @summary Create an upload rule.
     * @param {string} connectorId
     * @param {CreateUploadRule} [createUploadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUploadRule(connectorId: string, createUploadRule?: CreateUploadRule | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<UploadRule>>;
    /**
     *
     * @summary Delete a download rule.
     * @param {string} connectorId
     * @param {string} downloadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDownloadRule(connectorId: string, downloadRuleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Delete an upload rule.
     * @param {string} connectorId
     * @param {string} uploadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUploadRule(connectorId: string, uploadRuleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     * Endpoint for disabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Disable a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableConnector(connectorId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     * Endpoint for enabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Enable a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableConnector(connectorId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Retrieve a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnector(connectorId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Connector>>;
    /**
     *
     * @summary Retrieve a list of connectors.
     * @param {boolean} [activeOnly] When true only the active connectors will be returned. When false (default value) all connectors wil be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectors(activeOnly?: boolean | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ConnectorList>>;
    /**
     *
     * @summary Retrieve a download rule.
     * @param {string} connectorId
     * @param {string} downloadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDownloadRule(connectorId: string, downloadRuleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<DownloadRule>>;
    /**
     *
     * @summary Retrieve a list of download rules.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDownloadRules(connectorId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<DownloadRuleList>>;
    /**
     *
     * @summary Retrieve an upload rule.
     * @param {string} connectorId
     * @param {string} uploadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadRule(connectorId: string, uploadRuleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<UploadRule>>;
    /**
     *
     * @summary Retrieve a list of upload rules.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadRules(connectorId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<UploadRuleList>>;
    /**
     * Fields which can be updated:  - code  - active  - description  - sequence  - formatCode  - projectName  - targetLocalFolder  - protocol  - fileNameExpression  - disableHashing
     * @summary Update a download rule.
     * @param {string} connectorId
     * @param {string} downloadRuleId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {DownloadRule} [downloadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDownloadRule(connectorId: string, downloadRuleId: string, ifMatch?: string | undefined, downloadRule?: DownloadRule | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<DownloadRule>>;
    /**
     * Fields which can be updated:  - code  - active  - description  - localFolder  - filePattern  - dataFormat
     * @summary Update an upload rule.
     * @param {string} connectorId
     * @param {string} uploadRuleId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {UploadRule} [uploadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUploadRule(connectorId: string, uploadRuleId: string, ifMatch?: string | undefined, uploadRule?: UploadRule | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<UploadRule>>;
};
/**
 * ConnectorApi - factory interface
 * @export
 */
export declare const ConnectorApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     * Endpoint for cancelling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Cancel a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelConnector(connectorId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Create a connector.
     * @param {CreateConnector} [createConnector] The connector to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConnector(createConnector?: CreateConnector | undefined, options?: any): AxiosPromise<Connector>;
    /**
     *
     * @summary Create a download rule.
     * @param {string} connectorId
     * @param {CreateDownloadRule} [createDownloadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDownloadRule(connectorId: string, createDownloadRule?: CreateDownloadRule | undefined, options?: any): AxiosPromise<DownloadRule>;
    /**
     *
     * @summary Create an upload rule.
     * @param {string} connectorId
     * @param {CreateUploadRule} [createUploadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUploadRule(connectorId: string, createUploadRule?: CreateUploadRule | undefined, options?: any): AxiosPromise<UploadRule>;
    /**
     *
     * @summary Delete a download rule.
     * @param {string} connectorId
     * @param {string} downloadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDownloadRule(connectorId: string, downloadRuleId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Delete an upload rule.
     * @param {string} connectorId
     * @param {string} uploadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUploadRule(connectorId: string, uploadRuleId: string, options?: any): AxiosPromise<void>;
    /**
     * Endpoint for disabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Disable a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableConnector(connectorId: string, options?: any): AxiosPromise<void>;
    /**
     * Endpoint for enabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Enable a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableConnector(connectorId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Retrieve a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnector(connectorId: string, options?: any): AxiosPromise<Connector>;
    /**
     *
     * @summary Retrieve a list of connectors.
     * @param {boolean} [activeOnly] When true only the active connectors will be returned. When false (default value) all connectors wil be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectors(activeOnly?: boolean | undefined, options?: any): AxiosPromise<ConnectorList>;
    /**
     *
     * @summary Retrieve a download rule.
     * @param {string} connectorId
     * @param {string} downloadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDownloadRule(connectorId: string, downloadRuleId: string, options?: any): AxiosPromise<DownloadRule>;
    /**
     *
     * @summary Retrieve a list of download rules.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDownloadRules(connectorId: string, options?: any): AxiosPromise<DownloadRuleList>;
    /**
     *
     * @summary Retrieve an upload rule.
     * @param {string} connectorId
     * @param {string} uploadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadRule(connectorId: string, uploadRuleId: string, options?: any): AxiosPromise<UploadRule>;
    /**
     *
     * @summary Retrieve a list of upload rules.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadRules(connectorId: string, options?: any): AxiosPromise<UploadRuleList>;
    /**
     * Fields which can be updated:  - code  - active  - description  - sequence  - formatCode  - projectName  - targetLocalFolder  - protocol  - fileNameExpression  - disableHashing
     * @summary Update a download rule.
     * @param {string} connectorId
     * @param {string} downloadRuleId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {DownloadRule} [downloadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDownloadRule(connectorId: string, downloadRuleId: string, ifMatch?: string | undefined, downloadRule?: DownloadRule | undefined, options?: any): AxiosPromise<DownloadRule>;
    /**
     * Fields which can be updated:  - code  - active  - description  - localFolder  - filePattern  - dataFormat
     * @summary Update an upload rule.
     * @param {string} connectorId
     * @param {string} uploadRuleId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {UploadRule} [uploadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUploadRule(connectorId: string, uploadRuleId: string, ifMatch?: string | undefined, uploadRule?: UploadRule | undefined, options?: any): AxiosPromise<UploadRule>;
};
/**
 * ConnectorApi - object-oriented interface
 * @export
 * @class ConnectorApi
 * @extends {BaseAPI}
 */
export declare class ConnectorApi extends BaseAPI {
    /**
     * Endpoint for cancelling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Cancel a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    cancelConnector(connectorId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Create a connector.
     * @param {CreateConnector} [createConnector] The connector to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    createConnector(createConnector?: CreateConnector, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Connector, any>>;
    /**
     *
     * @summary Create a download rule.
     * @param {string} connectorId
     * @param {CreateDownloadRule} [createDownloadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    createDownloadRule(connectorId: string, createDownloadRule?: CreateDownloadRule, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<DownloadRule, any>>;
    /**
     *
     * @summary Create an upload rule.
     * @param {string} connectorId
     * @param {CreateUploadRule} [createUploadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    createUploadRule(connectorId: string, createUploadRule?: CreateUploadRule, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UploadRule, any>>;
    /**
     *
     * @summary Delete a download rule.
     * @param {string} connectorId
     * @param {string} downloadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    deleteDownloadRule(connectorId: string, downloadRuleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Delete an upload rule.
     * @param {string} connectorId
     * @param {string} uploadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    deleteUploadRule(connectorId: string, uploadRuleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Endpoint for disabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Disable a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    disableConnector(connectorId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Endpoint for enabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Enable a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    enableConnector(connectorId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Retrieve a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    getConnector(connectorId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Connector, any>>;
    /**
     *
     * @summary Retrieve a list of connectors.
     * @param {boolean} [activeOnly] When true only the active connectors will be returned. When false (default value) all connectors wil be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    getConnectors(activeOnly?: boolean, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ConnectorList, any>>;
    /**
     *
     * @summary Retrieve a download rule.
     * @param {string} connectorId
     * @param {string} downloadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    getDownloadRule(connectorId: string, downloadRuleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<DownloadRule, any>>;
    /**
     *
     * @summary Retrieve a list of download rules.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    getDownloadRules(connectorId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<DownloadRuleList, any>>;
    /**
     *
     * @summary Retrieve an upload rule.
     * @param {string} connectorId
     * @param {string} uploadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    getUploadRule(connectorId: string, uploadRuleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UploadRule, any>>;
    /**
     *
     * @summary Retrieve a list of upload rules.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    getUploadRules(connectorId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UploadRuleList, any>>;
    /**
     * Fields which can be updated:  - code  - active  - description  - sequence  - formatCode  - projectName  - targetLocalFolder  - protocol  - fileNameExpression  - disableHashing
     * @summary Update a download rule.
     * @param {string} connectorId
     * @param {string} downloadRuleId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {DownloadRule} [downloadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    updateDownloadRule(connectorId: string, downloadRuleId: string, ifMatch?: string, downloadRule?: DownloadRule, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<DownloadRule, any>>;
    /**
     * Fields which can be updated:  - code  - active  - description  - localFolder  - filePattern  - dataFormat
     * @summary Update an upload rule.
     * @param {string} connectorId
     * @param {string} uploadRuleId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {UploadRule} [uploadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    updateUploadRule(connectorId: string, uploadRuleId: string, ifMatch?: string, uploadRule?: UploadRule, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UploadRule, any>>;
}
/**
 * DataFormatApi - axios parameter creator
 * @export
 */
export declare const DataFormatApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a list of data formats.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFormats: (pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * DataFormatApi - functional programming interface
 * @export
 */
export declare const DataFormatApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a list of data formats.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFormats(pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<DataFormatPagedList>>;
};
/**
 * DataFormatApi - factory interface
 * @export
 */
export declare const DataFormatApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Retrieve a list of data formats.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFormats(pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: any): AxiosPromise<DataFormatPagedList>;
};
/**
 * DataFormatApi - object-oriented interface
 * @export
 * @class DataFormatApi
 * @extends {BaseAPI}
 */
export declare class DataFormatApi extends BaseAPI {
    /**
     *
     * @summary Retrieve a list of data formats.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFormatApi
     */
    getDataFormats(pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<DataFormatPagedList, any>>;
}
/**
 * EntitlementDetailApi - axios parameter creator
 * @export
 */
export declare const EntitlementDetailApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Endpoint for searching all matching activation code details for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search all matching activation code details for a Cwl pipeline.
     * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllMatchingActivationCodesForCwl: (searchMatchingActivationCodesForCwlAnalysis?: SearchMatchingActivationCodesForCwlAnalysis | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint for searching all matching activation code details for a project and an analysis from a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search all matching activation code details for a Nextflow pipeline.
     * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllMatchingActivationCodesForNextflow: (searchMatchingActivationCodesForNextflowAnalysis?: SearchMatchingActivationCodesForNextflowAnalysis | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint for searching the best activation code detail for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search the best matching activation code detail for Cwl pipeline.
     * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findBestMatchingActivationCodeForCwl: (searchMatchingActivationCodesForCwlAnalysis?: SearchMatchingActivationCodesForCwlAnalysis | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint for searching the best activation code details for a project and an analysis for a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search the best matching activation code details for Nextflow pipeline.
     * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findBestMatchingActivationCodesForNextflow: (searchMatchingActivationCodesForNextflowAnalysis?: SearchMatchingActivationCodesForNextflowAnalysis | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * EntitlementDetailApi - functional programming interface
 * @export
 */
export declare const EntitlementDetailApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Endpoint for searching all matching activation code details for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search all matching activation code details for a Cwl pipeline.
     * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllMatchingActivationCodesForCwl(searchMatchingActivationCodesForCwlAnalysis?: SearchMatchingActivationCodesForCwlAnalysis | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ActivationCodeDetailList>>;
    /**
     * Endpoint for searching all matching activation code details for a project and an analysis from a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search all matching activation code details for a Nextflow pipeline.
     * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis?: SearchMatchingActivationCodesForNextflowAnalysis | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ActivationCodeDetailList>>;
    /**
     * Endpoint for searching the best activation code detail for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search the best matching activation code detail for Cwl pipeline.
     * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findBestMatchingActivationCodeForCwl(searchMatchingActivationCodesForCwlAnalysis?: SearchMatchingActivationCodesForCwlAnalysis | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ActivationCodeDetail>>;
    /**
     * Endpoint for searching the best activation code details for a project and an analysis for a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search the best matching activation code details for Nextflow pipeline.
     * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findBestMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis?: SearchMatchingActivationCodesForNextflowAnalysis | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ActivationCodeDetail>>;
};
/**
 * EntitlementDetailApi - factory interface
 * @export
 */
export declare const EntitlementDetailApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     * Endpoint for searching all matching activation code details for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search all matching activation code details for a Cwl pipeline.
     * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllMatchingActivationCodesForCwl(searchMatchingActivationCodesForCwlAnalysis?: SearchMatchingActivationCodesForCwlAnalysis | undefined, options?: any): AxiosPromise<ActivationCodeDetailList>;
    /**
     * Endpoint for searching all matching activation code details for a project and an analysis from a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search all matching activation code details for a Nextflow pipeline.
     * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis?: SearchMatchingActivationCodesForNextflowAnalysis | undefined, options?: any): AxiosPromise<ActivationCodeDetailList>;
    /**
     * Endpoint for searching the best activation code detail for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search the best matching activation code detail for Cwl pipeline.
     * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findBestMatchingActivationCodeForCwl(searchMatchingActivationCodesForCwlAnalysis?: SearchMatchingActivationCodesForCwlAnalysis | undefined, options?: any): AxiosPromise<ActivationCodeDetail>;
    /**
     * Endpoint for searching the best activation code details for a project and an analysis for a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search the best matching activation code details for Nextflow pipeline.
     * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findBestMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis?: SearchMatchingActivationCodesForNextflowAnalysis | undefined, options?: any): AxiosPromise<ActivationCodeDetail>;
};
/**
 * EntitlementDetailApi - object-oriented interface
 * @export
 * @class EntitlementDetailApi
 * @extends {BaseAPI}
 */
export declare class EntitlementDetailApi extends BaseAPI {
    /**
     * Endpoint for searching all matching activation code details for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search all matching activation code details for a Cwl pipeline.
     * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementDetailApi
     */
    findAllMatchingActivationCodesForCwl(searchMatchingActivationCodesForCwlAnalysis?: SearchMatchingActivationCodesForCwlAnalysis, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ActivationCodeDetailList, any>>;
    /**
     * Endpoint for searching all matching activation code details for a project and an analysis from a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search all matching activation code details for a Nextflow pipeline.
     * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementDetailApi
     */
    findAllMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis?: SearchMatchingActivationCodesForNextflowAnalysis, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ActivationCodeDetailList, any>>;
    /**
     * Endpoint for searching the best activation code detail for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search the best matching activation code detail for Cwl pipeline.
     * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementDetailApi
     */
    findBestMatchingActivationCodeForCwl(searchMatchingActivationCodesForCwlAnalysis?: SearchMatchingActivationCodesForCwlAnalysis, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ActivationCodeDetail, any>>;
    /**
     * Endpoint for searching the best activation code details for a project and an analysis for a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search the best matching activation code details for Nextflow pipeline.
     * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementDetailApi
     */
    findBestMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis?: SearchMatchingActivationCodesForNextflowAnalysis, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ActivationCodeDetail, any>>;
}
/**
 * EventCodeApi - axios parameter creator
 * @export
 */
export declare const EventCodeApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve event codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventCodes: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * EventCodeApi - functional programming interface
 * @export
 */
export declare const EventCodeApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve event codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventCodes(options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<EventCodeList>>;
};
/**
 * EventCodeApi - factory interface
 * @export
 */
export declare const EventCodeApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Retrieve event codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventCodes(options?: any): AxiosPromise<EventCodeList>;
};
/**
 * EventCodeApi - object-oriented interface
 * @export
 * @class EventCodeApi
 * @extends {BaseAPI}
 */
export declare class EventCodeApi extends BaseAPI {
    /**
     *
     * @summary Retrieve event codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventCodeApi
     */
    getEventCodes(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<EventCodeList, any>>;
}
/**
 * EventLogApi - axios parameter creator
 * @export
 */
export declare const EventLogApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a list of event logs.
     * @param {string} [code] Code
     * @param {'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS'} [codeFilterType] Code filter type
     * @param {'ERROR' | 'WARN' | 'INFO'} [category] Category
     * @param {string} [dateFrom] Date from
     * @param {string} [dateUntil] Date until
     * @param {number} [rows] Amount of rows to fetch. Maximum 250. Defaults to 250
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventLogs: (code?: string | undefined, codeFilterType?: "STARTS_WITH" | "ENDS_WITH" | "EQUALS" | undefined, category?: "ERROR" | "WARN" | "INFO" | undefined, dateFrom?: string | undefined, dateUntil?: string | undefined, rows?: number | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * EventLogApi - functional programming interface
 * @export
 */
export declare const EventLogApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a list of event logs.
     * @param {string} [code] Code
     * @param {'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS'} [codeFilterType] Code filter type
     * @param {'ERROR' | 'WARN' | 'INFO'} [category] Category
     * @param {string} [dateFrom] Date from
     * @param {string} [dateUntil] Date until
     * @param {number} [rows] Amount of rows to fetch. Maximum 250. Defaults to 250
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventLogs(code?: string | undefined, codeFilterType?: "STARTS_WITH" | "ENDS_WITH" | "EQUALS" | undefined, category?: "ERROR" | "WARN" | "INFO" | undefined, dateFrom?: string | undefined, dateUntil?: string | undefined, rows?: number | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<EventLogList>>;
};
/**
 * EventLogApi - factory interface
 * @export
 */
export declare const EventLogApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Retrieve a list of event logs.
     * @param {string} [code] Code
     * @param {'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS'} [codeFilterType] Code filter type
     * @param {'ERROR' | 'WARN' | 'INFO'} [category] Category
     * @param {string} [dateFrom] Date from
     * @param {string} [dateUntil] Date until
     * @param {number} [rows] Amount of rows to fetch. Maximum 250. Defaults to 250
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventLogs(code?: string | undefined, codeFilterType?: "STARTS_WITH" | "ENDS_WITH" | "EQUALS" | undefined, category?: "ERROR" | "WARN" | "INFO" | undefined, dateFrom?: string | undefined, dateUntil?: string | undefined, rows?: number | undefined, options?: any): AxiosPromise<EventLogList>;
};
/**
 * EventLogApi - object-oriented interface
 * @export
 * @class EventLogApi
 * @extends {BaseAPI}
 */
export declare class EventLogApi extends BaseAPI {
    /**
     *
     * @summary Retrieve a list of event logs.
     * @param {string} [code] Code
     * @param {'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS'} [codeFilterType] Code filter type
     * @param {'ERROR' | 'WARN' | 'INFO'} [category] Category
     * @param {string} [dateFrom] Date from
     * @param {string} [dateUntil] Date until
     * @param {number} [rows] Amount of rows to fetch. Maximum 250. Defaults to 250
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventLogApi
     */
    getEventLogs(code?: string, codeFilterType?: 'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS', category?: 'ERROR' | 'WARN' | 'INFO', dateFrom?: string, dateUntil?: string, rows?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<EventLogList, any>>;
}
/**
 * MetadataModelApi - axios parameter creator
 * @export
 */
export declare const MetadataModelApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a metadata model. Only metadata models that the user has access to can be retrieved.
     * @param {string} metadataModelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataModel: (metadataModelId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve the fields of a metadata model. Only metadata models that the user has access to can be retrieved.
     * @param {string} metadataModelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataModelFields: (metadataModelId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve the metadata models for the tenant associated to the security context. This call returns a list of metadata models for the tenant in a non-hierarchical way. Instead of a model having a list of child models all models except the root model have a parent model identifier. This can be used to reconstruct the hierarchy.
     * @summary Retrieve the metadata models for the tenant associated to the security context.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataModels: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve the tenant model for the tenant associated to the security context. The tenant model is a hierarchical structure where the top level tenant holds a list of child models (which in turn can hold child models).
     * @summary Retrieve the tenant model for the tenant associated to the security context.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenantModel: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * MetadataModelApi - functional programming interface
 * @export
 */
export declare const MetadataModelApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a metadata model. Only metadata models that the user has access to can be retrieved.
     * @param {string} metadataModelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataModel(metadataModelId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<MetadataModel>>;
    /**
     *
     * @summary Retrieve the fields of a metadata model. Only metadata models that the user has access to can be retrieved.
     * @param {string} metadataModelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataModelFields(metadataModelId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<FieldList>>;
    /**
     * Retrieve the metadata models for the tenant associated to the security context. This call returns a list of metadata models for the tenant in a non-hierarchical way. Instead of a model having a list of child models all models except the root model have a parent model identifier. This can be used to reconstruct the hierarchy.
     * @summary Retrieve the metadata models for the tenant associated to the security context.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataModels(options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<MetadataModelList>>;
    /**
     * Retrieve the tenant model for the tenant associated to the security context. The tenant model is a hierarchical structure where the top level tenant holds a list of child models (which in turn can hold child models).
     * @summary Retrieve the tenant model for the tenant associated to the security context.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenantModel(options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Model>>;
};
/**
 * MetadataModelApi - factory interface
 * @export
 */
export declare const MetadataModelApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Retrieve a metadata model. Only metadata models that the user has access to can be retrieved.
     * @param {string} metadataModelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataModel(metadataModelId: string, options?: any): AxiosPromise<MetadataModel>;
    /**
     *
     * @summary Retrieve the fields of a metadata model. Only metadata models that the user has access to can be retrieved.
     * @param {string} metadataModelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataModelFields(metadataModelId: string, options?: any): AxiosPromise<FieldList>;
    /**
     * Retrieve the metadata models for the tenant associated to the security context. This call returns a list of metadata models for the tenant in a non-hierarchical way. Instead of a model having a list of child models all models except the root model have a parent model identifier. This can be used to reconstruct the hierarchy.
     * @summary Retrieve the metadata models for the tenant associated to the security context.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataModels(options?: any): AxiosPromise<MetadataModelList>;
    /**
     * Retrieve the tenant model for the tenant associated to the security context. The tenant model is a hierarchical structure where the top level tenant holds a list of child models (which in turn can hold child models).
     * @summary Retrieve the tenant model for the tenant associated to the security context.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenantModel(options?: any): AxiosPromise<Model>;
};
/**
 * MetadataModelApi - object-oriented interface
 * @export
 * @class MetadataModelApi
 * @extends {BaseAPI}
 */
export declare class MetadataModelApi extends BaseAPI {
    /**
     *
     * @summary Retrieve a metadata model. Only metadata models that the user has access to can be retrieved.
     * @param {string} metadataModelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataModelApi
     */
    getMetadataModel(metadataModelId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<MetadataModel, any>>;
    /**
     *
     * @summary Retrieve the fields of a metadata model. Only metadata models that the user has access to can be retrieved.
     * @param {string} metadataModelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataModelApi
     */
    getMetadataModelFields(metadataModelId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<FieldList, any>>;
    /**
     * Retrieve the metadata models for the tenant associated to the security context. This call returns a list of metadata models for the tenant in a non-hierarchical way. Instead of a model having a list of child models all models except the root model have a parent model identifier. This can be used to reconstruct the hierarchy.
     * @summary Retrieve the metadata models for the tenant associated to the security context.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataModelApi
     */
    getMetadataModels(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<MetadataModelList, any>>;
    /**
     * Retrieve the tenant model for the tenant associated to the security context. The tenant model is a hierarchical structure where the top level tenant holds a list of child models (which in turn can hold child models).
     * @summary Retrieve the tenant model for the tenant associated to the security context.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataModelApi
     */
    getTenantModel(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Model, any>>;
}
/**
 * NotificationChannelApi - axios parameter creator
 * @export
 */
export declare const NotificationChannelApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a notification channel
     * @param {CreateNotificationChannel} [createNotificationChannel] The new channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNotificationChannel: (createNotificationChannel?: CreateNotificationChannel | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete a notification channel
     * @param {string} channelId The ID of the notification channel to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotificationChannel: (channelId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a notification channel
     * @param {string} channelId The ID of the notification channel to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationChannel: (channelId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve notification channels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationChannels: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * This will affect all subscriptions which use this address!Fields which can be updated:  - enabled  - address
     * @summary Update a notification channel
     * @param {string} channelId The ID of the notification channel to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {NotificationChannel} [notificationChannel] The updated channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNotificationChannel: (channelId: string, ifMatch?: string | undefined, notificationChannel?: NotificationChannel | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * NotificationChannelApi - functional programming interface
 * @export
 */
export declare const NotificationChannelApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a notification channel
     * @param {CreateNotificationChannel} [createNotificationChannel] The new channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNotificationChannel(createNotificationChannel?: CreateNotificationChannel | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<NotificationChannel>>;
    /**
     *
     * @summary Delete a notification channel
     * @param {string} channelId The ID of the notification channel to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotificationChannel(channelId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Retrieve a notification channel
     * @param {string} channelId The ID of the notification channel to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationChannel(channelId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<NotificationChannel>>;
    /**
     *
     * @summary Retrieve notification channels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationChannels(options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<NotificationChannelList>>;
    /**
     * This will affect all subscriptions which use this address!Fields which can be updated:  - enabled  - address
     * @summary Update a notification channel
     * @param {string} channelId The ID of the notification channel to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {NotificationChannel} [notificationChannel] The updated channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNotificationChannel(channelId: string, ifMatch?: string | undefined, notificationChannel?: NotificationChannel | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<NotificationChannel>>;
};
/**
 * NotificationChannelApi - factory interface
 * @export
 */
export declare const NotificationChannelApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Create a notification channel
     * @param {CreateNotificationChannel} [createNotificationChannel] The new channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNotificationChannel(createNotificationChannel?: CreateNotificationChannel | undefined, options?: any): AxiosPromise<NotificationChannel>;
    /**
     *
     * @summary Delete a notification channel
     * @param {string} channelId The ID of the notification channel to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotificationChannel(channelId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Retrieve a notification channel
     * @param {string} channelId The ID of the notification channel to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationChannel(channelId: string, options?: any): AxiosPromise<NotificationChannel>;
    /**
     *
     * @summary Retrieve notification channels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationChannels(options?: any): AxiosPromise<NotificationChannelList>;
    /**
     * This will affect all subscriptions which use this address!Fields which can be updated:  - enabled  - address
     * @summary Update a notification channel
     * @param {string} channelId The ID of the notification channel to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {NotificationChannel} [notificationChannel] The updated channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNotificationChannel(channelId: string, ifMatch?: string | undefined, notificationChannel?: NotificationChannel | undefined, options?: any): AxiosPromise<NotificationChannel>;
};
/**
 * NotificationChannelApi - object-oriented interface
 * @export
 * @class NotificationChannelApi
 * @extends {BaseAPI}
 */
export declare class NotificationChannelApi extends BaseAPI {
    /**
     *
     * @summary Create a notification channel
     * @param {CreateNotificationChannel} [createNotificationChannel] The new channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelApi
     */
    createNotificationChannel(createNotificationChannel?: CreateNotificationChannel, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<NotificationChannel, any>>;
    /**
     *
     * @summary Delete a notification channel
     * @param {string} channelId The ID of the notification channel to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelApi
     */
    deleteNotificationChannel(channelId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Retrieve a notification channel
     * @param {string} channelId The ID of the notification channel to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelApi
     */
    getNotificationChannel(channelId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<NotificationChannel, any>>;
    /**
     *
     * @summary Retrieve notification channels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelApi
     */
    getNotificationChannels(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<NotificationChannelList, any>>;
    /**
     * This will affect all subscriptions which use this address!Fields which can be updated:  - enabled  - address
     * @summary Update a notification channel
     * @param {string} channelId The ID of the notification channel to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {NotificationChannel} [notificationChannel] The updated channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelApi
     */
    updateNotificationChannel(channelId: string, ifMatch?: string, notificationChannel?: NotificationChannel, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<NotificationChannel, any>>;
}
/**
 * PipelineApi - axios parameter creator
 * @export
 */
export declare const PipelineApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipeline: (pipelineId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve input parameters for a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve input parameters for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelineInputParameters: (pipelineId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve the reference sets of a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelineReferenceSets: (pipelineId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of pipelines.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelines: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * PipelineApi - functional programming interface
 * @export
 */
export declare const PipelineApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipeline(pipelineId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Pipeline>>;
    /**
     *
     * @summary Retrieve input parameters for a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve input parameters for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelineInputParameters(pipelineId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<InputParameterList>>;
    /**
     *
     * @summary Retrieve the reference sets of a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelineReferenceSets(pipelineId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ReferenceSetList>>;
    /**
     *
     * @summary Retrieve a list of pipelines.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelines(options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<PipelineList>>;
};
/**
 * PipelineApi - factory interface
 * @export
 */
export declare const PipelineApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Retrieve a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipeline(pipelineId: string, options?: any): AxiosPromise<Pipeline>;
    /**
     *
     * @summary Retrieve input parameters for a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve input parameters for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelineInputParameters(pipelineId: string, options?: any): AxiosPromise<InputParameterList>;
    /**
     *
     * @summary Retrieve the reference sets of a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelineReferenceSets(pipelineId: string, options?: any): AxiosPromise<ReferenceSetList>;
    /**
     *
     * @summary Retrieve a list of pipelines.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPipelines(options?: any): AxiosPromise<PipelineList>;
};
/**
 * PipelineApi - object-oriented interface
 * @export
 * @class PipelineApi
 * @extends {BaseAPI}
 */
export declare class PipelineApi extends BaseAPI {
    /**
     *
     * @summary Retrieve a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    getPipeline(pipelineId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Pipeline, any>>;
    /**
     *
     * @summary Retrieve input parameters for a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve input parameters for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    getPipelineInputParameters(pipelineId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<InputParameterList, any>>;
    /**
     *
     * @summary Retrieve the reference sets of a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    getPipelineReferenceSets(pipelineId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ReferenceSetList, any>>;
    /**
     *
     * @summary Retrieve a list of pipelines.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    getPipelines(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PipelineList, any>>;
}
/**
 * ProjectApi - axios parameter creator
 * @export
 */
export declare const ProjectApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a new project.
     * @param {CreateProject} [createProject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProject: (createProject?: CreateProject | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a project.
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProject: (projectId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of projects.
     * @param {string} [search] Search
     * @param {Array<string>} [userTags] User tags to filter on
     * @param {Array<string>} [technicalTags] Technical tags to filter on
     * @param {boolean} [includeHiddenProjects] Include hidden projects.
     * @param {string} [region] The ID of the region to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription - information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjects: (search?: string | undefined, userTags?: string[] | undefined, technicalTags?: string[] | undefined, includeHiddenProjects?: boolean | undefined, region?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fields which can be updated: - shortDescription - projectInformation - billingMode - dataSharingEnabled - tags - storageBundle - metaDataModel
     * @summary Update a project.
     * @param {string} projectId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {Project} [project]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProject: (projectId: string, ifMatch?: string | undefined, project?: Project | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProjectApi - functional programming interface
 * @export
 */
export declare const ProjectApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a new project.
     * @param {CreateProject} [createProject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProject(createProject?: CreateProject | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Project>>;
    /**
     *
     * @summary Retrieve a project.
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProject(projectId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Project>>;
    /**
     *
     * @summary Retrieve a list of projects.
     * @param {string} [search] Search
     * @param {Array<string>} [userTags] User tags to filter on
     * @param {Array<string>} [technicalTags] Technical tags to filter on
     * @param {boolean} [includeHiddenProjects] Include hidden projects.
     * @param {string} [region] The ID of the region to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription - information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjects(search?: string | undefined, userTags?: string[] | undefined, technicalTags?: string[] | undefined, includeHiddenProjects?: boolean | undefined, region?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectPagedList>>;
    /**
     * Fields which can be updated: - shortDescription - projectInformation - billingMode - dataSharingEnabled - tags - storageBundle - metaDataModel
     * @summary Update a project.
     * @param {string} projectId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {Project} [project]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProject(projectId: string, ifMatch?: string | undefined, project?: Project | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Project>>;
};
/**
 * ProjectApi - factory interface
 * @export
 */
export declare const ProjectApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Create a new project.
     * @param {CreateProject} [createProject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProject(createProject?: CreateProject | undefined, options?: any): AxiosPromise<Project>;
    /**
     *
     * @summary Retrieve a project.
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProject(projectId: string, options?: any): AxiosPromise<Project>;
    /**
     *
     * @summary Retrieve a list of projects.
     * @param {string} [search] Search
     * @param {Array<string>} [userTags] User tags to filter on
     * @param {Array<string>} [technicalTags] Technical tags to filter on
     * @param {boolean} [includeHiddenProjects] Include hidden projects.
     * @param {string} [region] The ID of the region to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription - information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjects(search?: string | undefined, userTags?: string[] | undefined, technicalTags?: string[] | undefined, includeHiddenProjects?: boolean | undefined, region?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: any): AxiosPromise<ProjectPagedList>;
    /**
     * Fields which can be updated: - shortDescription - projectInformation - billingMode - dataSharingEnabled - tags - storageBundle - metaDataModel
     * @summary Update a project.
     * @param {string} projectId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {Project} [project]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProject(projectId: string, ifMatch?: string | undefined, project?: Project | undefined, options?: any): AxiosPromise<Project>;
};
/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export declare class ProjectApi extends BaseAPI {
    /**
     *
     * @summary Create a new project.
     * @param {CreateProject} [createProject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    createProject(createProject?: CreateProject, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Project, any>>;
    /**
     *
     * @summary Retrieve a project.
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    getProject(projectId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Project, any>>;
    /**
     *
     * @summary Retrieve a list of projects.
     * @param {string} [search] Search
     * @param {Array<string>} [userTags] User tags to filter on
     * @param {Array<string>} [technicalTags] Technical tags to filter on
     * @param {boolean} [includeHiddenProjects] Include hidden projects.
     * @param {string} [region] The ID of the region to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription - information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    getProjects(search?: string, userTags?: Array<string>, technicalTags?: Array<string>, includeHiddenProjects?: boolean, region?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectPagedList, any>>;
    /**
     * Fields which can be updated: - shortDescription - projectInformation - billingMode - dataSharingEnabled - tags - storageBundle - metaDataModel
     * @summary Update a project.
     * @param {string} projectId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {Project} [project]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    updateProject(projectId: string, ifMatch?: string, project?: Project, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Project, any>>;
}
/**
 * ProjectAnalysisApi - axios parameter creator
 * @export
 */
export declare const ProjectAnalysisApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Abort an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to abort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abortAnalysis: (projectId: string, analysisId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Create and start an analysis for a CWL pipeline.
     * @param {string} projectId
     * @param {CreateCwlAnalysis} createCwlAnalysis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCwlAnalysis: (projectId: string, createCwlAnalysis: CreateCwlAnalysis, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Create and start an analysis for a Nextflow pipeline.
     * @param {string} projectId
     * @param {CreateNextflowAnalysis} createNextflowAnalysis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNextflowAnalysis: (projectId: string, createNextflowAnalysis: CreateNextflowAnalysis, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve the list of project analyses.
     * @param {string} projectId
     * @param {string} [reference] The reference to filter on.
     * @param {string} [userreference] The user-reference to filter on.
     * @param {string} [status] The status to filter on.
     * @param {string} [usertag] The user-tags to filter on.
     * @param {string} [technicaltag] The technical-tags to filter on.
     * @param {string} [referencetag] The reference-data-tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalyses: (projectId: string, reference?: string | undefined, userreference?: string | undefined, status?: string | undefined, usertag?: string | undefined, technicaltag?: string | undefined, referencetag?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysis: (projectId: string, analysisId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve the configurations of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the configuration for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysisConfigurations: (projectId: string, analysisId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve the inputs of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the inputs for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysisInputs: (projectId: string, analysisId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve the outputs of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the outputs for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysisOutputs: (projectId: string, analysisId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve the individual steps of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the individual steps for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysisSteps: (projectId: string, analysisId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve the raw output of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis for which to retrieve the raw output
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hGetExecutionOutputObject: (projectId: string, analysisId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Attributes which can be updated:    - tags
     * @summary Update an analysis.
     * @param {string} projectId
     * @param {string} analysisId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {Analysis} [analysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAnalysis: (projectId: string, analysisId: string, ifMatch?: string | undefined, analysis?: Analysis | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProjectAnalysisApi - functional programming interface
 * @export
 */
export declare const ProjectAnalysisApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Abort an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to abort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abortAnalysis(projectId: string, analysisId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Create and start an analysis for a CWL pipeline.
     * @param {string} projectId
     * @param {CreateCwlAnalysis} createCwlAnalysis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCwlAnalysis(projectId: string, createCwlAnalysis: CreateCwlAnalysis, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Analysis>>;
    /**
     *
     * @summary Create and start an analysis for a Nextflow pipeline.
     * @param {string} projectId
     * @param {CreateNextflowAnalysis} createNextflowAnalysis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNextflowAnalysis(projectId: string, createNextflowAnalysis: CreateNextflowAnalysis, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Analysis>>;
    /**
     *
     * @summary Retrieve the list of project analyses.
     * @param {string} projectId
     * @param {string} [reference] The reference to filter on.
     * @param {string} [userreference] The user-reference to filter on.
     * @param {string} [status] The status to filter on.
     * @param {string} [usertag] The user-tags to filter on.
     * @param {string} [technicaltag] The technical-tags to filter on.
     * @param {string} [referencetag] The reference-data-tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalyses(projectId: string, reference?: string | undefined, userreference?: string | undefined, status?: string | undefined, usertag?: string | undefined, technicaltag?: string | undefined, referencetag?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<AnalysisPagedList>>;
    /**
     *
     * @summary Retrieve an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysis(projectId: string, analysisId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Analysis>>;
    /**
     *
     * @summary Retrieve the configurations of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the configuration for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysisConfigurations(projectId: string, analysisId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ExecutionConfigurationList>>;
    /**
     *
     * @summary Retrieve the inputs of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the inputs for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysisInputs(projectId: string, analysisId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<AnalysisInputList>>;
    /**
     *
     * @summary Retrieve the outputs of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the outputs for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysisOutputs(projectId: string, analysisId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<AnalysisOutputList>>;
    /**
     *
     * @summary Retrieve the individual steps of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the individual steps for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysisSteps(projectId: string, analysisId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<AnalysisStepList>>;
    /**
     *
     * @summary Retrieve the raw output of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis for which to retrieve the raw output
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hGetExecutionOutputObject(projectId: string, analysisId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<AnalysisRawOutput>>;
    /**
     * Attributes which can be updated:    - tags
     * @summary Update an analysis.
     * @param {string} projectId
     * @param {string} analysisId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {Analysis} [analysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAnalysis(projectId: string, analysisId: string, ifMatch?: string | undefined, analysis?: Analysis | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Analysis>>;
};
/**
 * ProjectAnalysisApi - factory interface
 * @export
 */
export declare const ProjectAnalysisApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     * Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Abort an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to abort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abortAnalysis(projectId: string, analysisId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Create and start an analysis for a CWL pipeline.
     * @param {string} projectId
     * @param {CreateCwlAnalysis} createCwlAnalysis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCwlAnalysis(projectId: string, createCwlAnalysis: CreateCwlAnalysis, options?: any): AxiosPromise<Analysis>;
    /**
     *
     * @summary Create and start an analysis for a Nextflow pipeline.
     * @param {string} projectId
     * @param {CreateNextflowAnalysis} createNextflowAnalysis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNextflowAnalysis(projectId: string, createNextflowAnalysis: CreateNextflowAnalysis, options?: any): AxiosPromise<Analysis>;
    /**
     *
     * @summary Retrieve the list of project analyses.
     * @param {string} projectId
     * @param {string} [reference] The reference to filter on.
     * @param {string} [userreference] The user-reference to filter on.
     * @param {string} [status] The status to filter on.
     * @param {string} [usertag] The user-tags to filter on.
     * @param {string} [technicaltag] The technical-tags to filter on.
     * @param {string} [referencetag] The reference-data-tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalyses(projectId: string, reference?: string | undefined, userreference?: string | undefined, status?: string | undefined, usertag?: string | undefined, technicaltag?: string | undefined, referencetag?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: any): AxiosPromise<AnalysisPagedList>;
    /**
     *
     * @summary Retrieve an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysis(projectId: string, analysisId: string, options?: any): AxiosPromise<Analysis>;
    /**
     *
     * @summary Retrieve the configurations of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the configuration for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysisConfigurations(projectId: string, analysisId: string, options?: any): AxiosPromise<ExecutionConfigurationList>;
    /**
     *
     * @summary Retrieve the inputs of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the inputs for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysisInputs(projectId: string, analysisId: string, options?: any): AxiosPromise<AnalysisInputList>;
    /**
     *
     * @summary Retrieve the outputs of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the outputs for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysisOutputs(projectId: string, analysisId: string, options?: any): AxiosPromise<AnalysisOutputList>;
    /**
     *
     * @summary Retrieve the individual steps of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the individual steps for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalysisSteps(projectId: string, analysisId: string, options?: any): AxiosPromise<AnalysisStepList>;
    /**
     *
     * @summary Retrieve the raw output of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis for which to retrieve the raw output
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hGetExecutionOutputObject(projectId: string, analysisId: string, options?: any): AxiosPromise<AnalysisRawOutput>;
    /**
     * Attributes which can be updated:    - tags
     * @summary Update an analysis.
     * @param {string} projectId
     * @param {string} analysisId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {Analysis} [analysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAnalysis(projectId: string, analysisId: string, ifMatch?: string | undefined, analysis?: Analysis | undefined, options?: any): AxiosPromise<Analysis>;
};
/**
 * ProjectAnalysisApi - object-oriented interface
 * @export
 * @class ProjectAnalysisApi
 * @extends {BaseAPI}
 */
export declare class ProjectAnalysisApi extends BaseAPI {
    /**
     * Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Abort an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to abort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    abortAnalysis(projectId: string, analysisId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Create and start an analysis for a CWL pipeline.
     * @param {string} projectId
     * @param {CreateCwlAnalysis} createCwlAnalysis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    createCwlAnalysis(projectId: string, createCwlAnalysis: CreateCwlAnalysis, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Analysis, any>>;
    /**
     *
     * @summary Create and start an analysis for a Nextflow pipeline.
     * @param {string} projectId
     * @param {CreateNextflowAnalysis} createNextflowAnalysis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    createNextflowAnalysis(projectId: string, createNextflowAnalysis: CreateNextflowAnalysis, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Analysis, any>>;
    /**
     *
     * @summary Retrieve the list of project analyses.
     * @param {string} projectId
     * @param {string} [reference] The reference to filter on.
     * @param {string} [userreference] The user-reference to filter on.
     * @param {string} [status] The status to filter on.
     * @param {string} [usertag] The user-tags to filter on.
     * @param {string} [technicaltag] The technical-tags to filter on.
     * @param {string} [referencetag] The reference-data-tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    getAnalyses(projectId: string, reference?: string, userreference?: string, status?: string, usertag?: string, technicaltag?: string, referencetag?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AnalysisPagedList, any>>;
    /**
     *
     * @summary Retrieve an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    getAnalysis(projectId: string, analysisId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Analysis, any>>;
    /**
     *
     * @summary Retrieve the configurations of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the configuration for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    getAnalysisConfigurations(projectId: string, analysisId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ExecutionConfigurationList, any>>;
    /**
     *
     * @summary Retrieve the inputs of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the inputs for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    getAnalysisInputs(projectId: string, analysisId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AnalysisInputList, any>>;
    /**
     *
     * @summary Retrieve the outputs of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the outputs for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    getAnalysisOutputs(projectId: string, analysisId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AnalysisOutputList, any>>;
    /**
     *
     * @summary Retrieve the individual steps of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the individual steps for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    getAnalysisSteps(projectId: string, analysisId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AnalysisStepList, any>>;
    /**
     *
     * @summary Retrieve the raw output of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis for which to retrieve the raw output
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    hGetExecutionOutputObject(projectId: string, analysisId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AnalysisRawOutput, any>>;
    /**
     * Attributes which can be updated:    - tags
     * @summary Update an analysis.
     * @param {string} projectId
     * @param {string} analysisId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {Analysis} [analysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    updateAnalysis(projectId: string, analysisId: string, ifMatch?: string, analysis?: Analysis, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Analysis, any>>;
}
/**
 * ProjectBaseApi - axios parameter creator
 * @export
 */
export declare const ProjectBaseApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Creates the connection details to snowflake instance.
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBaseConnectionDetails: (projectId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProjectBaseApi - functional programming interface
 * @export
 */
export declare const ProjectBaseApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Creates the connection details to snowflake instance.
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBaseConnectionDetails(projectId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<BaseConnection>>;
};
/**
 * ProjectBaseApi - factory interface
 * @export
 */
export declare const ProjectBaseApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Creates the connection details to snowflake instance.
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBaseConnectionDetails(projectId: string, options?: any): AxiosPromise<BaseConnection>;
};
/**
 * ProjectBaseApi - object-oriented interface
 * @export
 * @class ProjectBaseApi
 * @extends {BaseAPI}
 */
export declare class ProjectBaseApi extends BaseAPI {
    /**
     *
     * @summary Creates the connection details to snowflake instance.
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectBaseApi
     */
    createBaseConnectionDetails(projectId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BaseConnection, any>>;
}
/**
 * ProjectBaseJobApi - axios parameter creator
 * @export
 */
export declare const ProjectBaseJobApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a base job.
     * @param {string} projectId
     * @param {string} baseJobId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBaseJob: (projectId: string, baseJobId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of base jobs
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBaseJobs: (projectId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProjectBaseJobApi - functional programming interface
 * @export
 */
export declare const ProjectBaseJobApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a base job.
     * @param {string} projectId
     * @param {string} baseJobId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBaseJob(projectId: string, baseJobId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<BaseJob>>;
    /**
     *
     * @summary Retrieve a list of base jobs
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBaseJobs(projectId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<BaseJobList>>;
};
/**
 * ProjectBaseJobApi - factory interface
 * @export
 */
export declare const ProjectBaseJobApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Retrieve a base job.
     * @param {string} projectId
     * @param {string} baseJobId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBaseJob(projectId: string, baseJobId: string, options?: any): AxiosPromise<BaseJob>;
    /**
     *
     * @summary Retrieve a list of base jobs
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBaseJobs(projectId: string, options?: any): AxiosPromise<BaseJobList>;
};
/**
 * ProjectBaseJobApi - object-oriented interface
 * @export
 * @class ProjectBaseJobApi
 * @extends {BaseAPI}
 */
export declare class ProjectBaseJobApi extends BaseAPI {
    /**
     *
     * @summary Retrieve a base job.
     * @param {string} projectId
     * @param {string} baseJobId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectBaseJobApi
     */
    getBaseJob(projectId: string, baseJobId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BaseJob, any>>;
    /**
     *
     * @summary Retrieve a list of base jobs
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectBaseJobApi
     */
    getBaseJobs(projectId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BaseJobList, any>>;
}
/**
 * ProjectBaseTableApi - axios parameter creator
 * @export
 */
export declare const ProjectBaseTableApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a liste of base tables.
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBaseTables: (projectId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Load data in the specified table
     * @summary Load data in a base table.
     * @param {string} projectId
     * @param {string} tableId
     * @param {LoadDataInBaseRequest} [loadDataInBaseRequest] Load data request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loadData: (projectId: string, tableId: string, loadDataInBaseRequest?: LoadDataInBaseRequest | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProjectBaseTableApi - functional programming interface
 * @export
 */
export declare const ProjectBaseTableApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a liste of base tables.
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBaseTables(projectId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectBaseTableList>>;
    /**
     * Load data in the specified table
     * @summary Load data in a base table.
     * @param {string} projectId
     * @param {string} tableId
     * @param {LoadDataInBaseRequest} [loadDataInBaseRequest] Load data request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loadData(projectId: string, tableId: string, loadDataInBaseRequest?: LoadDataInBaseRequest | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<BaseJob>>;
};
/**
 * ProjectBaseTableApi - factory interface
 * @export
 */
export declare const ProjectBaseTableApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Retrieve a liste of base tables.
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBaseTables(projectId: string, options?: any): AxiosPromise<ProjectBaseTableList>;
    /**
     * Load data in the specified table
     * @summary Load data in a base table.
     * @param {string} projectId
     * @param {string} tableId
     * @param {LoadDataInBaseRequest} [loadDataInBaseRequest] Load data request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loadData(projectId: string, tableId: string, loadDataInBaseRequest?: LoadDataInBaseRequest | undefined, options?: any): AxiosPromise<BaseJob>;
};
/**
 * ProjectBaseTableApi - object-oriented interface
 * @export
 * @class ProjectBaseTableApi
 * @extends {BaseAPI}
 */
export declare class ProjectBaseTableApi extends BaseAPI {
    /**
     *
     * @summary Retrieve a liste of base tables.
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectBaseTableApi
     */
    getBaseTables(projectId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectBaseTableList, any>>;
    /**
     * Load data in the specified table
     * @summary Load data in a base table.
     * @param {string} projectId
     * @param {string} tableId
     * @param {LoadDataInBaseRequest} [loadDataInBaseRequest] Load data request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectBaseTableApi
     */
    loadData(projectId: string, tableId: string, loadDataInBaseRequest?: LoadDataInBaseRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BaseJob, any>>;
}
/**
 * ProjectCustomEventsApi - axios parameter creator
 * @export
 */
export declare const ProjectCustomEventsApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a new custom event.
     * @param {string} projectId
     * @param {CreateCustomEvent} createCustomEvent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCustomEvent: (projectId: string, createCustomEvent: CreateCustomEvent, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProjectCustomEventsApi - functional programming interface
 * @export
 */
export declare const ProjectCustomEventsApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a new custom event.
     * @param {string} projectId
     * @param {CreateCustomEvent} createCustomEvent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCustomEvent(projectId: string, createCustomEvent: CreateCustomEvent, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
};
/**
 * ProjectCustomEventsApi - factory interface
 * @export
 */
export declare const ProjectCustomEventsApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Create a new custom event.
     * @param {string} projectId
     * @param {CreateCustomEvent} createCustomEvent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCustomEvent(projectId: string, createCustomEvent: CreateCustomEvent, options?: any): AxiosPromise<void>;
};
/**
 * ProjectCustomEventsApi - object-oriented interface
 * @export
 * @class ProjectCustomEventsApi
 * @extends {BaseAPI}
 */
export declare class ProjectCustomEventsApi extends BaseAPI {
    /**
     *
     * @summary Create a new custom event.
     * @param {string} projectId
     * @param {CreateCustomEvent} createCustomEvent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomEventsApi
     */
    createCustomEvent(projectId: string, createCustomEvent: CreateCustomEvent, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * ProjectCustomNotificationSubscriptionsApi - axios parameter creator
 * @export
 */
export declare const ProjectCustomNotificationSubscriptionsApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a custom notification subscription
     * @param {string} projectId The ID of the project
     * @param {CreateCustomNotificationSubscription} [createCustomNotificationSubscription] The new subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNotificationSubscription: (projectId: string, createCustomNotificationSubscription?: CreateCustomNotificationSubscription | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete a custom notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the custom notification subscription to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotificationSubscription: (projectId: string, subscriptionId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSubscription: (projectId: string, subscriptionId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve notification subscriptions
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSubscriptions: (projectId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel
     * @summary Update a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the custom notification subscription to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {CustomNotificationSubscription} [customNotificationSubscription] The updated subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNotificationSubscription: (projectId: string, subscriptionId: string, ifMatch?: string | undefined, customNotificationSubscription?: CustomNotificationSubscription | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProjectCustomNotificationSubscriptionsApi - functional programming interface
 * @export
 */
export declare const ProjectCustomNotificationSubscriptionsApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a custom notification subscription
     * @param {string} projectId The ID of the project
     * @param {CreateCustomNotificationSubscription} [createCustomNotificationSubscription] The new subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNotificationSubscription(projectId: string, createCustomNotificationSubscription?: CreateCustomNotificationSubscription | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<CustomNotificationSubscription>>;
    /**
     *
     * @summary Delete a custom notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the custom notification subscription to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotificationSubscription(projectId: string, subscriptionId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Retrieve a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSubscription(projectId: string, subscriptionId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<CustomNotificationSubscription>>;
    /**
     *
     * @summary Retrieve notification subscriptions
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSubscriptions(projectId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<CustomNotificationSubscriptionList>>;
    /**
     * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel
     * @summary Update a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the custom notification subscription to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {CustomNotificationSubscription} [customNotificationSubscription] The updated subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNotificationSubscription(projectId: string, subscriptionId: string, ifMatch?: string | undefined, customNotificationSubscription?: CustomNotificationSubscription | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<CustomNotificationSubscription>>;
};
/**
 * ProjectCustomNotificationSubscriptionsApi - factory interface
 * @export
 */
export declare const ProjectCustomNotificationSubscriptionsApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Create a custom notification subscription
     * @param {string} projectId The ID of the project
     * @param {CreateCustomNotificationSubscription} [createCustomNotificationSubscription] The new subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNotificationSubscription(projectId: string, createCustomNotificationSubscription?: CreateCustomNotificationSubscription | undefined, options?: any): AxiosPromise<CustomNotificationSubscription>;
    /**
     *
     * @summary Delete a custom notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the custom notification subscription to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotificationSubscription(projectId: string, subscriptionId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Retrieve a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSubscription(projectId: string, subscriptionId: string, options?: any): AxiosPromise<CustomNotificationSubscription>;
    /**
     *
     * @summary Retrieve notification subscriptions
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSubscriptions(projectId: string, options?: any): AxiosPromise<CustomNotificationSubscriptionList>;
    /**
     * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel
     * @summary Update a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the custom notification subscription to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {CustomNotificationSubscription} [customNotificationSubscription] The updated subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNotificationSubscription(projectId: string, subscriptionId: string, ifMatch?: string | undefined, customNotificationSubscription?: CustomNotificationSubscription | undefined, options?: any): AxiosPromise<CustomNotificationSubscription>;
};
/**
 * ProjectCustomNotificationSubscriptionsApi - object-oriented interface
 * @export
 * @class ProjectCustomNotificationSubscriptionsApi
 * @extends {BaseAPI}
 */
export declare class ProjectCustomNotificationSubscriptionsApi extends BaseAPI {
    /**
     *
     * @summary Create a custom notification subscription
     * @param {string} projectId The ID of the project
     * @param {CreateCustomNotificationSubscription} [createCustomNotificationSubscription] The new subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomNotificationSubscriptionsApi
     */
    createNotificationSubscription(projectId: string, createCustomNotificationSubscription?: CreateCustomNotificationSubscription, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<CustomNotificationSubscription, any>>;
    /**
     *
     * @summary Delete a custom notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the custom notification subscription to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomNotificationSubscriptionsApi
     */
    deleteNotificationSubscription(projectId: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Retrieve a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomNotificationSubscriptionsApi
     */
    getNotificationSubscription(projectId: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<CustomNotificationSubscription, any>>;
    /**
     *
     * @summary Retrieve notification subscriptions
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomNotificationSubscriptionsApi
     */
    getNotificationSubscriptions(projectId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<CustomNotificationSubscriptionList, any>>;
    /**
     * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel
     * @summary Update a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the custom notification subscription to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {CustomNotificationSubscription} [customNotificationSubscription] The updated subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomNotificationSubscriptionsApi
     */
    updateNotificationSubscription(projectId: string, subscriptionId: string, ifMatch?: string, customNotificationSubscription?: CustomNotificationSubscription, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<CustomNotificationSubscription, any>>;
}
/**
 * ProjectDataApi - axios parameter creator
 * @export
 */
export declare const ProjectDataApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Endpoint for scheduling this data for archival. This will also archive all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for archival.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archiveData: (projectId: string, dataId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Complete a trackable folder upload session. By completing the folder upload session, and specifying how many files you have uploaded, ICA can ensure that all uploaded files are accounted for.
     * @summary Complete a trackable folder upload session.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} folderUploadSessionId
     * @param {CompleteFolderUploadSession} [completeFolderUploadSession] The info required to complete the folder upload session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeFolderUploadSession: (projectId: string, dataId: string, folderUploadSessionId: string, completeFolderUploadSession?: CompleteFolderUploadSession | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Create data in this project.
     * @param {string} projectId
     * @param {CreateData} [createData] The data to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDataInProject: (projectId: string, createData?: CreateData | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Can be used to download a file directly from the region where it is located, no connector is needed. Only small files can be downloaded, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve a download URL for this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDownloadUrlForData: (projectId: string, dataId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * This endpoint can be used to ensure that all uploaded files within the requested session are accounted for. This call has to be used together with the :complete endpoint once upload is done.
     * @summary Create a trackable folder upload session.
     * @param {string} projectId
     * @param {string} dataId
     * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolderUploadSession: (projectId: string, dataId: string, createTemporaryCredentials?: CreateTemporaryCredentials | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Can be used to view a file directly from the region where it is located, no connector is needed. Only small files can be viewed, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve an URL for this data to use for inline view in a browser.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInlineViewUrlForData: (projectId: string, dataId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Can be used to upload or download a file directly from the region where it is located, no connector is needed.
     * @summary Retrieve temporary credentials for this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTemporaryCredentialsForData: (projectId: string, dataId: string, createTemporaryCredentials?: CreateTemporaryCredentials | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Can be used to upload a file directly from the region where it is located, no connector is needed. Only small files can be uploaded, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve an upload URL for this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} [fileType]
     * @param {string} [hash]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUploadUrlForData: (projectId: string, dataId: string, fileType?: string | undefined, hash?: string | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint for scheduling this data for deletion. This will also delete all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for deletion.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteData: (projectId: string, dataId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of data eligible for linking to the current project.
     * @param {string} projectId
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned. This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataEligibleForLinking: (projectId: string, fullText?: string | undefined, id?: string[] | undefined, filename?: string[] | undefined, filenameMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, filePath?: string[] | undefined, filePathMatchMode?: "STARTS_WITH_CASE_INSENSITIVE" | "FULL_CASE_INSENSITIVE" | undefined, status?: ("PARTIAL" | "AVAILABLE" | "ARCHIVING" | "ARCHIVED" | "UNARCHIVING" | "DELETING")[] | undefined, formatId?: string[] | undefined, formatCode?: string[] | undefined, type?: "FILE" | "FOLDER" | undefined, parentFolderId?: string[] | undefined, parentFolderPath?: string | undefined, creationDateAfter?: string | undefined, creationDateBefore?: string | undefined, statusDateAfter?: string | undefined, statusDateBefore?: string | undefined, userTag?: string[] | undefined, userTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runInputTag?: string[] | undefined, runInputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runOutputTag?: string[] | undefined, runOutputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, connectorTag?: string[] | undefined, connectorTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, technicalTag?: string[] | undefined, technicalTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, notInRun?: boolean | undefined, notLinkedToSample?: boolean | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve folder upload session details, including the current status of your upload session.
     * @summary Retrieve folder upload session details.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} folderUploadSessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolderUploadSession: (projectId: string, dataId: string, folderUploadSessionId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of project data not linked to a sample.
     * @param {string} projectId
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNonSampleProjectData: (projectId: string, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a project data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectData: (projectId: string, dataId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve the children of this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDataChildren: (projectId: string, dataId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve the list of project data.
     * @param {string} projectId
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned.  This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDataList: (projectId: string, fullText?: string | undefined, id?: string[] | undefined, filename?: string[] | undefined, filenameMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, filePath?: string[] | undefined, filePathMatchMode?: "STARTS_WITH_CASE_INSENSITIVE" | "FULL_CASE_INSENSITIVE" | undefined, status?: ("PARTIAL" | "AVAILABLE" | "ARCHIVING" | "ARCHIVED" | "UNARCHIVING" | "DELETING")[] | undefined, formatId?: string[] | undefined, formatCode?: string[] | undefined, type?: "FILE" | "FOLDER" | undefined, parentFolderId?: string[] | undefined, parentFolderPath?: string | undefined, creationDateAfter?: string | undefined, creationDateBefore?: string | undefined, statusDateAfter?: string | undefined, statusDateBefore?: string | undefined, userTag?: string[] | undefined, userTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runInputTag?: string[] | undefined, runInputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runOutputTag?: string[] | undefined, runOutputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, connectorTag?: string[] | undefined, connectorTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, technicalTag?: string[] | undefined, technicalTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, notInRun?: boolean | undefined, notLinkedToSample?: boolean | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of projects to which this data is linked.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectsLinkedToData: (projectId: string, dataId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Link data to this project.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkDataToProject: (projectId: string, dataId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint for scheduling a download for the data specified by the ID to a connector. This download will only start when the connector is running. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule a download.
     * @param {string} projectId
     * @param {string} dataId
     * @param {ScheduleDownload} scheduleDownload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleDownloadForData: (projectId: string, dataId: string, scheduleDownload: ScheduleDownload, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint for scheduling this data for unarchival. This will also unarchive all files and directories below that data. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for unarchival.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unarchiveData: (projectId: string, dataId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Unlink data from this project.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkDataFromProject: (projectId: string, dataId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fields which can be updated for files:  - data.willBeArchivedAt  - data.willBeDeletedAt  - data.format  - data.tags  Fields which can be updated for folders:  - data.tags
     * @summary Update this project data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {ProjectData} [projectData] The updated project data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectData: (projectId: string, dataId: string, projectData?: ProjectData | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProjectDataApi - functional programming interface
 * @export
 */
export declare const ProjectDataApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Endpoint for scheduling this data for archival. This will also archive all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for archival.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archiveData(projectId: string, dataId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     * Complete a trackable folder upload session. By completing the folder upload session, and specifying how many files you have uploaded, ICA can ensure that all uploaded files are accounted for.
     * @summary Complete a trackable folder upload session.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} folderUploadSessionId
     * @param {CompleteFolderUploadSession} [completeFolderUploadSession] The info required to complete the folder upload session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeFolderUploadSession(projectId: string, dataId: string, folderUploadSessionId: string, completeFolderUploadSession?: CompleteFolderUploadSession | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<FolderUploadSession>>;
    /**
     *
     * @summary Create data in this project.
     * @param {string} projectId
     * @param {CreateData} [createData] The data to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDataInProject(projectId: string, createData?: CreateData | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectData>>;
    /**
     * Can be used to download a file directly from the region where it is located, no connector is needed. Only small files can be downloaded, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve a download URL for this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDownloadUrlForData(projectId: string, dataId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Download>>;
    /**
     * This endpoint can be used to ensure that all uploaded files within the requested session are accounted for. This call has to be used together with the :complete endpoint once upload is done.
     * @summary Create a trackable folder upload session.
     * @param {string} projectId
     * @param {string} dataId
     * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolderUploadSession(projectId: string, dataId: string, createTemporaryCredentials?: CreateTemporaryCredentials | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<FolderUploadSession>>;
    /**
     * Can be used to view a file directly from the region where it is located, no connector is needed. Only small files can be viewed, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve an URL for this data to use for inline view in a browser.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInlineViewUrlForData(projectId: string, dataId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<InlineView>>;
    /**
     * Can be used to upload or download a file directly from the region where it is located, no connector is needed.
     * @summary Retrieve temporary credentials for this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTemporaryCredentialsForData(projectId: string, dataId: string, createTemporaryCredentials?: CreateTemporaryCredentials | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<TempCredentials>>;
    /**
     * Can be used to upload a file directly from the region where it is located, no connector is needed. Only small files can be uploaded, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve an upload URL for this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} [fileType]
     * @param {string} [hash]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUploadUrlForData(projectId: string, dataId: string, fileType?: string | undefined, hash?: string | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Upload>>;
    /**
     * Endpoint for scheduling this data for deletion. This will also delete all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for deletion.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteData(projectId: string, dataId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Retrieve a list of data eligible for linking to the current project.
     * @param {string} projectId
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned. This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataEligibleForLinking(projectId: string, fullText?: string | undefined, id?: string[] | undefined, filename?: string[] | undefined, filenameMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, filePath?: string[] | undefined, filePathMatchMode?: "STARTS_WITH_CASE_INSENSITIVE" | "FULL_CASE_INSENSITIVE" | undefined, status?: ("PARTIAL" | "AVAILABLE" | "ARCHIVING" | "ARCHIVED" | "UNARCHIVING" | "DELETING")[] | undefined, formatId?: string[] | undefined, formatCode?: string[] | undefined, type?: "FILE" | "FOLDER" | undefined, parentFolderId?: string[] | undefined, parentFolderPath?: string | undefined, creationDateAfter?: string | undefined, creationDateBefore?: string | undefined, statusDateAfter?: string | undefined, statusDateBefore?: string | undefined, userTag?: string[] | undefined, userTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runInputTag?: string[] | undefined, runInputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runOutputTag?: string[] | undefined, runOutputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, connectorTag?: string[] | undefined, connectorTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, technicalTag?: string[] | undefined, technicalTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, notInRun?: boolean | undefined, notLinkedToSample?: boolean | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<DataPagedList>>;
    /**
     * Retrieve folder upload session details, including the current status of your upload session.
     * @summary Retrieve folder upload session details.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} folderUploadSessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolderUploadSession(projectId: string, dataId: string, folderUploadSessionId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<FolderUploadSession>>;
    /**
     *
     * @summary Retrieve a list of project data not linked to a sample.
     * @param {string} projectId
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNonSampleProjectData(projectId: string, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectDataPagedList>>;
    /**
     *
     * @summary Retrieve a project data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectData(projectId: string, dataId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectData>>;
    /**
     *
     * @summary Retrieve the children of this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDataChildren(projectId: string, dataId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<DataList>>;
    /**
     *
     * @summary Retrieve the list of project data.
     * @param {string} projectId
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned.  This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDataList(projectId: string, fullText?: string | undefined, id?: string[] | undefined, filename?: string[] | undefined, filenameMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, filePath?: string[] | undefined, filePathMatchMode?: "STARTS_WITH_CASE_INSENSITIVE" | "FULL_CASE_INSENSITIVE" | undefined, status?: ("PARTIAL" | "AVAILABLE" | "ARCHIVING" | "ARCHIVED" | "UNARCHIVING" | "DELETING")[] | undefined, formatId?: string[] | undefined, formatCode?: string[] | undefined, type?: "FILE" | "FOLDER" | undefined, parentFolderId?: string[] | undefined, parentFolderPath?: string | undefined, creationDateAfter?: string | undefined, creationDateBefore?: string | undefined, statusDateAfter?: string | undefined, statusDateBefore?: string | undefined, userTag?: string[] | undefined, userTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runInputTag?: string[] | undefined, runInputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runOutputTag?: string[] | undefined, runOutputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, connectorTag?: string[] | undefined, connectorTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, technicalTag?: string[] | undefined, technicalTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, notInRun?: boolean | undefined, notLinkedToSample?: boolean | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectDataPagedList>>;
    /**
     *
     * @summary Retrieve a list of projects to which this data is linked.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectsLinkedToData(projectId: string, dataId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectList>>;
    /**
     *
     * @summary Link data to this project.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkDataToProject(projectId: string, dataId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectData>>;
    /**
     * Endpoint for scheduling a download for the data specified by the ID to a connector. This download will only start when the connector is running. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule a download.
     * @param {string} projectId
     * @param {string} dataId
     * @param {ScheduleDownload} scheduleDownload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleDownloadForData(projectId: string, dataId: string, scheduleDownload: ScheduleDownload, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<DataTransfer>>;
    /**
     * Endpoint for scheduling this data for unarchival. This will also unarchive all files and directories below that data. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for unarchival.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unarchiveData(projectId: string, dataId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Unlink data from this project.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkDataFromProject(projectId: string, dataId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     * Fields which can be updated for files:  - data.willBeArchivedAt  - data.willBeDeletedAt  - data.format  - data.tags  Fields which can be updated for folders:  - data.tags
     * @summary Update this project data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {ProjectData} [projectData] The updated project data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectData(projectId: string, dataId: string, projectData?: ProjectData | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectData>>;
};
/**
 * ProjectDataApi - factory interface
 * @export
 */
export declare const ProjectDataApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     * Endpoint for scheduling this data for archival. This will also archive all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for archival.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archiveData(projectId: string, dataId: string, options?: any): AxiosPromise<void>;
    /**
     * Complete a trackable folder upload session. By completing the folder upload session, and specifying how many files you have uploaded, ICA can ensure that all uploaded files are accounted for.
     * @summary Complete a trackable folder upload session.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} folderUploadSessionId
     * @param {CompleteFolderUploadSession} [completeFolderUploadSession] The info required to complete the folder upload session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeFolderUploadSession(projectId: string, dataId: string, folderUploadSessionId: string, completeFolderUploadSession?: CompleteFolderUploadSession | undefined, options?: any): AxiosPromise<FolderUploadSession>;
    /**
     *
     * @summary Create data in this project.
     * @param {string} projectId
     * @param {CreateData} [createData] The data to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDataInProject(projectId: string, createData?: CreateData | undefined, options?: any): AxiosPromise<ProjectData>;
    /**
     * Can be used to download a file directly from the region where it is located, no connector is needed. Only small files can be downloaded, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve a download URL for this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDownloadUrlForData(projectId: string, dataId: string, options?: any): AxiosPromise<Download>;
    /**
     * This endpoint can be used to ensure that all uploaded files within the requested session are accounted for. This call has to be used together with the :complete endpoint once upload is done.
     * @summary Create a trackable folder upload session.
     * @param {string} projectId
     * @param {string} dataId
     * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolderUploadSession(projectId: string, dataId: string, createTemporaryCredentials?: CreateTemporaryCredentials | undefined, options?: any): AxiosPromise<FolderUploadSession>;
    /**
     * Can be used to view a file directly from the region where it is located, no connector is needed. Only small files can be viewed, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve an URL for this data to use for inline view in a browser.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInlineViewUrlForData(projectId: string, dataId: string, options?: any): AxiosPromise<InlineView>;
    /**
     * Can be used to upload or download a file directly from the region where it is located, no connector is needed.
     * @summary Retrieve temporary credentials for this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTemporaryCredentialsForData(projectId: string, dataId: string, createTemporaryCredentials?: CreateTemporaryCredentials | undefined, options?: any): AxiosPromise<TempCredentials>;
    /**
     * Can be used to upload a file directly from the region where it is located, no connector is needed. Only small files can be uploaded, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve an upload URL for this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} [fileType]
     * @param {string} [hash]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUploadUrlForData(projectId: string, dataId: string, fileType?: string | undefined, hash?: string | undefined, options?: any): AxiosPromise<Upload>;
    /**
     * Endpoint for scheduling this data for deletion. This will also delete all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for deletion.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteData(projectId: string, dataId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Retrieve a list of data eligible for linking to the current project.
     * @param {string} projectId
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned. This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataEligibleForLinking(projectId: string, fullText?: string | undefined, id?: string[] | undefined, filename?: string[] | undefined, filenameMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, filePath?: string[] | undefined, filePathMatchMode?: "STARTS_WITH_CASE_INSENSITIVE" | "FULL_CASE_INSENSITIVE" | undefined, status?: ("PARTIAL" | "AVAILABLE" | "ARCHIVING" | "ARCHIVED" | "UNARCHIVING" | "DELETING")[] | undefined, formatId?: string[] | undefined, formatCode?: string[] | undefined, type?: "FILE" | "FOLDER" | undefined, parentFolderId?: string[] | undefined, parentFolderPath?: string | undefined, creationDateAfter?: string | undefined, creationDateBefore?: string | undefined, statusDateAfter?: string | undefined, statusDateBefore?: string | undefined, userTag?: string[] | undefined, userTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runInputTag?: string[] | undefined, runInputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runOutputTag?: string[] | undefined, runOutputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, connectorTag?: string[] | undefined, connectorTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, technicalTag?: string[] | undefined, technicalTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, notInRun?: boolean | undefined, notLinkedToSample?: boolean | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: any): AxiosPromise<DataPagedList>;
    /**
     * Retrieve folder upload session details, including the current status of your upload session.
     * @summary Retrieve folder upload session details.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} folderUploadSessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolderUploadSession(projectId: string, dataId: string, folderUploadSessionId: string, options?: any): AxiosPromise<FolderUploadSession>;
    /**
     *
     * @summary Retrieve a list of project data not linked to a sample.
     * @param {string} projectId
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNonSampleProjectData(projectId: string, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, options?: any): AxiosPromise<ProjectDataPagedList>;
    /**
     *
     * @summary Retrieve a project data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectData(projectId: string, dataId: string, options?: any): AxiosPromise<ProjectData>;
    /**
     *
     * @summary Retrieve the children of this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDataChildren(projectId: string, dataId: string, options?: any): AxiosPromise<DataList>;
    /**
     *
     * @summary Retrieve the list of project data.
     * @param {string} projectId
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned.  This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDataList(projectId: string, fullText?: string | undefined, id?: string[] | undefined, filename?: string[] | undefined, filenameMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, filePath?: string[] | undefined, filePathMatchMode?: "STARTS_WITH_CASE_INSENSITIVE" | "FULL_CASE_INSENSITIVE" | undefined, status?: ("PARTIAL" | "AVAILABLE" | "ARCHIVING" | "ARCHIVED" | "UNARCHIVING" | "DELETING")[] | undefined, formatId?: string[] | undefined, formatCode?: string[] | undefined, type?: "FILE" | "FOLDER" | undefined, parentFolderId?: string[] | undefined, parentFolderPath?: string | undefined, creationDateAfter?: string | undefined, creationDateBefore?: string | undefined, statusDateAfter?: string | undefined, statusDateBefore?: string | undefined, userTag?: string[] | undefined, userTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runInputTag?: string[] | undefined, runInputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runOutputTag?: string[] | undefined, runOutputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, connectorTag?: string[] | undefined, connectorTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, technicalTag?: string[] | undefined, technicalTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, notInRun?: boolean | undefined, notLinkedToSample?: boolean | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: any): AxiosPromise<ProjectDataPagedList>;
    /**
     *
     * @summary Retrieve a list of projects to which this data is linked.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectsLinkedToData(projectId: string, dataId: string, options?: any): AxiosPromise<ProjectList>;
    /**
     *
     * @summary Link data to this project.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkDataToProject(projectId: string, dataId: string, options?: any): AxiosPromise<ProjectData>;
    /**
     * Endpoint for scheduling a download for the data specified by the ID to a connector. This download will only start when the connector is running. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule a download.
     * @param {string} projectId
     * @param {string} dataId
     * @param {ScheduleDownload} scheduleDownload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleDownloadForData(projectId: string, dataId: string, scheduleDownload: ScheduleDownload, options?: any): AxiosPromise<DataTransfer>;
    /**
     * Endpoint for scheduling this data for unarchival. This will also unarchive all files and directories below that data. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for unarchival.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unarchiveData(projectId: string, dataId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Unlink data from this project.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkDataFromProject(projectId: string, dataId: string, options?: any): AxiosPromise<void>;
    /**
     * Fields which can be updated for files:  - data.willBeArchivedAt  - data.willBeDeletedAt  - data.format  - data.tags  Fields which can be updated for folders:  - data.tags
     * @summary Update this project data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {ProjectData} [projectData] The updated project data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectData(projectId: string, dataId: string, projectData?: ProjectData | undefined, options?: any): AxiosPromise<ProjectData>;
};
/**
 * ProjectDataApi - object-oriented interface
 * @export
 * @class ProjectDataApi
 * @extends {BaseAPI}
 */
export declare class ProjectDataApi extends BaseAPI {
    /**
     * Endpoint for scheduling this data for archival. This will also archive all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for archival.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    archiveData(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Complete a trackable folder upload session. By completing the folder upload session, and specifying how many files you have uploaded, ICA can ensure that all uploaded files are accounted for.
     * @summary Complete a trackable folder upload session.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} folderUploadSessionId
     * @param {CompleteFolderUploadSession} [completeFolderUploadSession] The info required to complete the folder upload session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    completeFolderUploadSession(projectId: string, dataId: string, folderUploadSessionId: string, completeFolderUploadSession?: CompleteFolderUploadSession, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<FolderUploadSession, any>>;
    /**
     *
     * @summary Create data in this project.
     * @param {string} projectId
     * @param {CreateData} [createData] The data to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    createDataInProject(projectId: string, createData?: CreateData, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectData, any>>;
    /**
     * Can be used to download a file directly from the region where it is located, no connector is needed. Only small files can be downloaded, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve a download URL for this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    createDownloadUrlForData(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Download, any>>;
    /**
     * This endpoint can be used to ensure that all uploaded files within the requested session are accounted for. This call has to be used together with the :complete endpoint once upload is done.
     * @summary Create a trackable folder upload session.
     * @param {string} projectId
     * @param {string} dataId
     * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    createFolderUploadSession(projectId: string, dataId: string, createTemporaryCredentials?: CreateTemporaryCredentials, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<FolderUploadSession, any>>;
    /**
     * Can be used to view a file directly from the region where it is located, no connector is needed. Only small files can be viewed, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve an URL for this data to use for inline view in a browser.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    createInlineViewUrlForData(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<InlineView, any>>;
    /**
     * Can be used to upload or download a file directly from the region where it is located, no connector is needed.
     * @summary Retrieve temporary credentials for this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    createTemporaryCredentialsForData(projectId: string, dataId: string, createTemporaryCredentials?: CreateTemporaryCredentials, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<TempCredentials, any>>;
    /**
     * Can be used to upload a file directly from the region where it is located, no connector is needed. Only small files can be uploaded, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve an upload URL for this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} [fileType]
     * @param {string} [hash]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    createUploadUrlForData(projectId: string, dataId: string, fileType?: string, hash?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Upload, any>>;
    /**
     * Endpoint for scheduling this data for deletion. This will also delete all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for deletion.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    deleteData(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Retrieve a list of data eligible for linking to the current project.
     * @param {string} projectId
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned. This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    getDataEligibleForLinking(projectId: string, fullText?: string, id?: Array<string>, filename?: Array<string>, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: Array<string>, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>, formatId?: Array<string>, formatCode?: Array<string>, type?: 'FILE' | 'FOLDER', parentFolderId?: Array<string>, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: Array<string>, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: Array<string>, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: Array<string>, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: Array<string>, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: Array<string>, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: boolean, notLinkedToSample?: boolean, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<DataPagedList, any>>;
    /**
     * Retrieve folder upload session details, including the current status of your upload session.
     * @summary Retrieve folder upload session details.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} folderUploadSessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    getFolderUploadSession(projectId: string, dataId: string, folderUploadSessionId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<FolderUploadSession, any>>;
    /**
     *
     * @summary Retrieve a list of project data not linked to a sample.
     * @param {string} projectId
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    getNonSampleProjectData(projectId: string, pageOffset?: string, pageToken?: string, pageSize?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectDataPagedList, any>>;
    /**
     *
     * @summary Retrieve a project data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    getProjectData(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectData, any>>;
    /**
     *
     * @summary Retrieve the children of this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    getProjectDataChildren(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<DataList, any>>;
    /**
     *
     * @summary Retrieve the list of project data.
     * @param {string} projectId
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned.  This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    getProjectDataList(projectId: string, fullText?: string, id?: Array<string>, filename?: Array<string>, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: Array<string>, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>, formatId?: Array<string>, formatCode?: Array<string>, type?: 'FILE' | 'FOLDER', parentFolderId?: Array<string>, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: Array<string>, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: Array<string>, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: Array<string>, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: Array<string>, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: Array<string>, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: boolean, notLinkedToSample?: boolean, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectDataPagedList, any>>;
    /**
     *
     * @summary Retrieve a list of projects to which this data is linked.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    getProjectsLinkedToData(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectList, any>>;
    /**
     *
     * @summary Link data to this project.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    linkDataToProject(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectData, any>>;
    /**
     * Endpoint for scheduling a download for the data specified by the ID to a connector. This download will only start when the connector is running. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule a download.
     * @param {string} projectId
     * @param {string} dataId
     * @param {ScheduleDownload} scheduleDownload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    scheduleDownloadForData(projectId: string, dataId: string, scheduleDownload: ScheduleDownload, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<DataTransfer, any>>;
    /**
     * Endpoint for scheduling this data for unarchival. This will also unarchive all files and directories below that data. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for unarchival.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    unarchiveData(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Unlink data from this project.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    unlinkDataFromProject(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Fields which can be updated for files:  - data.willBeArchivedAt  - data.willBeDeletedAt  - data.format  - data.tags  Fields which can be updated for folders:  - data.tags
     * @summary Update this project data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {ProjectData} [projectData] The updated project data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    updateProjectData(projectId: string, dataId: string, projectData?: ProjectData, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectData, any>>;
}
/**
 * ProjectDataTransferApi - axios parameter creator
 * @export
 */
export declare const ProjectDataTransferApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Endpoint for aborting a data transfer.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Abort a data transfer.
     * @param {string} projectId
     * @param {string} dataTransferId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abortDataTransfer: (projectId: string, dataTransferId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a data transfer.
     * @param {string} projectId
     * @param {string} dataTransferId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTransfer: (projectId: string, dataTransferId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve a list of data transfers for the current app (session), excluding web browser transfers.
     * @summary Retrieve a list of data transfers.
     * @param {string} projectId
     * @param {string} [connector] The ID of the connector to filter on.
     * @param {string} [direction] The direction to filter on.
     * @param {string} [status] The status to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - direction - connector - protocol - dataTransferred - status - statusMessage - duration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTransfers: (projectId: string, connector?: string | undefined, direction?: string | undefined, status?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProjectDataTransferApi - functional programming interface
 * @export
 */
export declare const ProjectDataTransferApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Endpoint for aborting a data transfer.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Abort a data transfer.
     * @param {string} projectId
     * @param {string} dataTransferId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abortDataTransfer(projectId: string, dataTransferId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Retrieve a data transfer.
     * @param {string} projectId
     * @param {string} dataTransferId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTransfer(projectId: string, dataTransferId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<DataTransfer>>;
    /**
     * Retrieve a list of data transfers for the current app (session), excluding web browser transfers.
     * @summary Retrieve a list of data transfers.
     * @param {string} projectId
     * @param {string} [connector] The ID of the connector to filter on.
     * @param {string} [direction] The direction to filter on.
     * @param {string} [status] The status to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - direction - connector - protocol - dataTransferred - status - statusMessage - duration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTransfers(projectId: string, connector?: string | undefined, direction?: string | undefined, status?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<DataTransfers>>;
};
/**
 * ProjectDataTransferApi - factory interface
 * @export
 */
export declare const ProjectDataTransferApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     * Endpoint for aborting a data transfer.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Abort a data transfer.
     * @param {string} projectId
     * @param {string} dataTransferId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abortDataTransfer(projectId: string, dataTransferId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Retrieve a data transfer.
     * @param {string} projectId
     * @param {string} dataTransferId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTransfer(projectId: string, dataTransferId: string, options?: any): AxiosPromise<DataTransfer>;
    /**
     * Retrieve a list of data transfers for the current app (session), excluding web browser transfers.
     * @summary Retrieve a list of data transfers.
     * @param {string} projectId
     * @param {string} [connector] The ID of the connector to filter on.
     * @param {string} [direction] The direction to filter on.
     * @param {string} [status] The status to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - direction - connector - protocol - dataTransferred - status - statusMessage - duration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTransfers(projectId: string, connector?: string | undefined, direction?: string | undefined, status?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: any): AxiosPromise<DataTransfers>;
};
/**
 * ProjectDataTransferApi - object-oriented interface
 * @export
 * @class ProjectDataTransferApi
 * @extends {BaseAPI}
 */
export declare class ProjectDataTransferApi extends BaseAPI {
    /**
     * Endpoint for aborting a data transfer.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Abort a data transfer.
     * @param {string} projectId
     * @param {string} dataTransferId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataTransferApi
     */
    abortDataTransfer(projectId: string, dataTransferId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Retrieve a data transfer.
     * @param {string} projectId
     * @param {string} dataTransferId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataTransferApi
     */
    getDataTransfer(projectId: string, dataTransferId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<DataTransfer, any>>;
    /**
     * Retrieve a list of data transfers for the current app (session), excluding web browser transfers.
     * @summary Retrieve a list of data transfers.
     * @param {string} projectId
     * @param {string} [connector] The ID of the connector to filter on.
     * @param {string} [direction] The direction to filter on.
     * @param {string} [status] The status to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - direction - connector - protocol - dataTransferred - status - statusMessage - duration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataTransferApi
     */
    getDataTransfers(projectId: string, connector?: string, direction?: string, status?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<DataTransfers, any>>;
}
/**
 * ProjectNotificationSubscriptionsApi - axios parameter creator
 * @export
 */
export declare const ProjectNotificationSubscriptionsApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a notification subscription
     * @param {string} projectId The ID of the project
     * @param {CreateNotificationSubscription} [createNotificationSubscription] The new subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNotificationSubscription1: (projectId: string, createNotificationSubscription?: CreateNotificationSubscription | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotificationSubscription1: (projectId: string, subscriptionId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSubscription1: (projectId: string, subscriptionId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve notification subscriptions
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSubscriptions1: (projectId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel
     * @summary Update a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {NotificationSubscription} [notificationSubscription] The updated subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNotificationSubscription1: (projectId: string, subscriptionId: string, ifMatch?: string | undefined, notificationSubscription?: NotificationSubscription | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProjectNotificationSubscriptionsApi - functional programming interface
 * @export
 */
export declare const ProjectNotificationSubscriptionsApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a notification subscription
     * @param {string} projectId The ID of the project
     * @param {CreateNotificationSubscription} [createNotificationSubscription] The new subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNotificationSubscription1(projectId: string, createNotificationSubscription?: CreateNotificationSubscription | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<NotificationSubscription>>;
    /**
     *
     * @summary Delete a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotificationSubscription1(projectId: string, subscriptionId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Retrieve a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSubscription1(projectId: string, subscriptionId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<NotificationSubscription>>;
    /**
     *
     * @summary Retrieve notification subscriptions
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSubscriptions1(projectId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<NotificationSubscriptionList>>;
    /**
     * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel
     * @summary Update a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {NotificationSubscription} [notificationSubscription] The updated subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNotificationSubscription1(projectId: string, subscriptionId: string, ifMatch?: string | undefined, notificationSubscription?: NotificationSubscription | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<NotificationSubscription>>;
};
/**
 * ProjectNotificationSubscriptionsApi - factory interface
 * @export
 */
export declare const ProjectNotificationSubscriptionsApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Create a notification subscription
     * @param {string} projectId The ID of the project
     * @param {CreateNotificationSubscription} [createNotificationSubscription] The new subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNotificationSubscription1(projectId: string, createNotificationSubscription?: CreateNotificationSubscription | undefined, options?: any): AxiosPromise<NotificationSubscription>;
    /**
     *
     * @summary Delete a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotificationSubscription1(projectId: string, subscriptionId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Retrieve a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSubscription1(projectId: string, subscriptionId: string, options?: any): AxiosPromise<NotificationSubscription>;
    /**
     *
     * @summary Retrieve notification subscriptions
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSubscriptions1(projectId: string, options?: any): AxiosPromise<NotificationSubscriptionList>;
    /**
     * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel
     * @summary Update a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {NotificationSubscription} [notificationSubscription] The updated subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNotificationSubscription1(projectId: string, subscriptionId: string, ifMatch?: string | undefined, notificationSubscription?: NotificationSubscription | undefined, options?: any): AxiosPromise<NotificationSubscription>;
};
/**
 * ProjectNotificationSubscriptionsApi - object-oriented interface
 * @export
 * @class ProjectNotificationSubscriptionsApi
 * @extends {BaseAPI}
 */
export declare class ProjectNotificationSubscriptionsApi extends BaseAPI {
    /**
     *
     * @summary Create a notification subscription
     * @param {string} projectId The ID of the project
     * @param {CreateNotificationSubscription} [createNotificationSubscription] The new subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectNotificationSubscriptionsApi
     */
    createNotificationSubscription1(projectId: string, createNotificationSubscription?: CreateNotificationSubscription, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<NotificationSubscription, any>>;
    /**
     *
     * @summary Delete a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectNotificationSubscriptionsApi
     */
    deleteNotificationSubscription1(projectId: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Retrieve a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectNotificationSubscriptionsApi
     */
    getNotificationSubscription1(projectId: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<NotificationSubscription, any>>;
    /**
     *
     * @summary Retrieve notification subscriptions
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectNotificationSubscriptionsApi
     */
    getNotificationSubscriptions1(projectId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<NotificationSubscriptionList, any>>;
    /**
     * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel
     * @summary Update a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {NotificationSubscription} [notificationSubscription] The updated subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectNotificationSubscriptionsApi
     */
    updateNotificationSubscription1(projectId: string, subscriptionId: string, ifMatch?: string, notificationSubscription?: NotificationSubscription, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<NotificationSubscription, any>>;
}
/**
 * ProjectPermissionApi - axios parameter creator
 * @export
 */
export declare const ProjectPermissionApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a project permission.
     * @param {string} projectId
     * @param {CreateProjectPermission} [createProjectPermission]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProjectPermission: (projectId: string, createProjectPermission?: CreateProjectPermission | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a project permission.
     * @param {string} projectId
     * @param {string} permissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPermission: (projectId: string, permissionId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of project permissions.
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPermissions: (projectId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fields which can be updated: - uploadAllowed - downloadAllowed - roleProject - roleFlow - roleBase - roleBench
     * @summary Update a project permission.
     * @param {string} projectId
     * @param {string} permissionId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {ProjectPermission} [projectPermission]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectPermission: (projectId: string, permissionId: string, ifMatch?: string | undefined, projectPermission?: ProjectPermission | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProjectPermissionApi - functional programming interface
 * @export
 */
export declare const ProjectPermissionApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a project permission.
     * @param {string} projectId
     * @param {CreateProjectPermission} [createProjectPermission]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProjectPermission(projectId: string, createProjectPermission?: CreateProjectPermission | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectPermission>>;
    /**
     *
     * @summary Retrieve a project permission.
     * @param {string} projectId
     * @param {string} permissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPermission(projectId: string, permissionId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectPermission>>;
    /**
     *
     * @summary Retrieve a list of project permissions.
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPermissions(projectId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectPermissionList>>;
    /**
     * Fields which can be updated: - uploadAllowed - downloadAllowed - roleProject - roleFlow - roleBase - roleBench
     * @summary Update a project permission.
     * @param {string} projectId
     * @param {string} permissionId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {ProjectPermission} [projectPermission]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectPermission(projectId: string, permissionId: string, ifMatch?: string | undefined, projectPermission?: ProjectPermission | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectPermission>>;
};
/**
 * ProjectPermissionApi - factory interface
 * @export
 */
export declare const ProjectPermissionApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Create a project permission.
     * @param {string} projectId
     * @param {CreateProjectPermission} [createProjectPermission]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProjectPermission(projectId: string, createProjectPermission?: CreateProjectPermission | undefined, options?: any): AxiosPromise<ProjectPermission>;
    /**
     *
     * @summary Retrieve a project permission.
     * @param {string} projectId
     * @param {string} permissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPermission(projectId: string, permissionId: string, options?: any): AxiosPromise<ProjectPermission>;
    /**
     *
     * @summary Retrieve a list of project permissions.
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPermissions(projectId: string, options?: any): AxiosPromise<ProjectPermissionList>;
    /**
     * Fields which can be updated: - uploadAllowed - downloadAllowed - roleProject - roleFlow - roleBase - roleBench
     * @summary Update a project permission.
     * @param {string} projectId
     * @param {string} permissionId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {ProjectPermission} [projectPermission]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectPermission(projectId: string, permissionId: string, ifMatch?: string | undefined, projectPermission?: ProjectPermission | undefined, options?: any): AxiosPromise<ProjectPermission>;
};
/**
 * ProjectPermissionApi - object-oriented interface
 * @export
 * @class ProjectPermissionApi
 * @extends {BaseAPI}
 */
export declare class ProjectPermissionApi extends BaseAPI {
    /**
     *
     * @summary Create a project permission.
     * @param {string} projectId
     * @param {CreateProjectPermission} [createProjectPermission]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPermissionApi
     */
    createProjectPermission(projectId: string, createProjectPermission?: CreateProjectPermission, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectPermission, any>>;
    /**
     *
     * @summary Retrieve a project permission.
     * @param {string} projectId
     * @param {string} permissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPermissionApi
     */
    getProjectPermission(projectId: string, permissionId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectPermission, any>>;
    /**
     *
     * @summary Retrieve a list of project permissions.
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPermissionApi
     */
    getProjectPermissions(projectId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectPermissionList, any>>;
    /**
     * Fields which can be updated: - uploadAllowed - downloadAllowed - roleProject - roleFlow - roleBase - roleBench
     * @summary Update a project permission.
     * @param {string} projectId
     * @param {string} permissionId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {ProjectPermission} [projectPermission]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPermissionApi
     */
    updateProjectPermission(projectId: string, permissionId: string, ifMatch?: string, projectPermission?: ProjectPermission, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectPermission, any>>;
}
/**
 * ProjectPipelineApi - axios parameter creator
 * @export
 */
export declare const ProjectPipelineApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a CWL pipeline within a project.
     * @param {string} projectId The ID of the project
     * @param {string} code The code of the CWL pipeline
     * @param {string} description The description of the CWL pipeline
     * @param {any} workflowCwlFile The CWL workflow file.
     * @param {any} parametersXmlFile
     * @param {string} analysisStorageId The id of the storage to use for the pipeline.
     * @param {Array<any>} [toolCwlFiles]
     * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
     * @param {Links} [links]
     * @param {string} [versionComment]
     * @param {Array<string>} [categories]
     * @param {string} [htmlDocumentation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCwlPipeline: (projectId: string, code: string, description: string, workflowCwlFile: any, parametersXmlFile: any, analysisStorageId: string, toolCwlFiles?: any[] | undefined, metadataModelFile?: any, links?: Links | undefined, versionComment?: string | undefined, categories?: string[] | undefined, htmlDocumentation?: string | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Create a Nextflow pipeline within a project.
     * @param {string} projectId The ID of the project
     * @param {string} code The code of the pipeline
     * @param {string} description The description of the pipeline
     * @param {any} mainNextflowFile The main Nextflow file.
     * @param {any} parametersXmlFile
     * @param {string} analysisStorageId The id of the storage to use for the pipeline.
     * @param {Array<any>} [otherNextflowFiles]
     * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
     * @param {Links} [links]
     * @param {string} [versionComment]
     * @param {Array<string>} [categories]
     * @param {string} [htmlDocumentation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNextflowPipeline: (projectId: string, code: string, description: string, mainNextflowFile: any, parametersXmlFile: any, analysisStorageId: string, otherNextflowFiles?: any[] | undefined, metadataModelFile?: any, links?: Links | undefined, versionComment?: string | undefined, categories?: string[] | undefined, htmlDocumentation?: string | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the project pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPipeline: (projectId: string, pipelineId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve input parameters for a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve input parameters for a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the project pipeline to retrieve input parameters for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPipelineInputParameters: (projectId: string, pipelineId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve the reference sets of a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPipelineReferenceSets: (projectId: string, pipelineId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve a list of project pipelines. This includes pipelines from linked bundles.
     * @summary Retrieve a list of project pipelines.
     * @param {string} projectId The ID of the project to retrieve pipelines for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPipelines: (projectId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Link a pipeline to a project.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkPipelineToProject: (projectId: string, pipelineId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Release a pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    releasePipeline: (projectId: string, pipelineId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Unlink a pipeline from a project.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkPipelineFromProject: (projectId: string, pipelineId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProjectPipelineApi - functional programming interface
 * @export
 */
export declare const ProjectPipelineApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a CWL pipeline within a project.
     * @param {string} projectId The ID of the project
     * @param {string} code The code of the CWL pipeline
     * @param {string} description The description of the CWL pipeline
     * @param {any} workflowCwlFile The CWL workflow file.
     * @param {any} parametersXmlFile
     * @param {string} analysisStorageId The id of the storage to use for the pipeline.
     * @param {Array<any>} [toolCwlFiles]
     * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
     * @param {Links} [links]
     * @param {string} [versionComment]
     * @param {Array<string>} [categories]
     * @param {string} [htmlDocumentation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCwlPipeline(projectId: string, code: string, description: string, workflowCwlFile: any, parametersXmlFile: any, analysisStorageId: string, toolCwlFiles?: any[] | undefined, metadataModelFile?: any, links?: Links | undefined, versionComment?: string | undefined, categories?: string[] | undefined, htmlDocumentation?: string | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectPipeline>>;
    /**
     *
     * @summary Create a Nextflow pipeline within a project.
     * @param {string} projectId The ID of the project
     * @param {string} code The code of the pipeline
     * @param {string} description The description of the pipeline
     * @param {any} mainNextflowFile The main Nextflow file.
     * @param {any} parametersXmlFile
     * @param {string} analysisStorageId The id of the storage to use for the pipeline.
     * @param {Array<any>} [otherNextflowFiles]
     * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
     * @param {Links} [links]
     * @param {string} [versionComment]
     * @param {Array<string>} [categories]
     * @param {string} [htmlDocumentation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNextflowPipeline(projectId: string, code: string, description: string, mainNextflowFile: any, parametersXmlFile: any, analysisStorageId: string, otherNextflowFiles?: any[] | undefined, metadataModelFile?: any, links?: Links | undefined, versionComment?: string | undefined, categories?: string[] | undefined, htmlDocumentation?: string | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectPipeline>>;
    /**
     * Retrieve a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the project pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPipeline(projectId: string, pipelineId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectPipeline>>;
    /**
     * Retrieve input parameters for a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve input parameters for a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the project pipeline to retrieve input parameters for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPipelineInputParameters(projectId: string, pipelineId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<InputParameterList>>;
    /**
     * Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve the reference sets of a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPipelineReferenceSets(projectId: string, pipelineId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ReferenceSetList>>;
    /**
     * Retrieve a list of project pipelines. This includes pipelines from linked bundles.
     * @summary Retrieve a list of project pipelines.
     * @param {string} projectId The ID of the project to retrieve pipelines for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPipelines(projectId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectPipelineList>>;
    /**
     *
     * @summary Link a pipeline to a project.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkPipelineToProject(projectId: string, pipelineId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Release a pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    releasePipeline(projectId: string, pipelineId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Unlink a pipeline from a project.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkPipelineFromProject(projectId: string, pipelineId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
};
/**
 * ProjectPipelineApi - factory interface
 * @export
 */
export declare const ProjectPipelineApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Create a CWL pipeline within a project.
     * @param {string} projectId The ID of the project
     * @param {string} code The code of the CWL pipeline
     * @param {string} description The description of the CWL pipeline
     * @param {any} workflowCwlFile The CWL workflow file.
     * @param {any} parametersXmlFile
     * @param {string} analysisStorageId The id of the storage to use for the pipeline.
     * @param {Array<any>} [toolCwlFiles]
     * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
     * @param {Links} [links]
     * @param {string} [versionComment]
     * @param {Array<string>} [categories]
     * @param {string} [htmlDocumentation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCwlPipeline(projectId: string, code: string, description: string, workflowCwlFile: any, parametersXmlFile: any, analysisStorageId: string, toolCwlFiles?: any[] | undefined, metadataModelFile?: any, links?: Links | undefined, versionComment?: string | undefined, categories?: string[] | undefined, htmlDocumentation?: string | undefined, options?: any): AxiosPromise<ProjectPipeline>;
    /**
     *
     * @summary Create a Nextflow pipeline within a project.
     * @param {string} projectId The ID of the project
     * @param {string} code The code of the pipeline
     * @param {string} description The description of the pipeline
     * @param {any} mainNextflowFile The main Nextflow file.
     * @param {any} parametersXmlFile
     * @param {string} analysisStorageId The id of the storage to use for the pipeline.
     * @param {Array<any>} [otherNextflowFiles]
     * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
     * @param {Links} [links]
     * @param {string} [versionComment]
     * @param {Array<string>} [categories]
     * @param {string} [htmlDocumentation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNextflowPipeline(projectId: string, code: string, description: string, mainNextflowFile: any, parametersXmlFile: any, analysisStorageId: string, otherNextflowFiles?: any[] | undefined, metadataModelFile?: any, links?: Links | undefined, versionComment?: string | undefined, categories?: string[] | undefined, htmlDocumentation?: string | undefined, options?: any): AxiosPromise<ProjectPipeline>;
    /**
     * Retrieve a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the project pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPipeline(projectId: string, pipelineId: string, options?: any): AxiosPromise<ProjectPipeline>;
    /**
     * Retrieve input parameters for a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve input parameters for a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the project pipeline to retrieve input parameters for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPipelineInputParameters(projectId: string, pipelineId: string, options?: any): AxiosPromise<InputParameterList>;
    /**
     * Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve the reference sets of a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPipelineReferenceSets(projectId: string, pipelineId: string, options?: any): AxiosPromise<ReferenceSetList>;
    /**
     * Retrieve a list of project pipelines. This includes pipelines from linked bundles.
     * @summary Retrieve a list of project pipelines.
     * @param {string} projectId The ID of the project to retrieve pipelines for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectPipelines(projectId: string, options?: any): AxiosPromise<ProjectPipelineList>;
    /**
     *
     * @summary Link a pipeline to a project.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkPipelineToProject(projectId: string, pipelineId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Release a pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    releasePipeline(projectId: string, pipelineId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Unlink a pipeline from a project.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkPipelineFromProject(projectId: string, pipelineId: string, options?: any): AxiosPromise<void>;
};
/**
 * ProjectPipelineApi - object-oriented interface
 * @export
 * @class ProjectPipelineApi
 * @extends {BaseAPI}
 */
export declare class ProjectPipelineApi extends BaseAPI {
    /**
     *
     * @summary Create a CWL pipeline within a project.
     * @param {string} projectId The ID of the project
     * @param {string} code The code of the CWL pipeline
     * @param {string} description The description of the CWL pipeline
     * @param {any} workflowCwlFile The CWL workflow file.
     * @param {any} parametersXmlFile
     * @param {string} analysisStorageId The id of the storage to use for the pipeline.
     * @param {Array<any>} [toolCwlFiles]
     * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
     * @param {Links} [links]
     * @param {string} [versionComment]
     * @param {Array<string>} [categories]
     * @param {string} [htmlDocumentation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    createCwlPipeline(projectId: string, code: string, description: string, workflowCwlFile: any, parametersXmlFile: any, analysisStorageId: string, toolCwlFiles?: Array<any>, metadataModelFile?: any, links?: Links, versionComment?: string, categories?: Array<string>, htmlDocumentation?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectPipeline, any>>;
    /**
     *
     * @summary Create a Nextflow pipeline within a project.
     * @param {string} projectId The ID of the project
     * @param {string} code The code of the pipeline
     * @param {string} description The description of the pipeline
     * @param {any} mainNextflowFile The main Nextflow file.
     * @param {any} parametersXmlFile
     * @param {string} analysisStorageId The id of the storage to use for the pipeline.
     * @param {Array<any>} [otherNextflowFiles]
     * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
     * @param {Links} [links]
     * @param {string} [versionComment]
     * @param {Array<string>} [categories]
     * @param {string} [htmlDocumentation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    createNextflowPipeline(projectId: string, code: string, description: string, mainNextflowFile: any, parametersXmlFile: any, analysisStorageId: string, otherNextflowFiles?: Array<any>, metadataModelFile?: any, links?: Links, versionComment?: string, categories?: Array<string>, htmlDocumentation?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectPipeline, any>>;
    /**
     * Retrieve a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the project pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    getProjectPipeline(projectId: string, pipelineId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectPipeline, any>>;
    /**
     * Retrieve input parameters for a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve input parameters for a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the project pipeline to retrieve input parameters for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    getProjectPipelineInputParameters(projectId: string, pipelineId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<InputParameterList, any>>;
    /**
     * Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve the reference sets of a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    getProjectPipelineReferenceSets(projectId: string, pipelineId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ReferenceSetList, any>>;
    /**
     * Retrieve a list of project pipelines. This includes pipelines from linked bundles.
     * @summary Retrieve a list of project pipelines.
     * @param {string} projectId The ID of the project to retrieve pipelines for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    getProjectPipelines(projectId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectPipelineList, any>>;
    /**
     *
     * @summary Link a pipeline to a project.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    linkPipelineToProject(projectId: string, pipelineId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Release a pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    releasePipeline(projectId: string, pipelineId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Unlink a pipeline from a project.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    unlinkPipelineFromProject(projectId: string, pipelineId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * ProjectSampleApi - axios parameter creator
 * @export
 */
export declare const ProjectSampleApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Add a metadata model to a sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} metadataModelId The ID of the metadata model
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    addMetadataModelToSample: (projectId: string, sampleId: string, metadataModelId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Completes the sample after data has been linked to it. The sample status will be set to \'Available\' and a sample completed event will be triggered as well.
     * @summary Completes the sample after data has been linked to it.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeProjectSample: (projectId: string, sampleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Create a new sample in this project
     * @param {string} projectId
     * @param {CreateSample} [createSample]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSampleInProject: (projectId: string, createSample?: CreateSample | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint deleting a sample together with all of its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample together with all of its data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deepDeleteSample: (projectId: string, sampleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint for deleting a sample while unlinking its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample and unlink its data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAndUnlinkSample: (projectId: string, sampleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint for deleting a sample as well as its input data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample as well as its input data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSampleWithInput: (projectId: string, sampleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a project sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectSample: (projectId: string, sampleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint for retrieving project samples. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Retrieve project samples.
     * @param {string} projectId
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {FindProjectSamples} [findProjectSamples]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectSamples: (projectId: string, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, findProjectSamples?: FindProjectSamples | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of projects for this sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectsForSample: (projectId: string, sampleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve the list of sample data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample to retrieve data for
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleDataList: (projectId: string, sampleId: string, fullText?: string | undefined, id?: string[] | undefined, filename?: string[] | undefined, filenameMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, filePath?: string[] | undefined, filePathMatchMode?: "STARTS_WITH_CASE_INSENSITIVE" | "FULL_CASE_INSENSITIVE" | undefined, status?: ("PARTIAL" | "AVAILABLE" | "ARCHIVING" | "ARCHIVED" | "UNARCHIVING" | "DELETING")[] | undefined, formatId?: string[] | undefined, formatCode?: string[] | undefined, type?: "FILE" | "FOLDER" | undefined, parentFolderId?: string[] | undefined, parentFolderPath?: string | undefined, creationDateAfter?: string | undefined, creationDateBefore?: string | undefined, statusDateAfter?: string | undefined, statusDateBefore?: string | undefined, userTag?: string[] | undefined, userTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runInputTag?: string[] | undefined, runInputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runOutputTag?: string[] | undefined, runOutputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, connectorTag?: string[] | undefined, connectorTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, technicalTag?: string[] | undefined, technicalTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, notInRun?: boolean | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve sample history.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleHistory: (projectId: string, sampleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
     * @summary Retrieve a metadata field.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} fieldId The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleMetadataField: (projectId: string, sampleId: string, fieldId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
     * @summary Retrieves the number of occurrences of a given field.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} fieldId The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleMetadataFieldCount: (projectId: string, sampleId: string, fieldId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Link data to a sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} dataId The ID of the data to link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkDataToSample: (projectId: string, sampleId: string, dataId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Link a sample to a project.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkSampleToProject: (projectId: string, sampleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint for marking a sample as deleted.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Mark a sample deleted.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markSampleDeleted: (projectId: string, sampleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Unlink data from a sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} dataId The ID of the data to unlink
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkDataFromSample: (projectId: string, sampleId: string, dataId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Unlink a sample from a project.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkSampleFromProject: (projectId: string, sampleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fields which can be updated: - sample.name - sample.description - sample.status - sample.tags
     * @summary Update a project sample.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {ProjectSample} [projectSample]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectSample: (projectId: string, sampleId: string, ifMatch?: string | undefined, projectSample?: ProjectSample | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint for updating metadata fields.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Update metadata fields.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {UpdateMetadata} [updateMetadata]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSampleMetadataFields: (projectId: string, sampleId: string, updateMetadata?: UpdateMetadata | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProjectSampleApi - functional programming interface
 * @export
 */
export declare const ProjectSampleApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Add a metadata model to a sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} metadataModelId The ID of the metadata model
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    addMetadataModelToSample(projectId: string, sampleId: string, metadataModelId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     * Completes the sample after data has been linked to it. The sample status will be set to \'Available\' and a sample completed event will be triggered as well.
     * @summary Completes the sample after data has been linked to it.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeProjectSample(projectId: string, sampleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Create a new sample in this project
     * @param {string} projectId
     * @param {CreateSample} [createSample]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSampleInProject(projectId: string, createSample?: CreateSample | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectSample>>;
    /**
     * Endpoint deleting a sample together with all of its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample together with all of its data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deepDeleteSample(projectId: string, sampleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     * Endpoint for deleting a sample while unlinking its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample and unlink its data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAndUnlinkSample(projectId: string, sampleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     * Endpoint for deleting a sample as well as its input data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample as well as its input data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSampleWithInput(projectId: string, sampleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Retrieve a project sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectSample(projectId: string, sampleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectSample>>;
    /**
     * Endpoint for retrieving project samples. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Retrieve project samples.
     * @param {string} projectId
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {FindProjectSamples} [findProjectSamples]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectSamples(projectId: string, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, findProjectSamples?: FindProjectSamples | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectSamplePagedList>>;
    /**
     *
     * @summary Retrieve a list of projects for this sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectsForSample(projectId: string, sampleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectList>>;
    /**
     *
     * @summary Retrieve the list of sample data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample to retrieve data for
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleDataList(projectId: string, sampleId: string, fullText?: string | undefined, id?: string[] | undefined, filename?: string[] | undefined, filenameMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, filePath?: string[] | undefined, filePathMatchMode?: "STARTS_WITH_CASE_INSENSITIVE" | "FULL_CASE_INSENSITIVE" | undefined, status?: ("PARTIAL" | "AVAILABLE" | "ARCHIVING" | "ARCHIVED" | "UNARCHIVING" | "DELETING")[] | undefined, formatId?: string[] | undefined, formatCode?: string[] | undefined, type?: "FILE" | "FOLDER" | undefined, parentFolderId?: string[] | undefined, parentFolderPath?: string | undefined, creationDateAfter?: string | undefined, creationDateBefore?: string | undefined, statusDateAfter?: string | undefined, statusDateBefore?: string | undefined, userTag?: string[] | undefined, userTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runInputTag?: string[] | undefined, runInputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runOutputTag?: string[] | undefined, runOutputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, connectorTag?: string[] | undefined, connectorTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, technicalTag?: string[] | undefined, technicalTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, notInRun?: boolean | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<DataList>>;
    /**
     *
     * @summary Retrieve sample history.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleHistory(projectId: string, sampleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<SampleHistoryList>>;
    /**
     * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
     * @summary Retrieve a metadata field.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} fieldId The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleMetadataField(projectId: string, sampleId: string, fieldId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Field>>;
    /**
     * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
     * @summary Retrieves the number of occurrences of a given field.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} fieldId The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleMetadataFieldCount(projectId: string, sampleId: string, fieldId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Field>>;
    /**
     *
     * @summary Link data to a sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} dataId The ID of the data to link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkDataToSample(projectId: string, sampleId: string, dataId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Link a sample to a project.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkSampleToProject(projectId: string, sampleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectSample>>;
    /**
     * Endpoint for marking a sample as deleted.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Mark a sample deleted.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markSampleDeleted(projectId: string, sampleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Unlink data from a sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} dataId The ID of the data to unlink
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkDataFromSample(projectId: string, sampleId: string, dataId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Unlink a sample from a project.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkSampleFromProject(projectId: string, sampleId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     * Fields which can be updated: - sample.name - sample.description - sample.status - sample.tags
     * @summary Update a project sample.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {ProjectSample} [projectSample]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectSample(projectId: string, sampleId: string, ifMatch?: string | undefined, projectSample?: ProjectSample | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<ProjectSample>>;
    /**
     * Endpoint for updating metadata fields.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Update metadata fields.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {UpdateMetadata} [updateMetadata]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSampleMetadataFields(projectId: string, sampleId: string, updateMetadata?: UpdateMetadata | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Sample>>;
};
/**
 * ProjectSampleApi - factory interface
 * @export
 */
export declare const ProjectSampleApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Add a metadata model to a sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} metadataModelId The ID of the metadata model
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    addMetadataModelToSample(projectId: string, sampleId: string, metadataModelId: string, options?: any): AxiosPromise<void>;
    /**
     * Completes the sample after data has been linked to it. The sample status will be set to \'Available\' and a sample completed event will be triggered as well.
     * @summary Completes the sample after data has been linked to it.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeProjectSample(projectId: string, sampleId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Create a new sample in this project
     * @param {string} projectId
     * @param {CreateSample} [createSample]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSampleInProject(projectId: string, createSample?: CreateSample | undefined, options?: any): AxiosPromise<ProjectSample>;
    /**
     * Endpoint deleting a sample together with all of its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample together with all of its data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deepDeleteSample(projectId: string, sampleId: string, options?: any): AxiosPromise<void>;
    /**
     * Endpoint for deleting a sample while unlinking its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample and unlink its data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAndUnlinkSample(projectId: string, sampleId: string, options?: any): AxiosPromise<void>;
    /**
     * Endpoint for deleting a sample as well as its input data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample as well as its input data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSampleWithInput(projectId: string, sampleId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Retrieve a project sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectSample(projectId: string, sampleId: string, options?: any): AxiosPromise<ProjectSample>;
    /**
     * Endpoint for retrieving project samples. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Retrieve project samples.
     * @param {string} projectId
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {FindProjectSamples} [findProjectSamples]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectSamples(projectId: string, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, findProjectSamples?: FindProjectSamples | undefined, options?: any): AxiosPromise<ProjectSamplePagedList>;
    /**
     *
     * @summary Retrieve a list of projects for this sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectsForSample(projectId: string, sampleId: string, options?: any): AxiosPromise<ProjectList>;
    /**
     *
     * @summary Retrieve the list of sample data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample to retrieve data for
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleDataList(projectId: string, sampleId: string, fullText?: string | undefined, id?: string[] | undefined, filename?: string[] | undefined, filenameMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, filePath?: string[] | undefined, filePathMatchMode?: "STARTS_WITH_CASE_INSENSITIVE" | "FULL_CASE_INSENSITIVE" | undefined, status?: ("PARTIAL" | "AVAILABLE" | "ARCHIVING" | "ARCHIVED" | "UNARCHIVING" | "DELETING")[] | undefined, formatId?: string[] | undefined, formatCode?: string[] | undefined, type?: "FILE" | "FOLDER" | undefined, parentFolderId?: string[] | undefined, parentFolderPath?: string | undefined, creationDateAfter?: string | undefined, creationDateBefore?: string | undefined, statusDateAfter?: string | undefined, statusDateBefore?: string | undefined, userTag?: string[] | undefined, userTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runInputTag?: string[] | undefined, runInputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, runOutputTag?: string[] | undefined, runOutputTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, connectorTag?: string[] | undefined, connectorTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, technicalTag?: string[] | undefined, technicalTagMatchMode?: "EXACT" | "EXCLUDE" | "FUZZY" | undefined, notInRun?: boolean | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: any): AxiosPromise<DataList>;
    /**
     *
     * @summary Retrieve sample history.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleHistory(projectId: string, sampleId: string, options?: any): AxiosPromise<SampleHistoryList>;
    /**
     * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
     * @summary Retrieve a metadata field.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} fieldId The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleMetadataField(projectId: string, sampleId: string, fieldId: string, options?: any): AxiosPromise<Field>;
    /**
     * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
     * @summary Retrieves the number of occurrences of a given field.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} fieldId The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleMetadataFieldCount(projectId: string, sampleId: string, fieldId: string, options?: any): AxiosPromise<Field>;
    /**
     *
     * @summary Link data to a sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} dataId The ID of the data to link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkDataToSample(projectId: string, sampleId: string, dataId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Link a sample to a project.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkSampleToProject(projectId: string, sampleId: string, options?: any): AxiosPromise<ProjectSample>;
    /**
     * Endpoint for marking a sample as deleted.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Mark a sample deleted.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markSampleDeleted(projectId: string, sampleId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Unlink data from a sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} dataId The ID of the data to unlink
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkDataFromSample(projectId: string, sampleId: string, dataId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Unlink a sample from a project.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkSampleFromProject(projectId: string, sampleId: string, options?: any): AxiosPromise<void>;
    /**
     * Fields which can be updated: - sample.name - sample.description - sample.status - sample.tags
     * @summary Update a project sample.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {ProjectSample} [projectSample]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectSample(projectId: string, sampleId: string, ifMatch?: string | undefined, projectSample?: ProjectSample | undefined, options?: any): AxiosPromise<ProjectSample>;
    /**
     * Endpoint for updating metadata fields.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Update metadata fields.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {UpdateMetadata} [updateMetadata]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSampleMetadataFields(projectId: string, sampleId: string, updateMetadata?: UpdateMetadata | undefined, options?: any): AxiosPromise<Sample>;
};
/**
 * ProjectSampleApi - object-oriented interface
 * @export
 * @class ProjectSampleApi
 * @extends {BaseAPI}
 */
export declare class ProjectSampleApi extends BaseAPI {
    /**
     *
     * @summary Add a metadata model to a sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} metadataModelId The ID of the metadata model
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    addMetadataModelToSample(projectId: string, sampleId: string, metadataModelId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Completes the sample after data has been linked to it. The sample status will be set to \'Available\' and a sample completed event will be triggered as well.
     * @summary Completes the sample after data has been linked to it.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    completeProjectSample(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Create a new sample in this project
     * @param {string} projectId
     * @param {CreateSample} [createSample]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    createSampleInProject(projectId: string, createSample?: CreateSample, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectSample, any>>;
    /**
     * Endpoint deleting a sample together with all of its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample together with all of its data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    deepDeleteSample(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Endpoint for deleting a sample while unlinking its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample and unlink its data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    deleteAndUnlinkSample(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Endpoint for deleting a sample as well as its input data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample as well as its input data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    deleteSampleWithInput(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Retrieve a project sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    getProjectSample(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectSample, any>>;
    /**
     * Endpoint for retrieving project samples. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Retrieve project samples.
     * @param {string} projectId
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {FindProjectSamples} [findProjectSamples]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    getProjectSamples(projectId: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, findProjectSamples?: FindProjectSamples, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectSamplePagedList, any>>;
    /**
     *
     * @summary Retrieve a list of projects for this sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    getProjectsForSample(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectList, any>>;
    /**
     *
     * @summary Retrieve the list of sample data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample to retrieve data for
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    getSampleDataList(projectId: string, sampleId: string, fullText?: string, id?: Array<string>, filename?: Array<string>, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: Array<string>, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>, formatId?: Array<string>, formatCode?: Array<string>, type?: 'FILE' | 'FOLDER', parentFolderId?: Array<string>, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: Array<string>, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: Array<string>, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: Array<string>, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: Array<string>, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: Array<string>, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: boolean, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<DataList, any>>;
    /**
     *
     * @summary Retrieve sample history.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    getSampleHistory(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<SampleHistoryList, any>>;
    /**
     * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
     * @summary Retrieve a metadata field.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} fieldId The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    getSampleMetadataField(projectId: string, sampleId: string, fieldId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Field, any>>;
    /**
     * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
     * @summary Retrieves the number of occurrences of a given field.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} fieldId The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    getSampleMetadataFieldCount(projectId: string, sampleId: string, fieldId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Field, any>>;
    /**
     *
     * @summary Link data to a sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} dataId The ID of the data to link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    linkDataToSample(projectId: string, sampleId: string, dataId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Link a sample to a project.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    linkSampleToProject(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectSample, any>>;
    /**
     * Endpoint for marking a sample as deleted.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Mark a sample deleted.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    markSampleDeleted(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Unlink data from a sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} dataId The ID of the data to unlink
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    unlinkDataFromSample(projectId: string, sampleId: string, dataId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Unlink a sample from a project.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    unlinkSampleFromProject(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Fields which can be updated: - sample.name - sample.description - sample.status - sample.tags
     * @summary Update a project sample.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {ProjectSample} [projectSample]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    updateProjectSample(projectId: string, sampleId: string, ifMatch?: string, projectSample?: ProjectSample, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProjectSample, any>>;
    /**
     * Endpoint for updating metadata fields.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Update metadata fields.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {UpdateMetadata} [updateMetadata]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    updateSampleMetadataFields(projectId: string, sampleId: string, updateMetadata?: UpdateMetadata, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Sample, any>>;
}
/**
 * RegionApi - axios parameter creator
 * @export
 */
export declare const RegionApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a region. Only the regions the user has access to through his/her entitlements can be retrieved.
     * @param {string} regionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegion: (regionId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of regions. Only the regions the user has access to through his/her entitlements are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegions: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * RegionApi - functional programming interface
 * @export
 */
export declare const RegionApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a region. Only the regions the user has access to through his/her entitlements can be retrieved.
     * @param {string} regionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegion(regionId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Region>>;
    /**
     *
     * @summary Retrieve a list of regions. Only the regions the user has access to through his/her entitlements are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegions(options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<RegionList>>;
};
/**
 * RegionApi - factory interface
 * @export
 */
export declare const RegionApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Retrieve a region. Only the regions the user has access to through his/her entitlements can be retrieved.
     * @param {string} regionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegion(regionId: string, options?: any): AxiosPromise<Region>;
    /**
     *
     * @summary Retrieve a list of regions. Only the regions the user has access to through his/her entitlements are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegions(options?: any): AxiosPromise<RegionList>;
};
/**
 * RegionApi - object-oriented interface
 * @export
 * @class RegionApi
 * @extends {BaseAPI}
 */
export declare class RegionApi extends BaseAPI {
    /**
     *
     * @summary Retrieve a region. Only the regions the user has access to through his/her entitlements can be retrieved.
     * @param {string} regionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    getRegion(regionId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Region, any>>;
    /**
     *
     * @summary Retrieve a list of regions. Only the regions the user has access to through his/her entitlements are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    getRegions(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<RegionList, any>>;
}
/**
 * SampleApi - axios parameter creator
 * @export
 */
export declare const SampleApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a list of samples.
     * @param {string} region The ID of the region to filter on. This parameter is required.
     * @param {string} [search] To search through multiple fields of data.
     * @param {string} [userTags] The user tags to filter on.
     * @param {string} [technicalTags] The technical tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSamples: (region: string, search?: string | undefined, userTags?: string | undefined, technicalTags?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * SampleApi - functional programming interface
 * @export
 */
export declare const SampleApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a list of samples.
     * @param {string} region The ID of the region to filter on. This parameter is required.
     * @param {string} [search] To search through multiple fields of data.
     * @param {string} [userTags] The user tags to filter on.
     * @param {string} [technicalTags] The technical tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSamples(region: string, search?: string | undefined, userTags?: string | undefined, technicalTags?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<SamplePagedList>>;
};
/**
 * SampleApi - factory interface
 * @export
 */
export declare const SampleApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Retrieve a list of samples.
     * @param {string} region The ID of the region to filter on. This parameter is required.
     * @param {string} [search] To search through multiple fields of data.
     * @param {string} [userTags] The user tags to filter on.
     * @param {string} [technicalTags] The technical tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSamples(region: string, search?: string | undefined, userTags?: string | undefined, technicalTags?: string | undefined, pageOffset?: string | undefined, pageToken?: string | undefined, pageSize?: string | undefined, sort?: string | undefined, options?: any): AxiosPromise<SamplePagedList>;
};
/**
 * SampleApi - object-oriented interface
 * @export
 * @class SampleApi
 * @extends {BaseAPI}
 */
export declare class SampleApi extends BaseAPI {
    /**
     *
     * @summary Retrieve a list of samples.
     * @param {string} region The ID of the region to filter on. This parameter is required.
     * @param {string} [search] To search through multiple fields of data.
     * @param {string} [userTags] The user tags to filter on.
     * @param {string} [technicalTags] The technical tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SampleApi
     */
    getSamples(region: string, search?: string, userTags?: string, technicalTags?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<SamplePagedList, any>>;
}
/**
 * StorageBundleApi - axios parameter creator
 * @export
 */
export declare const StorageBundleApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a list of storage bundles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageBundles: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * StorageBundleApi - functional programming interface
 * @export
 */
export declare const StorageBundleApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a list of storage bundles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageBundles(options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<StorageBundleList>>;
};
/**
 * StorageBundleApi - factory interface
 * @export
 */
export declare const StorageBundleApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Retrieve a list of storage bundles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageBundles(options?: any): AxiosPromise<StorageBundleList>;
};
/**
 * StorageBundleApi - object-oriented interface
 * @export
 * @class StorageBundleApi
 * @extends {BaseAPI}
 */
export declare class StorageBundleApi extends BaseAPI {
    /**
     *
     * @summary Retrieve a list of storage bundles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageBundleApi
     */
    getStorageBundles(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<StorageBundleList, any>>;
}
/**
 * StorageConfigurationApi - axios parameter creator
 * @export
 */
export declare const StorageConfigurationApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a new storage configuration
     * @param {CreateStorageConfiguration} [createStorageConfiguration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStorageConfiguration: (createStorageConfiguration?: CreateStorageConfiguration | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a storage configuration.
     * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConfiguration: (storageConfigurationId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a storage configuration detail.
     * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConfigurationDetails: (storageConfigurationId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of storage configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConfigurations: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Here you share your own storage configuration with all the other users in your tenant.
     * @summary Share your own storage configuration with tenant.
     * @param {string} storageConfigurationId The ID of the storage configuration to share
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareStorageConfiguration: (storageConfigurationId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * StorageConfigurationApi - functional programming interface
 * @export
 */
export declare const StorageConfigurationApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a new storage configuration
     * @param {CreateStorageConfiguration} [createStorageConfiguration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStorageConfiguration(createStorageConfiguration?: CreateStorageConfiguration | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<StorageConfiguration>>;
    /**
     *
     * @summary Retrieve a storage configuration.
     * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConfiguration(storageConfigurationId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<StorageConfiguration>>;
    /**
     *
     * @summary Retrieve a storage configuration detail.
     * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConfigurationDetails(storageConfigurationId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<StorageConfigurationDetails>>;
    /**
     *
     * @summary Retrieve a list of storage configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConfigurations(options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<StorageConfigurationWithDetailsList>>;
    /**
     * Here you share your own storage configuration with all the other users in your tenant.
     * @summary Share your own storage configuration with tenant.
     * @param {string} storageConfigurationId The ID of the storage configuration to share
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareStorageConfiguration(storageConfigurationId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
};
/**
 * StorageConfigurationApi - factory interface
 * @export
 */
export declare const StorageConfigurationApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Create a new storage configuration
     * @param {CreateStorageConfiguration} [createStorageConfiguration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStorageConfiguration(createStorageConfiguration?: CreateStorageConfiguration | undefined, options?: any): AxiosPromise<StorageConfiguration>;
    /**
     *
     * @summary Retrieve a storage configuration.
     * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConfiguration(storageConfigurationId: string, options?: any): AxiosPromise<StorageConfiguration>;
    /**
     *
     * @summary Retrieve a storage configuration detail.
     * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConfigurationDetails(storageConfigurationId: string, options?: any): AxiosPromise<StorageConfigurationDetails>;
    /**
     *
     * @summary Retrieve a list of storage configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConfigurations(options?: any): AxiosPromise<StorageConfigurationWithDetailsList>;
    /**
     * Here you share your own storage configuration with all the other users in your tenant.
     * @summary Share your own storage configuration with tenant.
     * @param {string} storageConfigurationId The ID of the storage configuration to share
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareStorageConfiguration(storageConfigurationId: string, options?: any): AxiosPromise<void>;
};
/**
 * StorageConfigurationApi - object-oriented interface
 * @export
 * @class StorageConfigurationApi
 * @extends {BaseAPI}
 */
export declare class StorageConfigurationApi extends BaseAPI {
    /**
     *
     * @summary Create a new storage configuration
     * @param {CreateStorageConfiguration} [createStorageConfiguration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageConfigurationApi
     */
    createStorageConfiguration(createStorageConfiguration?: CreateStorageConfiguration, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<StorageConfiguration, any>>;
    /**
     *
     * @summary Retrieve a storage configuration.
     * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageConfigurationApi
     */
    getStorageConfiguration(storageConfigurationId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<StorageConfiguration, any>>;
    /**
     *
     * @summary Retrieve a storage configuration detail.
     * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageConfigurationApi
     */
    getStorageConfigurationDetails(storageConfigurationId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<StorageConfigurationDetails, any>>;
    /**
     *
     * @summary Retrieve a list of storage configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageConfigurationApi
     */
    getStorageConfigurations(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<StorageConfigurationWithDetailsList, any>>;
    /**
     * Here you share your own storage configuration with all the other users in your tenant.
     * @summary Share your own storage configuration with tenant.
     * @param {string} storageConfigurationId The ID of the storage configuration to share
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageConfigurationApi
     */
    shareStorageConfiguration(storageConfigurationId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * StorageCredentialsApi - axios parameter creator
 * @export
 */
export declare const StorageCredentialsApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a new storage credential
     * @param {CreateStorageCredential} [createStorageCredential]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStorageCredential: (createStorageCredential?: CreateStorageCredential | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a storage credential.
     * @param {string} storageCredentialId The ID of the storage credential to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageCredential: (storageCredentialId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of storage credentials.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageCredentials: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Here you share your own storage credentials with all the other users in your tenant.
     * @summary Share your own storage credentials with tenant.
     * @param {string} storageCredentialId The ID of the storage credential to share
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareStorageCredential: (storageCredentialId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * When your storage credentials change or get updated due to security reasons you need to update them here.
     * @summary Update a storage credential\'s secrets.
     * @param {string} storageCredentialId
     * @param {UpdateStorageCredentialSecrets} [updateStorageCredentialSecrets]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStorageCredentialSecrets: (storageCredentialId: string, updateStorageCredentialSecrets?: UpdateStorageCredentialSecrets | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * StorageCredentialsApi - functional programming interface
 * @export
 */
export declare const StorageCredentialsApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Create a new storage credential
     * @param {CreateStorageCredential} [createStorageCredential]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStorageCredential(createStorageCredential?: CreateStorageCredential | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<StorageCredential>>;
    /**
     *
     * @summary Retrieve a storage credential.
     * @param {string} storageCredentialId The ID of the storage credential to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageCredential(storageCredentialId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<StorageCredential>>;
    /**
     *
     * @summary Retrieve a list of storage credentials.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageCredentials(options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<StorageCredentialList>>;
    /**
     * Here you share your own storage credentials with all the other users in your tenant.
     * @summary Share your own storage credentials with tenant.
     * @param {string} storageCredentialId The ID of the storage credential to share
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareStorageCredential(storageCredentialId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     * When your storage credentials change or get updated due to security reasons you need to update them here.
     * @summary Update a storage credential\'s secrets.
     * @param {string} storageCredentialId
     * @param {UpdateStorageCredentialSecrets} [updateStorageCredentialSecrets]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStorageCredentialSecrets(storageCredentialId: string, updateStorageCredentialSecrets?: UpdateStorageCredentialSecrets | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
};
/**
 * StorageCredentialsApi - factory interface
 * @export
 */
export declare const StorageCredentialsApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Create a new storage credential
     * @param {CreateStorageCredential} [createStorageCredential]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStorageCredential(createStorageCredential?: CreateStorageCredential | undefined, options?: any): AxiosPromise<StorageCredential>;
    /**
     *
     * @summary Retrieve a storage credential.
     * @param {string} storageCredentialId The ID of the storage credential to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageCredential(storageCredentialId: string, options?: any): AxiosPromise<StorageCredential>;
    /**
     *
     * @summary Retrieve a list of storage credentials.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageCredentials(options?: any): AxiosPromise<StorageCredentialList>;
    /**
     * Here you share your own storage credentials with all the other users in your tenant.
     * @summary Share your own storage credentials with tenant.
     * @param {string} storageCredentialId The ID of the storage credential to share
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareStorageCredential(storageCredentialId: string, options?: any): AxiosPromise<void>;
    /**
     * When your storage credentials change or get updated due to security reasons you need to update them here.
     * @summary Update a storage credential\'s secrets.
     * @param {string} storageCredentialId
     * @param {UpdateStorageCredentialSecrets} [updateStorageCredentialSecrets]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStorageCredentialSecrets(storageCredentialId: string, updateStorageCredentialSecrets?: UpdateStorageCredentialSecrets | undefined, options?: any): AxiosPromise<void>;
};
/**
 * StorageCredentialsApi - object-oriented interface
 * @export
 * @class StorageCredentialsApi
 * @extends {BaseAPI}
 */
export declare class StorageCredentialsApi extends BaseAPI {
    /**
     *
     * @summary Create a new storage credential
     * @param {CreateStorageCredential} [createStorageCredential]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageCredentialsApi
     */
    createStorageCredential(createStorageCredential?: CreateStorageCredential, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<StorageCredential, any>>;
    /**
     *
     * @summary Retrieve a storage credential.
     * @param {string} storageCredentialId The ID of the storage credential to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageCredentialsApi
     */
    getStorageCredential(storageCredentialId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<StorageCredential, any>>;
    /**
     *
     * @summary Retrieve a list of storage credentials.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageCredentialsApi
     */
    getStorageCredentials(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<StorageCredentialList, any>>;
    /**
     * Here you share your own storage credentials with all the other users in your tenant.
     * @summary Share your own storage credentials with tenant.
     * @param {string} storageCredentialId The ID of the storage credential to share
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageCredentialsApi
     */
    shareStorageCredential(storageCredentialId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * When your storage credentials change or get updated due to security reasons you need to update them here.
     * @summary Update a storage credential\'s secrets.
     * @param {string} storageCredentialId
     * @param {UpdateStorageCredentialSecrets} [updateStorageCredentialSecrets]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageCredentialsApi
     */
    updateStorageCredentialSecrets(storageCredentialId: string, updateStorageCredentialSecrets?: UpdateStorageCredentialSecrets, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * TokenApi - axios parameter creator
 * @export
 */
export declare const TokenApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Generate a JWT using an API-key, Basic Authentication or a psToken. When using Basic Authentication, and you are member of several tenants, also provide the tenant request parameter to indicate for which tenant you want to authenticate. Note that Basic Authentication will not work for SSO (Single Sign On) enabled authentication.
     * @summary Generate a JWT using an API-key, Basic Authentication or a psToken.
     * @param {string} [tenant] The name of your tenant in case you have access to multiple tenants.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createJwtToken: (tenant?: string | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * When still having a valid JWT, this endpoint can be used to extend the validity.
     * @summary Refresh a JWT using a not yet expired, still valid JWT.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshJwtToken: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TokenApi - functional programming interface
 * @export
 */
export declare const TokenApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Generate a JWT using an API-key, Basic Authentication or a psToken. When using Basic Authentication, and you are member of several tenants, also provide the tenant request parameter to indicate for which tenant you want to authenticate. Note that Basic Authentication will not work for SSO (Single Sign On) enabled authentication.
     * @summary Generate a JWT using an API-key, Basic Authentication or a psToken.
     * @param {string} [tenant] The name of your tenant in case you have access to multiple tenants.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createJwtToken(tenant?: string | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Token>>;
    /**
     * When still having a valid JWT, this endpoint can be used to extend the validity.
     * @summary Refresh a JWT using a not yet expired, still valid JWT.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshJwtToken(options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Token>>;
};
/**
 * TokenApi - factory interface
 * @export
 */
export declare const TokenApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     * Generate a JWT using an API-key, Basic Authentication or a psToken. When using Basic Authentication, and you are member of several tenants, also provide the tenant request parameter to indicate for which tenant you want to authenticate. Note that Basic Authentication will not work for SSO (Single Sign On) enabled authentication.
     * @summary Generate a JWT using an API-key, Basic Authentication or a psToken.
     * @param {string} [tenant] The name of your tenant in case you have access to multiple tenants.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createJwtToken(tenant?: string | undefined, options?: any): AxiosPromise<Token>;
    /**
     * When still having a valid JWT, this endpoint can be used to extend the validity.
     * @summary Refresh a JWT using a not yet expired, still valid JWT.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshJwtToken(options?: any): AxiosPromise<Token>;
};
/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
export declare class TokenApi extends BaseAPI {
    /**
     * Generate a JWT using an API-key, Basic Authentication or a psToken. When using Basic Authentication, and you are member of several tenants, also provide the tenant request parameter to indicate for which tenant you want to authenticate. Note that Basic Authentication will not work for SSO (Single Sign On) enabled authentication.
     * @summary Generate a JWT using an API-key, Basic Authentication or a psToken.
     * @param {string} [tenant] The name of your tenant in case you have access to multiple tenants.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    createJwtToken(tenant?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Token, any>>;
    /**
     * When still having a valid JWT, this endpoint can be used to extend the validity.
     * @summary Refresh a JWT using a not yet expired, still valid JWT.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    refreshJwtToken(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Token, any>>;
}
/**
 * UserApi - axios parameter creator
 * @export
 */
export declare const UserApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Endpoint for approving a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Approve a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveUser: (userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint for assigning tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Assign tenant administrator rights to a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignTenantAdminRightsToUser: (userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: (userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint for revoking tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Revoke tenant administrator rights to a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeTenantAdminRightsToUser: (userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fields which can be updated: - greeting - two factor authentication - job title - first name - last name - mobile phone number - phone number - fax number - address lines - postal code - city - country - state
     * @summary Update a user.
     * @param {string} userId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {User} [user]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: (userId: string, ifMatch?: string | undefined, user?: User | undefined, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * UserApi - functional programming interface
 * @export
 */
export declare const UserApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Endpoint for approving a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Approve a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveUser(userId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     * Endpoint for assigning tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Assign tenant administrator rights to a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignTenantAdminRightsToUser(userId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     *
     * @summary Retrieve a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(userId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<User>>;
    /**
     *
     * @summary Retrieve a list of users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<UserList>>;
    /**
     * Endpoint for revoking tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Revoke tenant administrator rights to a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeTenantAdminRightsToUser(userId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<void>>;
    /**
     * Fields which can be updated: - greeting - two factor authentication - job title - first name - last name - mobile phone number - phone number - fax number - address lines - postal code - city - country - state
     * @summary Update a user.
     * @param {string} userId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {User} [user]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(userId: string, ifMatch?: string | undefined, user?: User | undefined, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<User>>;
};
/**
 * UserApi - factory interface
 * @export
 */
export declare const UserApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     * Endpoint for approving a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Approve a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveUser(userId: string, options?: any): AxiosPromise<void>;
    /**
     * Endpoint for assigning tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Assign tenant administrator rights to a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignTenantAdminRightsToUser(userId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Retrieve a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(userId: string, options?: any): AxiosPromise<User>;
    /**
     *
     * @summary Retrieve a list of users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(options?: any): AxiosPromise<UserList>;
    /**
     * Endpoint for revoking tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Revoke tenant administrator rights to a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeTenantAdminRightsToUser(userId: string, options?: any): AxiosPromise<void>;
    /**
     * Fields which can be updated: - greeting - two factor authentication - job title - first name - last name - mobile phone number - phone number - fax number - address lines - postal code - city - country - state
     * @summary Update a user.
     * @param {string} userId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {User} [user]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(userId: string, ifMatch?: string | undefined, user?: User | undefined, options?: any): AxiosPromise<User>;
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export declare class UserApi extends BaseAPI {
    /**
     * Endpoint for approving a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Approve a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    approveUser(userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Endpoint for assigning tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Assign tenant administrator rights to a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    assignTenantAdminRightsToUser(userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Retrieve a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<User, any>>;
    /**
     *
     * @summary Retrieve a list of users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUsers(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UserList, any>>;
    /**
     * Endpoint for revoking tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Revoke tenant administrator rights to a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    revokeTenantAdminRightsToUser(userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Fields which can be updated: - greeting - two factor authentication - job title - first name - last name - mobile phone number - phone number - fax number - address lines - postal code - city - country - state
     * @summary Update a user.
     * @param {string} userId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {User} [user]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUser(userId: string, ifMatch?: string, user?: User, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<User, any>>;
}
/**
 * WorkgroupApi - axios parameter creator
 * @export
 */
export declare const WorkgroupApiAxiosParamCreator: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a workgroup.
     * @param {string} workgroupId The ID of the workgroup to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkgroup: (workgroupId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve a list of workgroups.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkgroups: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * WorkgroupApi - functional programming interface
 * @export
 */
export declare const WorkgroupApiFp: (configuration?: Configuration | undefined) => {
    /**
     *
     * @summary Retrieve a workgroup.
     * @param {string} workgroupId The ID of the workgroup to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkgroup(workgroupId: string, options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<Workgroup>>;
    /**
     *
     * @summary Retrieve a list of workgroups.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkgroups(options?: AxiosRequestConfig<any> | undefined): Promise<(axios?: AxiosInstance | undefined, basePath?: string | undefined) => AxiosPromise<WorkgroupList>>;
};
/**
 * WorkgroupApi - factory interface
 * @export
 */
export declare const WorkgroupApiFactory: (configuration?: Configuration | undefined, basePath?: string | undefined, axios?: AxiosInstance | undefined) => {
    /**
     *
     * @summary Retrieve a workgroup.
     * @param {string} workgroupId The ID of the workgroup to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkgroup(workgroupId: string, options?: any): AxiosPromise<Workgroup>;
    /**
     *
     * @summary Retrieve a list of workgroups.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkgroups(options?: any): AxiosPromise<WorkgroupList>;
};
/**
 * WorkgroupApi - object-oriented interface
 * @export
 * @class WorkgroupApi
 * @extends {BaseAPI}
 */
export declare class WorkgroupApi extends BaseAPI {
    /**
     *
     * @summary Retrieve a workgroup.
     * @param {string} workgroupId The ID of the workgroup to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkgroupApi
     */
    getWorkgroup(workgroupId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Workgroup, any>>;
    /**
     *
     * @summary Retrieve a list of workgroups.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkgroupApi
     */
    getWorkgroups(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<WorkgroupList, any>>;
}
