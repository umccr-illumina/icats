"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * ICA Rest API
 * This API can be used to interact with Illumina Connected Analytics.<br> <p> Authentication to the  API can be done in multiple ways:<br> <ul><li>For the entire API, except for the POST /tokens endpoint: API-key + JWT</li> <li>Only for the POST /tokens endpoint: API-key + Basic Authentication</li></ul> </p> <p> <b>API-key</b><br> API keys are managed within the Illumina portal where you can manage your profile after you have logged on. The API-key has to be provided in the X-API-Key header parameter when executing API calls to ICA. In the background, a JWT will be requested at the IDP of Illumina to create a session. A good practice is to not use the API-key for every API call, but to first generate a JWT and to use that for authentication in subsequent calls.<br> </p> <p> <b>JWT</b><br> To avoid using an API-key for each call, we recommend to request a JWT via the POST /tokens endpoint  using this API-key. The JWT will expire after a pre-configured period specified by a tenant administrator through the IAM console in the Illumina portal. The JWT is the preferred way for authentication.<br>A not yet expired, still valid JWT could be refreshed using the POST /tokens:refresh endpoint.<br> </p> <p> <b>Basic Authentication</b><br> Basic authentication is only supported by the POST /tokens endpoint for generating a JWT. Use \"Basic base64encoded(emailaddress:password)\" in the \"Authorization\" header parameter for this authentication method. In case having access to multiple tenants using the same email-address, also provide the \"tenant\" request parameter to indicate what tenant you would like to request a JWT for. </p>
 *
 * The version of the OpenAPI document: 3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectBaseTableStatusEnum = exports.ProjectBaseTableTypeEnum = exports.ProjectBillingModeEnum = exports.PipelineLanguageEnum = exports.NotificationChannelTypeEnum = exports.ModelStateEnum = exports.MetadataModelStateEnum = exports.MetadataFieldFieldTypeEnum = exports.LoadDataInBaseRequestWritePreferenceEnum = exports.LoadDataInBaseRequestEncodingEnum = exports.FolderUploadSessionStatusEnum = exports.FindSampleConditionMatchModeEnum = exports.FindProjectSamplesTechTagMatchModeEnum = exports.FindProjectSamplesConnectorTagMatchModeEnum = exports.FindProjectSamplesRunInputTagMatchModeEnum = exports.FindProjectSamplesUserTagMatchModeEnum = exports.FieldFieldTypeEnum = exports.EventLogEventTypeCategoryEnum = exports.DataTransferStatusEnum = exports.DataTransferProtocolEnum = exports.DataTransferDirectionEnum = exports.DataDetailsDataTypeEnum = exports.DataDetailsStatusEnum = exports.CwlAnalysisStructuredInputObjectTypeEnum = exports.CwlAnalysisJsonInputObjectTypeEnum = exports.CreateTemporaryCredentialsCredentialsFormatEnum = exports.CreateStorageCredentialTypeEnum = exports.CreateStorageConfigurationTypeEnum = exports.CreateProjectPermissionMembershipTypeEnum = exports.CreateProjectPermissionRoleBenchEnum = exports.CreateProjectPermissionRoleBaseEnum = exports.CreateProjectPermissionRoleFlowEnum = exports.CreateProjectPermissionRoleProjectEnum = exports.CreateProjectBillingModeEnum = exports.CreateNotificationChannelTypeEnum = exports.CreateDataDataTypeEnum = exports.CreateConnectorOsEnum = exports.CreateConnectorModeEnum = exports.CreateBundleBundleStatusEnum = exports.ConnectorInstallationStatusEnum = exports.ConnectorOsEnum = exports.ConnectorModeEnum = exports.CWLToolDefinitionStatusEnum = exports.BundleStatusEnum = exports.BaseJobStatusEnum = exports.BaseJobTypeEnum = exports.ApplicationTypeEnum = exports.AnalysisStepStatusEnum = exports.AnalysisDataDataTypeEnum = exports.AnalysisStatusEnum = void 0;
exports.EntitlementDetailApiAxiosParamCreator = exports.EntitledBundleApi = exports.EntitledBundleApiFactory = exports.EntitledBundleApiFp = exports.EntitledBundleApiAxiosParamCreator = exports.DataFormatApi = exports.DataFormatApiFactory = exports.DataFormatApiFp = exports.DataFormatApiAxiosParamCreator = exports.ConnectorApi = exports.ConnectorApiFactory = exports.ConnectorApiFp = exports.ConnectorApiAxiosParamCreator = exports.BundleToolApi = exports.BundleToolApiFactory = exports.BundleToolApiFp = exports.BundleToolApiAxiosParamCreator = exports.BundleSampleApi = exports.BundleSampleApiFactory = exports.BundleSampleApiFp = exports.BundleSampleApiAxiosParamCreator = exports.BundlePipelineApi = exports.BundlePipelineApiFactory = exports.BundlePipelineApiFp = exports.BundlePipelineApiAxiosParamCreator = exports.BundleDataApi = exports.BundleDataApiFactory = exports.BundleDataApiFp = exports.BundleDataApiAxiosParamCreator = exports.BundleApi = exports.BundleApiFactory = exports.BundleApiFp = exports.BundleApiAxiosParamCreator = exports.AnalysisStorageApi = exports.AnalysisStorageApiFactory = exports.AnalysisStorageApiFp = exports.AnalysisStorageApiAxiosParamCreator = exports.UserGreetingEnum = exports.StorageCredentialTypeEnum = exports.StorageConfigurationWithDetailsStatusEnum = exports.StorageConfigurationWithDetailsTypeEnum = exports.StorageConfigurationStatusEnum = exports.StorageConfigurationTypeEnum = exports.ScheduleDownloadProtocolEnum = exports.SampleStatusEnum = exports.ProjectPermissionMembershipTypeEnum = exports.ProjectPermissionRoleBenchEnum = exports.ProjectPermissionRoleBaseEnum = exports.ProjectPermissionRoleFlowEnum = exports.ProjectPermissionRoleProjectEnum = void 0;
exports.ProjectCustomNotificationSubscriptionsApiFactory = exports.ProjectCustomNotificationSubscriptionsApiFp = exports.ProjectCustomNotificationSubscriptionsApiAxiosParamCreator = exports.ProjectCustomEventsApi = exports.ProjectCustomEventsApiFactory = exports.ProjectCustomEventsApiFp = exports.ProjectCustomEventsApiAxiosParamCreator = exports.ProjectBaseTableApi = exports.ProjectBaseTableApiFactory = exports.ProjectBaseTableApiFp = exports.ProjectBaseTableApiAxiosParamCreator = exports.ProjectBaseJobApi = exports.ProjectBaseJobApiFactory = exports.ProjectBaseJobApiFp = exports.ProjectBaseJobApiAxiosParamCreator = exports.ProjectBaseApi = exports.ProjectBaseApiFactory = exports.ProjectBaseApiFp = exports.ProjectBaseApiAxiosParamCreator = exports.ProjectAnalysisApi = exports.ProjectAnalysisApiFactory = exports.ProjectAnalysisApiFp = exports.ProjectAnalysisApiAxiosParamCreator = exports.ProjectApi = exports.ProjectApiFactory = exports.ProjectApiFp = exports.ProjectApiAxiosParamCreator = exports.PipelineApi = exports.PipelineApiFactory = exports.PipelineApiFp = exports.PipelineApiAxiosParamCreator = exports.NotificationChannelApi = exports.NotificationChannelApiFactory = exports.NotificationChannelApiFp = exports.NotificationChannelApiAxiosParamCreator = exports.MetadataModelApi = exports.MetadataModelApiFactory = exports.MetadataModelApiFp = exports.MetadataModelApiAxiosParamCreator = exports.EventLogApi = exports.EventLogApiFactory = exports.EventLogApiFp = exports.EventLogApiAxiosParamCreator = exports.EventCodeApi = exports.EventCodeApiFactory = exports.EventCodeApiFp = exports.EventCodeApiAxiosParamCreator = exports.EntitlementDetailApi = exports.EntitlementDetailApiFactory = exports.EntitlementDetailApiFp = void 0;
exports.UserApiAxiosParamCreator = exports.TokenApi = exports.TokenApiFactory = exports.TokenApiFp = exports.TokenApiAxiosParamCreator = exports.StorageCredentialsApi = exports.StorageCredentialsApiFactory = exports.StorageCredentialsApiFp = exports.StorageCredentialsApiAxiosParamCreator = exports.StorageConfigurationApi = exports.StorageConfigurationApiFactory = exports.StorageConfigurationApiFp = exports.StorageConfigurationApiAxiosParamCreator = exports.StorageBundleApi = exports.StorageBundleApiFactory = exports.StorageBundleApiFp = exports.StorageBundleApiAxiosParamCreator = exports.SampleApi = exports.SampleApiFactory = exports.SampleApiFp = exports.SampleApiAxiosParamCreator = exports.RegionApi = exports.RegionApiFactory = exports.RegionApiFp = exports.RegionApiAxiosParamCreator = exports.ProjectSampleApi = exports.ProjectSampleApiFactory = exports.ProjectSampleApiFp = exports.ProjectSampleApiAxiosParamCreator = exports.ProjectPipelineApi = exports.ProjectPipelineApiFactory = exports.ProjectPipelineApiFp = exports.ProjectPipelineApiAxiosParamCreator = exports.ProjectPermissionApi = exports.ProjectPermissionApiFactory = exports.ProjectPermissionApiFp = exports.ProjectPermissionApiAxiosParamCreator = exports.ProjectNotificationSubscriptionsApi = exports.ProjectNotificationSubscriptionsApiFactory = exports.ProjectNotificationSubscriptionsApiFp = exports.ProjectNotificationSubscriptionsApiAxiosParamCreator = exports.ProjectDataTransferApi = exports.ProjectDataTransferApiFactory = exports.ProjectDataTransferApiFp = exports.ProjectDataTransferApiAxiosParamCreator = exports.ProjectDataApi = exports.ProjectDataApiFactory = exports.ProjectDataApiFp = exports.ProjectDataApiAxiosParamCreator = exports.ProjectCustomNotificationSubscriptionsApi = void 0;
exports.WorkgroupApi = exports.WorkgroupApiFactory = exports.WorkgroupApiFp = exports.WorkgroupApiAxiosParamCreator = exports.UserApi = exports.UserApiFactory = exports.UserApiFp = void 0;
var axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
var common_1 = require("./common");
// @ts-ignore
var base_1 = require("./base");
exports.AnalysisStatusEnum = {
    Requested: 'REQUESTED',
    Awaitinginput: 'AWAITINGINPUT',
    Inprogress: 'INPROGRESS',
    Succeeded: 'SUCCEEDED',
    Failed: 'FAILED',
    Failedfinal: 'FAILEDFINAL',
    Aborted: 'ABORTED'
};
exports.AnalysisDataDataTypeEnum = {
    File: 'FILE',
    Folder: 'FOLDER'
};
exports.AnalysisStepStatusEnum = {
    Failed: 'FAILED',
    Done: 'DONE',
    Running: 'RUNNING',
    Interrupted: 'INTERRUPTED',
    Aborted: 'ABORTED',
    Waiting: 'WAITING'
};
exports.ApplicationTypeEnum = {
    Main: 'MAIN',
    Websolution: 'WEBSOLUTION',
    External: 'EXTERNAL'
};
exports.BaseJobTypeEnum = {
    Copytable: 'COPYTABLE',
    Exporttable: 'EXPORTTABLE',
    Createtable: 'CREATETABLE',
    Executequery: 'EXECUTEQUERY',
    Loaddata: 'LOADDATA',
    Preparedata: 'PREPAREDATA'
};
exports.BaseJobStatusEnum = {
    Created: 'CREATED',
    Succeeded: 'SUCCEEDED',
    Failed: 'FAILED',
    Pending: 'PENDING',
    Inprogress: 'INPROGRESS',
    Aborted: 'ABORTED'
};
exports.BundleStatusEnum = {
    Draft: 'DRAFT',
    Released: 'RELEASED',
    Deprecated: 'DEPRECATED'
};
exports.CWLToolDefinitionStatusEnum = {
    Draft: 'DRAFT',
    Released: 'RELEASED',
    Deprecated: 'DEPRECATED',
    Releasecandidate: 'RELEASECANDIDATE',
    Building: 'BUILDING',
    Buildfailed: 'BUILDFAILED'
};
exports.ConnectorModeEnum = {
    Download: 'DOWNLOAD',
    Upload: 'UPLOAD',
    Both: 'BOTH',
    None: 'NONE'
};
exports.ConnectorOsEnum = {
    Windows: 'WINDOWS',
    Linux: 'LINUX',
    Osx: 'OSX'
};
exports.ConnectorInstallationStatusEnum = {
    PendingInstallation: 'PENDING_INSTALLATION',
    Installed: 'INSTALLED',
    Error: 'ERROR',
    Unknown: 'UNKNOWN',
    Cancelled: 'CANCELLED'
};
exports.CreateBundleBundleStatusEnum = {
    Draft: 'DRAFT',
    Released: 'RELEASED',
    Deprecated: 'DEPRECATED'
};
exports.CreateConnectorModeEnum = {
    Download: 'DOWNLOAD',
    Upload: 'UPLOAD',
    Both: 'BOTH',
    None: 'NONE'
};
exports.CreateConnectorOsEnum = {
    Windows: 'WINDOWS',
    Linux: 'LINUX',
    Osx: 'OSX'
};
exports.CreateDataDataTypeEnum = {
    File: 'FILE',
    Folder: 'FOLDER'
};
exports.CreateNotificationChannelTypeEnum = {
    Mail: 'MAIL',
    Sqs: 'SQS',
    Sns: 'SNS',
    Http: 'HTTP'
};
exports.CreateProjectBillingModeEnum = {
    Project: 'PROJECT',
    Tenant: 'TENANT'
};
exports.CreateProjectPermissionRoleProjectEnum = {
    None: 'NONE',
    Viewer: 'VIEWER',
    Contributor: 'CONTRIBUTOR',
    Administrator: 'ADMINISTRATOR',
    DataProvider: 'DATA_PROVIDER'
};
exports.CreateProjectPermissionRoleFlowEnum = {
    None: 'NONE',
    Viewer: 'VIEWER',
    Contributor: 'CONTRIBUTOR'
};
exports.CreateProjectPermissionRoleBaseEnum = {
    None: 'NONE',
    Viewer: 'VIEWER',
    Contributor: 'CONTRIBUTOR'
};
exports.CreateProjectPermissionRoleBenchEnum = {
    None: 'NONE',
    Contributor: 'CONTRIBUTOR'
};
exports.CreateProjectPermissionMembershipTypeEnum = {
    User: 'USER',
    Email: 'EMAIL',
    Workgroup: 'WORKGROUP'
};
exports.CreateStorageConfigurationTypeEnum = {
    AwsS3: 'AWS_S3'
};
exports.CreateStorageCredentialTypeEnum = {
    AwsUser: 'AWS_USER'
};
exports.CreateTemporaryCredentialsCredentialsFormatEnum = {
    Rclone: 'RCLONE'
};
exports.CwlAnalysisJsonInputObjectTypeEnum = {
    Structured: 'STRUCTURED',
    Json: 'JSON'
};
exports.CwlAnalysisStructuredInputObjectTypeEnum = {
    Structured: 'STRUCTURED',
    Json: 'JSON'
};
exports.DataDetailsStatusEnum = {
    Partial: 'PARTIAL',
    Available: 'AVAILABLE',
    Archiving: 'ARCHIVING',
    Archived: 'ARCHIVED',
    Unarchiving: 'UNARCHIVING',
    Deleting: 'DELETING'
};
exports.DataDetailsDataTypeEnum = {
    File: 'FILE',
    Folder: 'FOLDER'
};
exports.DataTransferDirectionEnum = {
    Upload: 'UPLOAD',
    Download: 'DOWNLOAD',
    Import: 'IMPORT'
};
exports.DataTransferProtocolEnum = {
    Https: 'HTTPS'
};
exports.DataTransferStatusEnum = {
    Requested: 'REQUESTED',
    Ongoing: 'ONGOING',
    Succeeded: 'SUCCEEDED',
    Failed: 'FAILED',
    Aborted: 'ABORTED',
    Abortrequested: 'ABORTREQUESTED',
    Scheduled: 'SCHEDULED'
};
exports.EventLogEventTypeCategoryEnum = {
    Error: 'ERROR',
    Warn: 'WARN',
    Info: 'INFO'
};
exports.FieldFieldTypeEnum = {
    Text: 'TEXT',
    Numeric: 'NUMERIC',
    Boolean: 'BOOLEAN',
    Date: 'DATE',
    Enumeration: 'ENUMERATION',
    Fieldgroup: 'FIELDGROUP',
    PipelineReference: 'PIPELINE_REFERENCE'
};
exports.FindProjectSamplesUserTagMatchModeEnum = {
    Exact: 'EXACT',
    Exclude: 'EXCLUDE',
    Fuzzy: 'FUZZY'
};
exports.FindProjectSamplesRunInputTagMatchModeEnum = {
    Exact: 'EXACT',
    Exclude: 'EXCLUDE',
    Fuzzy: 'FUZZY'
};
exports.FindProjectSamplesConnectorTagMatchModeEnum = {
    Exact: 'EXACT',
    Exclude: 'EXCLUDE',
    Fuzzy: 'FUZZY'
};
exports.FindProjectSamplesTechTagMatchModeEnum = {
    Exact: 'EXACT',
    Exclude: 'EXCLUDE',
    Fuzzy: 'FUZZY'
};
exports.FindSampleConditionMatchModeEnum = {
    Exact: 'EXACT',
    Exclude: 'EXCLUDE',
    Fuzzy: 'FUZZY'
};
exports.FolderUploadSessionStatusEnum = {
    Open: 'OPEN',
    Closed: 'CLOSED',
    Completed: 'COMPLETED'
};
exports.LoadDataInBaseRequestEncodingEnum = {
    Utf8: 'UTF8',
    Iso88591: 'ISO88591'
};
exports.LoadDataInBaseRequestWritePreferenceEnum = {
    Writeifempty: 'WRITEIFEMPTY',
    Appendtotable: 'APPENDTOTABLE',
    Overwritetable: 'OVERWRITETABLE'
};
exports.MetadataFieldFieldTypeEnum = {
    Text: 'TEXT',
    Numeric: 'NUMERIC',
    Boolean: 'BOOLEAN',
    Date: 'DATE',
    Group: 'GROUP'
};
exports.MetadataModelStateEnum = {
    Draft: 'DRAFT',
    Published: 'PUBLISHED'
};
exports.ModelStateEnum = {
    Draft: 'DRAFT',
    Published: 'PUBLISHED'
};
exports.NotificationChannelTypeEnum = {
    Mail: 'MAIL',
    Sqs: 'SQS',
    Sns: 'SNS',
    Http: 'HTTP'
};
exports.PipelineLanguageEnum = {
    Cwl: 'CWL',
    Nextflow: 'NEXTFLOW',
    Unknown: 'UNKNOWN'
};
exports.ProjectBillingModeEnum = {
    Project: 'PROJECT',
    Tenant: 'TENANT'
};
exports.ProjectBaseTableTypeEnum = {
    Table: 'TABLE',
    View: 'VIEW'
};
exports.ProjectBaseTableStatusEnum = {
    Available: 'AVAILABLE',
    Deleted: 'DELETED',
    Pending: 'PENDING'
};
exports.ProjectPermissionRoleProjectEnum = {
    None: 'NONE',
    Viewer: 'VIEWER',
    Contributor: 'CONTRIBUTOR',
    Administrator: 'ADMINISTRATOR',
    DataProvider: 'DATA_PROVIDER'
};
exports.ProjectPermissionRoleFlowEnum = {
    None: 'NONE',
    Viewer: 'VIEWER',
    Contributor: 'CONTRIBUTOR'
};
exports.ProjectPermissionRoleBaseEnum = {
    None: 'NONE',
    Viewer: 'VIEWER',
    Contributor: 'CONTRIBUTOR'
};
exports.ProjectPermissionRoleBenchEnum = {
    None: 'NONE',
    Contributor: 'CONTRIBUTOR'
};
exports.ProjectPermissionMembershipTypeEnum = {
    User: 'USER',
    Email: 'EMAIL',
    Workgroup: 'WORKGROUP'
};
exports.SampleStatusEnum = {
    Deleted: 'DELETED',
    Available: 'AVAILABLE',
    Partial: 'PARTIAL'
};
exports.ScheduleDownloadProtocolEnum = {
    Https: 'HTTPS'
};
exports.StorageConfigurationTypeEnum = {
    AwsS3: 'AWS_S3'
};
exports.StorageConfigurationStatusEnum = {
    Initializing: 'INITIALIZING',
    Ok: 'OK',
    Error: 'ERROR'
};
exports.StorageConfigurationWithDetailsTypeEnum = {
    AwsS3: 'AWS_S3'
};
exports.StorageConfigurationWithDetailsStatusEnum = {
    Initializing: 'INITIALIZING',
    Ok: 'OK',
    Error: 'ERROR'
};
exports.StorageCredentialTypeEnum = {
    AwsUser: 'AWS_USER'
};
exports.UserGreetingEnum = {
    Mr: 'MR',
    Mrs: 'MRS',
    Ms: 'MS',
    Miss: 'MISS',
    Dr: 'DR',
    Hr: 'HR',
    Sr: 'SR'
};
/**
 * AnalysisStorageApi - axios parameter creator
 * @export
 */
var AnalysisStorageApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve the list of analysis storage options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisStorageOptions: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/analysisStorages";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.AnalysisStorageApiAxiosParamCreator = AnalysisStorageApiAxiosParamCreator;
/**
 * AnalysisStorageApi - functional programming interface
 * @export
 */
var AnalysisStorageApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.AnalysisStorageApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve the list of analysis storage options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisStorageOptions: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAnalysisStorageOptions(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.AnalysisStorageApiFp = AnalysisStorageApiFp;
/**
 * AnalysisStorageApi - factory interface
 * @export
 */
var AnalysisStorageApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.AnalysisStorageApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve the list of analysis storage options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisStorageOptions: function (options) {
            return localVarFp.getAnalysisStorageOptions(options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.AnalysisStorageApiFactory = AnalysisStorageApiFactory;
/**
 * AnalysisStorageApi - object-oriented interface
 * @export
 * @class AnalysisStorageApi
 * @extends {BaseAPI}
 */
var AnalysisStorageApi = /** @class */ (function (_super) {
    __extends(AnalysisStorageApi, _super);
    function AnalysisStorageApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve the list of analysis storage options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysisStorageApi
     */
    AnalysisStorageApi.prototype.getAnalysisStorageOptions = function (options) {
        var _this = this;
        return (0, exports.AnalysisStorageApiFp)(this.configuration).getAnalysisStorageOptions(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return AnalysisStorageApi;
}(base_1.BaseAPI));
exports.AnalysisStorageApi = AnalysisStorageApi;
/**
 * BundleApi - axios parameter creator
 * @export
 */
var BundleApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Create a new bundle
         * @param {CreateBundle} [createBundle]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundle: function (createBundle, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/bundles";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createBundle, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a bundle.
         * @param {string} bundleId The ID of the bundle to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundle: function (bundleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('getBundle', 'bundleId', bundleId);
                            localVarPath = "/api/bundles/{bundleId}"
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of bundles.
         * @param {string} [search] Search
         * @param {string} [userTags] User tags to filter on
         * @param {string} [technicalTags] Technical tags to filter on
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundles: function (search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/bundles";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (search !== undefined) {
                                localVarQueryParameter['search'] = search;
                            }
                            if (userTags !== undefined) {
                                localVarQueryParameter['userTags'] = userTags;
                            }
                            if (technicalTags !== undefined) {
                                localVarQueryParameter['technicalTags'] = technicalTags;
                            }
                            if (pageOffset !== undefined) {
                                localVarQueryParameter['pageOffset'] = pageOffset;
                            }
                            if (pageToken !== undefined) {
                                localVarQueryParameter['pageToken'] = pageToken;
                            }
                            if (pageSize !== undefined) {
                                localVarQueryParameter['pageSize'] = pageSize;
                            }
                            if (sort !== undefined) {
                                localVarQueryParameter['sort'] = sort;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary release a bundle
         * @param {string} bundleId The ID of the bundle to release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseBundle: function (bundleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('releaseBundle', 'bundleId', bundleId);
                            localVarPath = "/api/bundles/{bundleId}:release"
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.BundleApiAxiosParamCreator = BundleApiAxiosParamCreator;
/**
 * BundleApi - functional programming interface
 * @export
 */
var BundleApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.BundleApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a new bundle
         * @param {CreateBundle} [createBundle]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundle: function (createBundle, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createBundle(createBundle, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a bundle.
         * @param {string} bundleId The ID of the bundle to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundle: function (bundleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getBundle(bundleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of bundles.
         * @param {string} [search] Search
         * @param {string} [userTags] User tags to filter on
         * @param {string} [technicalTags] Technical tags to filter on
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundles: function (search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getBundles(search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary release a bundle
         * @param {string} bundleId The ID of the bundle to release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseBundle: function (bundleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.releaseBundle(bundleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.BundleApiFp = BundleApiFp;
/**
 * BundleApi - factory interface
 * @export
 */
var BundleApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.BundleApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a new bundle
         * @param {CreateBundle} [createBundle]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundle: function (createBundle, options) {
            return localVarFp.createBundle(createBundle, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a bundle.
         * @param {string} bundleId The ID of the bundle to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundle: function (bundleId, options) {
            return localVarFp.getBundle(bundleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of bundles.
         * @param {string} [search] Search
         * @param {string} [userTags] User tags to filter on
         * @param {string} [technicalTags] Technical tags to filter on
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundles: function (search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options) {
            return localVarFp.getBundles(search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary release a bundle
         * @param {string} bundleId The ID of the bundle to release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseBundle: function (bundleId, options) {
            return localVarFp.releaseBundle(bundleId, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.BundleApiFactory = BundleApiFactory;
/**
 * BundleApi - object-oriented interface
 * @export
 * @class BundleApi
 * @extends {BaseAPI}
 */
var BundleApi = /** @class */ (function (_super) {
    __extends(BundleApi, _super);
    function BundleApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Create a new bundle
     * @param {CreateBundle} [createBundle]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    BundleApi.prototype.createBundle = function (createBundle, options) {
        var _this = this;
        return (0, exports.BundleApiFp)(this.configuration).createBundle(createBundle, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a bundle.
     * @param {string} bundleId The ID of the bundle to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    BundleApi.prototype.getBundle = function (bundleId, options) {
        var _this = this;
        return (0, exports.BundleApiFp)(this.configuration).getBundle(bundleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of bundles.
     * @param {string} [search] Search
     * @param {string} [userTags] User tags to filter on
     * @param {string} [technicalTags] Technical tags to filter on
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    BundleApi.prototype.getBundles = function (search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options) {
        var _this = this;
        return (0, exports.BundleApiFp)(this.configuration).getBundles(search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary release a bundle
     * @param {string} bundleId The ID of the bundle to release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    BundleApi.prototype.releaseBundle = function (bundleId, options) {
        var _this = this;
        return (0, exports.BundleApiFp)(this.configuration).releaseBundle(bundleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return BundleApi;
}(base_1.BaseAPI));
exports.BundleApi = BundleApi;
/**
 * BundleDataApi - axios parameter creator
 * @export
 */
var BundleDataApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve the list of bundle data.
         * @param {string} bundleId
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {string} [id] The ids to filter on. This will always match exact.
         * @param {string} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
         * @param {string} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'} [status] The statuses to filter on.
         * @param {string} [formatId] The IDs of the formats to filter on.
         * @param {string} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {string} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
         * @param {string} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
         * @param {string} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
         * @param {string} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
         * @param {string} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
         * @param {string} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {string} [notLinkedToSample] When set to true only date that is unlinked to a sample will be returned.  This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleData: function (bundleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('getBundleData', 'bundleId', bundleId);
                            localVarPath = "/api/bundles/{bundleId}/data"
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (fullText !== undefined) {
                                localVarQueryParameter['fullText'] = fullText;
                            }
                            if (id !== undefined) {
                                localVarQueryParameter['id'] = id;
                            }
                            if (filename !== undefined) {
                                localVarQueryParameter['filename'] = filename;
                            }
                            if (filenameMatchMode !== undefined) {
                                localVarQueryParameter['filenameMatchMode'] = filenameMatchMode;
                            }
                            if (filePath !== undefined) {
                                localVarQueryParameter['filePath'] = filePath;
                            }
                            if (filePathMatchMode !== undefined) {
                                localVarQueryParameter['filePathMatchMode'] = filePathMatchMode;
                            }
                            if (status !== undefined) {
                                localVarQueryParameter['status'] = status;
                            }
                            if (formatId !== undefined) {
                                localVarQueryParameter['formatId'] = formatId;
                            }
                            if (formatCode !== undefined) {
                                localVarQueryParameter['formatCode'] = formatCode;
                            }
                            if (type !== undefined) {
                                localVarQueryParameter['type'] = type;
                            }
                            if (parentFolderId !== undefined) {
                                localVarQueryParameter['parentFolderId'] = parentFolderId;
                            }
                            if (parentFolderPath !== undefined) {
                                localVarQueryParameter['parentFolderPath'] = parentFolderPath;
                            }
                            if (creationDateAfter !== undefined) {
                                localVarQueryParameter['creationDateAfter'] = creationDateAfter;
                            }
                            if (creationDateBefore !== undefined) {
                                localVarQueryParameter['creationDateBefore'] = creationDateBefore;
                            }
                            if (statusDateAfter !== undefined) {
                                localVarQueryParameter['statusDateAfter'] = statusDateAfter;
                            }
                            if (statusDateBefore !== undefined) {
                                localVarQueryParameter['statusDateBefore'] = statusDateBefore;
                            }
                            if (userTag !== undefined) {
                                localVarQueryParameter['userTag'] = userTag;
                            }
                            if (userTagMatchMode !== undefined) {
                                localVarQueryParameter['userTagMatchMode'] = userTagMatchMode;
                            }
                            if (runInputTag !== undefined) {
                                localVarQueryParameter['runInputTag'] = runInputTag;
                            }
                            if (runInputTagMatchMode !== undefined) {
                                localVarQueryParameter['runInputTagMatchMode'] = runInputTagMatchMode;
                            }
                            if (runOutputTag !== undefined) {
                                localVarQueryParameter['runOutputTag'] = runOutputTag;
                            }
                            if (runOutputTagMatchMode !== undefined) {
                                localVarQueryParameter['runOutputTagMatchMode'] = runOutputTagMatchMode;
                            }
                            if (connectorTag !== undefined) {
                                localVarQueryParameter['connectorTag'] = connectorTag;
                            }
                            if (connectorTagMatchMode !== undefined) {
                                localVarQueryParameter['connectorTagMatchMode'] = connectorTagMatchMode;
                            }
                            if (technicalTag !== undefined) {
                                localVarQueryParameter['technicalTag'] = technicalTag;
                            }
                            if (technicalTagMatchMode !== undefined) {
                                localVarQueryParameter['technicalTagMatchMode'] = technicalTagMatchMode;
                            }
                            if (notInRun !== undefined) {
                                localVarQueryParameter['notInRun'] = notInRun;
                            }
                            if (notLinkedToSample !== undefined) {
                                localVarQueryParameter['notLinkedToSample'] = notLinkedToSample;
                            }
                            if (pageOffset !== undefined) {
                                localVarQueryParameter['pageOffset'] = pageOffset;
                            }
                            if (pageToken !== undefined) {
                                localVarQueryParameter['pageToken'] = pageToken;
                            }
                            if (pageSize !== undefined) {
                                localVarQueryParameter['pageSize'] = pageSize;
                            }
                            if (sort !== undefined) {
                                localVarQueryParameter['sort'] = sort;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Link data to this bundle.
         * @param {string} bundleId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataToBundle: function (bundleId, dataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('linkDataToBundle', 'bundleId', bundleId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('linkDataToBundle', 'dataId', dataId);
                            localVarPath = "/api/bundles/{bundleId}/data/{dataId}"
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink data from this bundle.
         * @param {string} bundleId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataFromBundle: function (bundleId, dataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkDataFromBundle', 'bundleId', bundleId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkDataFromBundle', 'dataId', dataId);
                            localVarPath = "/api/bundles/{bundleId}/data/{dataId}"
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.BundleDataApiAxiosParamCreator = BundleDataApiAxiosParamCreator;
/**
 * BundleDataApi - functional programming interface
 * @export
 */
var BundleDataApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.BundleDataApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve the list of bundle data.
         * @param {string} bundleId
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {string} [id] The ids to filter on. This will always match exact.
         * @param {string} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
         * @param {string} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'} [status] The statuses to filter on.
         * @param {string} [formatId] The IDs of the formats to filter on.
         * @param {string} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {string} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
         * @param {string} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
         * @param {string} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
         * @param {string} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
         * @param {string} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
         * @param {string} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {string} [notLinkedToSample] When set to true only date that is unlinked to a sample will be returned.  This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleData: function (bundleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getBundleData(bundleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Link data to this bundle.
         * @param {string} bundleId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataToBundle: function (bundleId, dataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.linkDataToBundle(bundleId, dataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink data from this bundle.
         * @param {string} bundleId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataFromBundle: function (bundleId, dataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unlinkDataFromBundle(bundleId, dataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.BundleDataApiFp = BundleDataApiFp;
/**
 * BundleDataApi - factory interface
 * @export
 */
var BundleDataApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.BundleDataApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve the list of bundle data.
         * @param {string} bundleId
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {string} [id] The ids to filter on. This will always match exact.
         * @param {string} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
         * @param {string} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'} [status] The statuses to filter on.
         * @param {string} [formatId] The IDs of the formats to filter on.
         * @param {string} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {string} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
         * @param {string} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
         * @param {string} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
         * @param {string} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
         * @param {string} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
         * @param {string} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {string} [notLinkedToSample] When set to true only date that is unlinked to a sample will be returned.  This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleData: function (bundleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options) {
            return localVarFp.getBundleData(bundleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Link data to this bundle.
         * @param {string} bundleId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataToBundle: function (bundleId, dataId, options) {
            return localVarFp.linkDataToBundle(bundleId, dataId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Unlink data from this bundle.
         * @param {string} bundleId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataFromBundle: function (bundleId, dataId, options) {
            return localVarFp.unlinkDataFromBundle(bundleId, dataId, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.BundleDataApiFactory = BundleDataApiFactory;
/**
 * BundleDataApi - object-oriented interface
 * @export
 * @class BundleDataApi
 * @extends {BaseAPI}
 */
var BundleDataApi = /** @class */ (function (_super) {
    __extends(BundleDataApi, _super);
    function BundleDataApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve the list of bundle data.
     * @param {string} bundleId
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {string} [id] The ids to filter on. This will always match exact.
     * @param {string} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {string} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'} [status] The statuses to filter on.
     * @param {string} [formatId] The IDs of the formats to filter on.
     * @param {string} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {string} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {string} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {string} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {string} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {string} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {string} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {string} [notLinkedToSample] When set to true only date that is unlinked to a sample will be returned.  This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleDataApi
     */
    BundleDataApi.prototype.getBundleData = function (bundleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options) {
        var _this = this;
        return (0, exports.BundleDataApiFp)(this.configuration).getBundleData(bundleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Link data to this bundle.
     * @param {string} bundleId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleDataApi
     */
    BundleDataApi.prototype.linkDataToBundle = function (bundleId, dataId, options) {
        var _this = this;
        return (0, exports.BundleDataApiFp)(this.configuration).linkDataToBundle(bundleId, dataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Unlink data from this bundle.
     * @param {string} bundleId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleDataApi
     */
    BundleDataApi.prototype.unlinkDataFromBundle = function (bundleId, dataId, options) {
        var _this = this;
        return (0, exports.BundleDataApiFp)(this.configuration).unlinkDataFromBundle(bundleId, dataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return BundleDataApi;
}(base_1.BaseAPI));
exports.BundleDataApi = BundleDataApi;
/**
 * BundlePipelineApi - axios parameter creator
 * @export
 */
var BundlePipelineApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve a list of bundle pipelines.
         * @param {string} bundleId The ID of the bundle to retrieve pipelines for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundlePipelines: function (bundleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('getBundlePipelines', 'bundleId', bundleId);
                            localVarPath = "/api/bundles/{bundleId}/pipelines"
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Link a pipeline to a bundle.
         * @param {string} bundleId The ID of the bundle
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPipelineToBundle: function (bundleId, pipelineId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('linkPipelineToBundle', 'bundleId', bundleId);
                            // verify required parameter 'pipelineId' is not null or undefined
                            (0, common_1.assertParamExists)('linkPipelineToBundle', 'pipelineId', pipelineId);
                            localVarPath = "/api/bundles/{bundleId}/pipelines/{pipelineId}"
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)))
                                .replace("{".concat("pipelineId", "}"), encodeURIComponent(String(pipelineId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink a pipeline from a bundle.
         * @param {string} bundleId The ID of the bundle
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPipelineFromBundle: function (bundleId, pipelineId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkPipelineFromBundle', 'bundleId', bundleId);
                            // verify required parameter 'pipelineId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkPipelineFromBundle', 'pipelineId', pipelineId);
                            localVarPath = "/api/bundles/{bundleId}/pipelines/{pipelineId}"
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)))
                                .replace("{".concat("pipelineId", "}"), encodeURIComponent(String(pipelineId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.BundlePipelineApiAxiosParamCreator = BundlePipelineApiAxiosParamCreator;
/**
 * BundlePipelineApi - functional programming interface
 * @export
 */
var BundlePipelineApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.BundlePipelineApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve a list of bundle pipelines.
         * @param {string} bundleId The ID of the bundle to retrieve pipelines for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundlePipelines: function (bundleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getBundlePipelines(bundleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Link a pipeline to a bundle.
         * @param {string} bundleId The ID of the bundle
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPipelineToBundle: function (bundleId, pipelineId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.linkPipelineToBundle(bundleId, pipelineId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink a pipeline from a bundle.
         * @param {string} bundleId The ID of the bundle
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPipelineFromBundle: function (bundleId, pipelineId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unlinkPipelineFromBundle(bundleId, pipelineId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.BundlePipelineApiFp = BundlePipelineApiFp;
/**
 * BundlePipelineApi - factory interface
 * @export
 */
var BundlePipelineApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.BundlePipelineApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve a list of bundle pipelines.
         * @param {string} bundleId The ID of the bundle to retrieve pipelines for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundlePipelines: function (bundleId, options) {
            return localVarFp.getBundlePipelines(bundleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Link a pipeline to a bundle.
         * @param {string} bundleId The ID of the bundle
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPipelineToBundle: function (bundleId, pipelineId, options) {
            return localVarFp.linkPipelineToBundle(bundleId, pipelineId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Unlink a pipeline from a bundle.
         * @param {string} bundleId The ID of the bundle
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPipelineFromBundle: function (bundleId, pipelineId, options) {
            return localVarFp.unlinkPipelineFromBundle(bundleId, pipelineId, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.BundlePipelineApiFactory = BundlePipelineApiFactory;
/**
 * BundlePipelineApi - object-oriented interface
 * @export
 * @class BundlePipelineApi
 * @extends {BaseAPI}
 */
var BundlePipelineApi = /** @class */ (function (_super) {
    __extends(BundlePipelineApi, _super);
    function BundlePipelineApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve a list of bundle pipelines.
     * @param {string} bundleId The ID of the bundle to retrieve pipelines for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundlePipelineApi
     */
    BundlePipelineApi.prototype.getBundlePipelines = function (bundleId, options) {
        var _this = this;
        return (0, exports.BundlePipelineApiFp)(this.configuration).getBundlePipelines(bundleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Link a pipeline to a bundle.
     * @param {string} bundleId The ID of the bundle
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundlePipelineApi
     */
    BundlePipelineApi.prototype.linkPipelineToBundle = function (bundleId, pipelineId, options) {
        var _this = this;
        return (0, exports.BundlePipelineApiFp)(this.configuration).linkPipelineToBundle(bundleId, pipelineId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Unlink a pipeline from a bundle.
     * @param {string} bundleId The ID of the bundle
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundlePipelineApi
     */
    BundlePipelineApi.prototype.unlinkPipelineFromBundle = function (bundleId, pipelineId, options) {
        var _this = this;
        return (0, exports.BundlePipelineApiFp)(this.configuration).unlinkPipelineFromBundle(bundleId, pipelineId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return BundlePipelineApi;
}(base_1.BaseAPI));
exports.BundlePipelineApi = BundlePipelineApi;
/**
 * BundleSampleApi - axios parameter creator
 * @export
 */
var BundleSampleApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve a list of bundle samples.
         * @param {string} bundleId The ID of the bundle to get bundle samples from
         * @param {string} [search] To search through multiple fields of data.
         * @param {string} [userTags] The user tags to filter on.
         * @param {string} [technicalTags] The technical tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleSamples: function (bundleId, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('getBundleSamples', 'bundleId', bundleId);
                            localVarPath = "/api/bundles/{bundleId}/samples"
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (search !== undefined) {
                                localVarQueryParameter['search'] = search;
                            }
                            if (userTags !== undefined) {
                                localVarQueryParameter['userTags'] = userTags;
                            }
                            if (technicalTags !== undefined) {
                                localVarQueryParameter['technicalTags'] = technicalTags;
                            }
                            if (pageOffset !== undefined) {
                                localVarQueryParameter['pageOffset'] = pageOffset;
                            }
                            if (pageToken !== undefined) {
                                localVarQueryParameter['pageToken'] = pageToken;
                            }
                            if (pageSize !== undefined) {
                                localVarQueryParameter['pageSize'] = pageSize;
                            }
                            if (sort !== undefined) {
                                localVarQueryParameter['sort'] = sort;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Link a sample to a bundle.
         * @param {string} bundleId
         * @param {string} sampleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkSampleToBundle: function (bundleId, sampleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('linkSampleToBundle', 'bundleId', bundleId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('linkSampleToBundle', 'sampleId', sampleId);
                            localVarPath = "/api/bundles/{bundleId}/samples/{sampleId}"
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink a sample from a bundle.
         * @param {string} bundleId
         * @param {string} sampleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkSampleFromBundle: function (bundleId, sampleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkSampleFromBundle', 'bundleId', bundleId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkSampleFromBundle', 'sampleId', sampleId);
                            localVarPath = "/api/bundles/{bundleId}/samples/{sampleId}"
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.BundleSampleApiAxiosParamCreator = BundleSampleApiAxiosParamCreator;
/**
 * BundleSampleApi - functional programming interface
 * @export
 */
var BundleSampleApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.BundleSampleApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve a list of bundle samples.
         * @param {string} bundleId The ID of the bundle to get bundle samples from
         * @param {string} [search] To search through multiple fields of data.
         * @param {string} [userTags] The user tags to filter on.
         * @param {string} [technicalTags] The technical tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleSamples: function (bundleId, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getBundleSamples(bundleId, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Link a sample to a bundle.
         * @param {string} bundleId
         * @param {string} sampleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkSampleToBundle: function (bundleId, sampleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.linkSampleToBundle(bundleId, sampleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink a sample from a bundle.
         * @param {string} bundleId
         * @param {string} sampleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkSampleFromBundle: function (bundleId, sampleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unlinkSampleFromBundle(bundleId, sampleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.BundleSampleApiFp = BundleSampleApiFp;
/**
 * BundleSampleApi - factory interface
 * @export
 */
var BundleSampleApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.BundleSampleApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve a list of bundle samples.
         * @param {string} bundleId The ID of the bundle to get bundle samples from
         * @param {string} [search] To search through multiple fields of data.
         * @param {string} [userTags] The user tags to filter on.
         * @param {string} [technicalTags] The technical tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleSamples: function (bundleId, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options) {
            return localVarFp.getBundleSamples(bundleId, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Link a sample to a bundle.
         * @param {string} bundleId
         * @param {string} sampleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkSampleToBundle: function (bundleId, sampleId, options) {
            return localVarFp.linkSampleToBundle(bundleId, sampleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Unlink a sample from a bundle.
         * @param {string} bundleId
         * @param {string} sampleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkSampleFromBundle: function (bundleId, sampleId, options) {
            return localVarFp.unlinkSampleFromBundle(bundleId, sampleId, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.BundleSampleApiFactory = BundleSampleApiFactory;
/**
 * BundleSampleApi - object-oriented interface
 * @export
 * @class BundleSampleApi
 * @extends {BaseAPI}
 */
var BundleSampleApi = /** @class */ (function (_super) {
    __extends(BundleSampleApi, _super);
    function BundleSampleApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve a list of bundle samples.
     * @param {string} bundleId The ID of the bundle to get bundle samples from
     * @param {string} [search] To search through multiple fields of data.
     * @param {string} [userTags] The user tags to filter on.
     * @param {string} [technicalTags] The technical tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleSampleApi
     */
    BundleSampleApi.prototype.getBundleSamples = function (bundleId, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options) {
        var _this = this;
        return (0, exports.BundleSampleApiFp)(this.configuration).getBundleSamples(bundleId, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Link a sample to a bundle.
     * @param {string} bundleId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleSampleApi
     */
    BundleSampleApi.prototype.linkSampleToBundle = function (bundleId, sampleId, options) {
        var _this = this;
        return (0, exports.BundleSampleApiFp)(this.configuration).linkSampleToBundle(bundleId, sampleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Unlink a sample from a bundle.
     * @param {string} bundleId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleSampleApi
     */
    BundleSampleApi.prototype.unlinkSampleFromBundle = function (bundleId, sampleId, options) {
        var _this = this;
        return (0, exports.BundleSampleApiFp)(this.configuration).unlinkSampleFromBundle(bundleId, sampleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return BundleSampleApi;
}(base_1.BaseAPI));
exports.BundleSampleApi = BundleSampleApi;
/**
 * BundleToolApi - axios parameter creator
 * @export
 */
var BundleToolApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve a list of bundle tools.
         * @param {string} bundleId The ID of the bundle to get tools from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleTools: function (bundleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('getBundleTools', 'bundleId', bundleId);
                            localVarPath = "/api/bundles/{bundleId}/tools"
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of tools eligible for linking to the bundle.
         * @param {string} bundleId The ID of the bundle to get the eligible tools for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolsEligibleForLinkingToBundle: function (bundleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('getToolsEligibleForLinkingToBundle', 'bundleId', bundleId);
                            localVarPath = "/api/bundles/{bundleId}/tools/eligibleForLinking"
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Link a tool to a bundle
         * @param {string} bundleId The ID of the bundle to link the tool to
         * @param {string} toolId The ID of the tool to link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkToolToBundle: function (bundleId, toolId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('linkToolToBundle', 'bundleId', bundleId);
                            // verify required parameter 'toolId' is not null or undefined
                            (0, common_1.assertParamExists)('linkToolToBundle', 'toolId', toolId);
                            localVarPath = "/api/bundles/{bundleId}/tools/{toolId}"
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)))
                                .replace("{".concat("toolId", "}"), encodeURIComponent(String(toolId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink a tool from this bundle.
         * @param {string} bundleId
         * @param {string} toolId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkToolFromBundle: function (bundleId, toolId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkToolFromBundle', 'bundleId', bundleId);
                            // verify required parameter 'toolId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkToolFromBundle', 'toolId', toolId);
                            localVarPath = "/api/bundles/{bundleId}/tools/{toolId}"
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)))
                                .replace("{".concat("toolId", "}"), encodeURIComponent(String(toolId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.BundleToolApiAxiosParamCreator = BundleToolApiAxiosParamCreator;
/**
 * BundleToolApi - functional programming interface
 * @export
 */
var BundleToolApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.BundleToolApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve a list of bundle tools.
         * @param {string} bundleId The ID of the bundle to get tools from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleTools: function (bundleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getBundleTools(bundleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of tools eligible for linking to the bundle.
         * @param {string} bundleId The ID of the bundle to get the eligible tools for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolsEligibleForLinkingToBundle: function (bundleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getToolsEligibleForLinkingToBundle(bundleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Link a tool to a bundle
         * @param {string} bundleId The ID of the bundle to link the tool to
         * @param {string} toolId The ID of the tool to link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkToolToBundle: function (bundleId, toolId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.linkToolToBundle(bundleId, toolId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink a tool from this bundle.
         * @param {string} bundleId
         * @param {string} toolId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkToolFromBundle: function (bundleId, toolId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unlinkToolFromBundle(bundleId, toolId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.BundleToolApiFp = BundleToolApiFp;
/**
 * BundleToolApi - factory interface
 * @export
 */
var BundleToolApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.BundleToolApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve a list of bundle tools.
         * @param {string} bundleId The ID of the bundle to get tools from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleTools: function (bundleId, options) {
            return localVarFp.getBundleTools(bundleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of tools eligible for linking to the bundle.
         * @param {string} bundleId The ID of the bundle to get the eligible tools for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolsEligibleForLinkingToBundle: function (bundleId, options) {
            return localVarFp.getToolsEligibleForLinkingToBundle(bundleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Link a tool to a bundle
         * @param {string} bundleId The ID of the bundle to link the tool to
         * @param {string} toolId The ID of the tool to link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkToolToBundle: function (bundleId, toolId, options) {
            return localVarFp.linkToolToBundle(bundleId, toolId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Unlink a tool from this bundle.
         * @param {string} bundleId
         * @param {string} toolId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkToolFromBundle: function (bundleId, toolId, options) {
            return localVarFp.unlinkToolFromBundle(bundleId, toolId, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.BundleToolApiFactory = BundleToolApiFactory;
/**
 * BundleToolApi - object-oriented interface
 * @export
 * @class BundleToolApi
 * @extends {BaseAPI}
 */
var BundleToolApi = /** @class */ (function (_super) {
    __extends(BundleToolApi, _super);
    function BundleToolApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve a list of bundle tools.
     * @param {string} bundleId The ID of the bundle to get tools from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleToolApi
     */
    BundleToolApi.prototype.getBundleTools = function (bundleId, options) {
        var _this = this;
        return (0, exports.BundleToolApiFp)(this.configuration).getBundleTools(bundleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of tools eligible for linking to the bundle.
     * @param {string} bundleId The ID of the bundle to get the eligible tools for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleToolApi
     */
    BundleToolApi.prototype.getToolsEligibleForLinkingToBundle = function (bundleId, options) {
        var _this = this;
        return (0, exports.BundleToolApiFp)(this.configuration).getToolsEligibleForLinkingToBundle(bundleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Link a tool to a bundle
     * @param {string} bundleId The ID of the bundle to link the tool to
     * @param {string} toolId The ID of the tool to link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleToolApi
     */
    BundleToolApi.prototype.linkToolToBundle = function (bundleId, toolId, options) {
        var _this = this;
        return (0, exports.BundleToolApiFp)(this.configuration).linkToolToBundle(bundleId, toolId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Unlink a tool from this bundle.
     * @param {string} bundleId
     * @param {string} toolId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleToolApi
     */
    BundleToolApi.prototype.unlinkToolFromBundle = function (bundleId, toolId, options) {
        var _this = this;
        return (0, exports.BundleToolApiFp)(this.configuration).unlinkToolFromBundle(bundleId, toolId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return BundleToolApi;
}(base_1.BaseAPI));
exports.BundleToolApi = BundleToolApi;
/**
 * ConnectorApi - axios parameter creator
 * @export
 */
var ConnectorApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Endpoint for cancelling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Cancel a connector.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelConnector: function (connectorId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'connectorId' is not null or undefined
                            (0, common_1.assertParamExists)('cancelConnector', 'connectorId', connectorId);
                            localVarPath = "/api/connectors/{connectorId}:cancel"
                                .replace("{".concat("connectorId", "}"), encodeURIComponent(String(connectorId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Create a connector.
         * @param {CreateConnector} [createConnector] The connector to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnector: function (createConnector, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/connectors";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createConnector, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Create a download rule.
         * @param {string} connectorId
         * @param {CreateDownloadRule} [createDownloadRule]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDownloadRule: function (connectorId, createDownloadRule, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'connectorId' is not null or undefined
                            (0, common_1.assertParamExists)('createDownloadRule', 'connectorId', connectorId);
                            localVarPath = "/api/connectors/{connectorId}/downloadRules"
                                .replace("{".concat("connectorId", "}"), encodeURIComponent(String(connectorId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createDownloadRule, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Create an upload rule.
         * @param {string} connectorId
         * @param {CreateUploadRule} [createUploadRule]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUploadRule: function (connectorId, createUploadRule, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'connectorId' is not null or undefined
                            (0, common_1.assertParamExists)('createUploadRule', 'connectorId', connectorId);
                            localVarPath = "/api/connectors/{connectorId}/uploadRules"
                                .replace("{".concat("connectorId", "}"), encodeURIComponent(String(connectorId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createUploadRule, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Delete a download rule.
         * @param {string} connectorId
         * @param {string} downloadRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDownloadRule: function (connectorId, downloadRuleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'connectorId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteDownloadRule', 'connectorId', connectorId);
                            // verify required parameter 'downloadRuleId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteDownloadRule', 'downloadRuleId', downloadRuleId);
                            localVarPath = "/api/connectors/{connectorId}/downloadRules/{downloadRuleId}"
                                .replace("{".concat("connectorId", "}"), encodeURIComponent(String(connectorId)))
                                .replace("{".concat("downloadRuleId", "}"), encodeURIComponent(String(downloadRuleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Delete an upload rule.
         * @param {string} connectorId
         * @param {string} uploadRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUploadRule: function (connectorId, uploadRuleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'connectorId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteUploadRule', 'connectorId', connectorId);
                            // verify required parameter 'uploadRuleId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteUploadRule', 'uploadRuleId', uploadRuleId);
                            localVarPath = "/api/connectors/{connectorId}/uploadRules/{uploadRuleId}"
                                .replace("{".concat("connectorId", "}"), encodeURIComponent(String(connectorId)))
                                .replace("{".concat("uploadRuleId", "}"), encodeURIComponent(String(uploadRuleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint for disabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Disable a connector.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableConnector: function (connectorId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'connectorId' is not null or undefined
                            (0, common_1.assertParamExists)('disableConnector', 'connectorId', connectorId);
                            localVarPath = "/api/connectors/{connectorId}:disable"
                                .replace("{".concat("connectorId", "}"), encodeURIComponent(String(connectorId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint for enabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Enable a connector.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableConnector: function (connectorId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'connectorId' is not null or undefined
                            (0, common_1.assertParamExists)('enableConnector', 'connectorId', connectorId);
                            localVarPath = "/api/connectors/{connectorId}:enable"
                                .replace("{".concat("connectorId", "}"), encodeURIComponent(String(connectorId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a connector.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnector: function (connectorId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'connectorId' is not null or undefined
                            (0, common_1.assertParamExists)('getConnector', 'connectorId', connectorId);
                            localVarPath = "/api/connectors/{connectorId}"
                                .replace("{".concat("connectorId", "}"), encodeURIComponent(String(connectorId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of connectors.
         * @param {boolean} [activeOnly] When true only the active connectors will be returned. When false (default value) all connectors wil be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors: function (activeOnly, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/connectors";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (activeOnly !== undefined) {
                                localVarQueryParameter['activeOnly'] = activeOnly;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a download rule.
         * @param {string} connectorId
         * @param {string} downloadRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadRule: function (connectorId, downloadRuleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'connectorId' is not null or undefined
                            (0, common_1.assertParamExists)('getDownloadRule', 'connectorId', connectorId);
                            // verify required parameter 'downloadRuleId' is not null or undefined
                            (0, common_1.assertParamExists)('getDownloadRule', 'downloadRuleId', downloadRuleId);
                            localVarPath = "/api/connectors/{connectorId}/downloadRules/{downloadRuleId}"
                                .replace("{".concat("connectorId", "}"), encodeURIComponent(String(connectorId)))
                                .replace("{".concat("downloadRuleId", "}"), encodeURIComponent(String(downloadRuleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of download rules.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadRules: function (connectorId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'connectorId' is not null or undefined
                            (0, common_1.assertParamExists)('getDownloadRules', 'connectorId', connectorId);
                            localVarPath = "/api/connectors/{connectorId}/downloadRules"
                                .replace("{".concat("connectorId", "}"), encodeURIComponent(String(connectorId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve an upload rule.
         * @param {string} connectorId
         * @param {string} uploadRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadRule: function (connectorId, uploadRuleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'connectorId' is not null or undefined
                            (0, common_1.assertParamExists)('getUploadRule', 'connectorId', connectorId);
                            // verify required parameter 'uploadRuleId' is not null or undefined
                            (0, common_1.assertParamExists)('getUploadRule', 'uploadRuleId', uploadRuleId);
                            localVarPath = "/api/connectors/{connectorId}/uploadRules/{uploadRuleId}"
                                .replace("{".concat("connectorId", "}"), encodeURIComponent(String(connectorId)))
                                .replace("{".concat("uploadRuleId", "}"), encodeURIComponent(String(uploadRuleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of upload rules.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadRules: function (connectorId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'connectorId' is not null or undefined
                            (0, common_1.assertParamExists)('getUploadRules', 'connectorId', connectorId);
                            localVarPath = "/api/connectors/{connectorId}/uploadRules"
                                .replace("{".concat("connectorId", "}"), encodeURIComponent(String(connectorId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Fields which can be updated:  - code  - active  - description  - sequence  - formatCode  - projectName  - targetLocalFolder  - protocol  - fileNameExpression  - disableHashing
         * @summary Update a download rule.
         * @param {string} connectorId
         * @param {string} downloadRuleId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {DownloadRule} [downloadRule]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDownloadRule: function (connectorId, downloadRuleId, ifMatch, downloadRule, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'connectorId' is not null or undefined
                            (0, common_1.assertParamExists)('updateDownloadRule', 'connectorId', connectorId);
                            // verify required parameter 'downloadRuleId' is not null or undefined
                            (0, common_1.assertParamExists)('updateDownloadRule', 'downloadRuleId', downloadRuleId);
                            localVarPath = "/api/connectors/{connectorId}/downloadRules/{downloadRuleId}"
                                .replace("{".concat("connectorId", "}"), encodeURIComponent(String(connectorId)))
                                .replace("{".concat("downloadRuleId", "}"), encodeURIComponent(String(downloadRuleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (ifMatch !== undefined && ifMatch !== null) {
                                localVarHeaderParameter['If-Match'] = String(ifMatch);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(downloadRule, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Fields which can be updated:  - code  - active  - description  - localFolder  - filePattern  - dataFormat
         * @summary Update an upload rule.
         * @param {string} connectorId
         * @param {string} uploadRuleId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {UploadRule} [uploadRule]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUploadRule: function (connectorId, uploadRuleId, ifMatch, uploadRule, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'connectorId' is not null or undefined
                            (0, common_1.assertParamExists)('updateUploadRule', 'connectorId', connectorId);
                            // verify required parameter 'uploadRuleId' is not null or undefined
                            (0, common_1.assertParamExists)('updateUploadRule', 'uploadRuleId', uploadRuleId);
                            localVarPath = "/api/connectors/{connectorId}/uploadRules/{uploadRuleId}"
                                .replace("{".concat("connectorId", "}"), encodeURIComponent(String(connectorId)))
                                .replace("{".concat("uploadRuleId", "}"), encodeURIComponent(String(uploadRuleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (ifMatch !== undefined && ifMatch !== null) {
                                localVarHeaderParameter['If-Match'] = String(ifMatch);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(uploadRule, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ConnectorApiAxiosParamCreator = ConnectorApiAxiosParamCreator;
/**
 * ConnectorApi - functional programming interface
 * @export
 */
var ConnectorApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ConnectorApiAxiosParamCreator)(configuration);
    return {
        /**
         * Endpoint for cancelling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Cancel a connector.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelConnector: function (connectorId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.cancelConnector(connectorId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Create a connector.
         * @param {CreateConnector} [createConnector] The connector to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnector: function (createConnector, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createConnector(createConnector, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Create a download rule.
         * @param {string} connectorId
         * @param {CreateDownloadRule} [createDownloadRule]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDownloadRule: function (connectorId, createDownloadRule, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createDownloadRule(connectorId, createDownloadRule, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Create an upload rule.
         * @param {string} connectorId
         * @param {CreateUploadRule} [createUploadRule]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUploadRule: function (connectorId, createUploadRule, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createUploadRule(connectorId, createUploadRule, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Delete a download rule.
         * @param {string} connectorId
         * @param {string} downloadRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDownloadRule: function (connectorId, downloadRuleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteDownloadRule(connectorId, downloadRuleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Delete an upload rule.
         * @param {string} connectorId
         * @param {string} uploadRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUploadRule: function (connectorId, uploadRuleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteUploadRule(connectorId, uploadRuleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint for disabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Disable a connector.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableConnector: function (connectorId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.disableConnector(connectorId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint for enabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Enable a connector.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableConnector: function (connectorId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.enableConnector(connectorId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a connector.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnector: function (connectorId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getConnector(connectorId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of connectors.
         * @param {boolean} [activeOnly] When true only the active connectors will be returned. When false (default value) all connectors wil be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors: function (activeOnly, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getConnectors(activeOnly, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a download rule.
         * @param {string} connectorId
         * @param {string} downloadRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadRule: function (connectorId, downloadRuleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getDownloadRule(connectorId, downloadRuleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of download rules.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadRules: function (connectorId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getDownloadRules(connectorId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve an upload rule.
         * @param {string} connectorId
         * @param {string} uploadRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadRule: function (connectorId, uploadRuleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getUploadRule(connectorId, uploadRuleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of upload rules.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadRules: function (connectorId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getUploadRules(connectorId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fields which can be updated:  - code  - active  - description  - sequence  - formatCode  - projectName  - targetLocalFolder  - protocol  - fileNameExpression  - disableHashing
         * @summary Update a download rule.
         * @param {string} connectorId
         * @param {string} downloadRuleId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {DownloadRule} [downloadRule]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDownloadRule: function (connectorId, downloadRuleId, ifMatch, downloadRule, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateDownloadRule(connectorId, downloadRuleId, ifMatch, downloadRule, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fields which can be updated:  - code  - active  - description  - localFolder  - filePattern  - dataFormat
         * @summary Update an upload rule.
         * @param {string} connectorId
         * @param {string} uploadRuleId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {UploadRule} [uploadRule]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUploadRule: function (connectorId, uploadRuleId, ifMatch, uploadRule, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateUploadRule(connectorId, uploadRuleId, ifMatch, uploadRule, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ConnectorApiFp = ConnectorApiFp;
/**
 * ConnectorApi - factory interface
 * @export
 */
var ConnectorApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ConnectorApiFp)(configuration);
    return {
        /**
         * Endpoint for cancelling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Cancel a connector.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelConnector: function (connectorId, options) {
            return localVarFp.cancelConnector(connectorId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Create a connector.
         * @param {CreateConnector} [createConnector] The connector to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnector: function (createConnector, options) {
            return localVarFp.createConnector(createConnector, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Create a download rule.
         * @param {string} connectorId
         * @param {CreateDownloadRule} [createDownloadRule]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDownloadRule: function (connectorId, createDownloadRule, options) {
            return localVarFp.createDownloadRule(connectorId, createDownloadRule, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Create an upload rule.
         * @param {string} connectorId
         * @param {CreateUploadRule} [createUploadRule]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUploadRule: function (connectorId, createUploadRule, options) {
            return localVarFp.createUploadRule(connectorId, createUploadRule, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Delete a download rule.
         * @param {string} connectorId
         * @param {string} downloadRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDownloadRule: function (connectorId, downloadRuleId, options) {
            return localVarFp.deleteDownloadRule(connectorId, downloadRuleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Delete an upload rule.
         * @param {string} connectorId
         * @param {string} uploadRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUploadRule: function (connectorId, uploadRuleId, options) {
            return localVarFp.deleteUploadRule(connectorId, uploadRuleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint for disabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Disable a connector.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableConnector: function (connectorId, options) {
            return localVarFp.disableConnector(connectorId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint for enabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Enable a connector.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableConnector: function (connectorId, options) {
            return localVarFp.enableConnector(connectorId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a connector.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnector: function (connectorId, options) {
            return localVarFp.getConnector(connectorId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of connectors.
         * @param {boolean} [activeOnly] When true only the active connectors will be returned. When false (default value) all connectors wil be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors: function (activeOnly, options) {
            return localVarFp.getConnectors(activeOnly, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a download rule.
         * @param {string} connectorId
         * @param {string} downloadRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadRule: function (connectorId, downloadRuleId, options) {
            return localVarFp.getDownloadRule(connectorId, downloadRuleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of download rules.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadRules: function (connectorId, options) {
            return localVarFp.getDownloadRules(connectorId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve an upload rule.
         * @param {string} connectorId
         * @param {string} uploadRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadRule: function (connectorId, uploadRuleId, options) {
            return localVarFp.getUploadRule(connectorId, uploadRuleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of upload rules.
         * @param {string} connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadRules: function (connectorId, options) {
            return localVarFp.getUploadRules(connectorId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fields which can be updated:  - code  - active  - description  - sequence  - formatCode  - projectName  - targetLocalFolder  - protocol  - fileNameExpression  - disableHashing
         * @summary Update a download rule.
         * @param {string} connectorId
         * @param {string} downloadRuleId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {DownloadRule} [downloadRule]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDownloadRule: function (connectorId, downloadRuleId, ifMatch, downloadRule, options) {
            return localVarFp.updateDownloadRule(connectorId, downloadRuleId, ifMatch, downloadRule, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fields which can be updated:  - code  - active  - description  - localFolder  - filePattern  - dataFormat
         * @summary Update an upload rule.
         * @param {string} connectorId
         * @param {string} uploadRuleId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {UploadRule} [uploadRule]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUploadRule: function (connectorId, uploadRuleId, ifMatch, uploadRule, options) {
            return localVarFp.updateUploadRule(connectorId, uploadRuleId, ifMatch, uploadRule, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ConnectorApiFactory = ConnectorApiFactory;
/**
 * ConnectorApi - object-oriented interface
 * @export
 * @class ConnectorApi
 * @extends {BaseAPI}
 */
var ConnectorApi = /** @class */ (function (_super) {
    __extends(ConnectorApi, _super);
    function ConnectorApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Endpoint for cancelling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Cancel a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    ConnectorApi.prototype.cancelConnector = function (connectorId, options) {
        var _this = this;
        return (0, exports.ConnectorApiFp)(this.configuration).cancelConnector(connectorId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Create a connector.
     * @param {CreateConnector} [createConnector] The connector to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    ConnectorApi.prototype.createConnector = function (createConnector, options) {
        var _this = this;
        return (0, exports.ConnectorApiFp)(this.configuration).createConnector(createConnector, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Create a download rule.
     * @param {string} connectorId
     * @param {CreateDownloadRule} [createDownloadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    ConnectorApi.prototype.createDownloadRule = function (connectorId, createDownloadRule, options) {
        var _this = this;
        return (0, exports.ConnectorApiFp)(this.configuration).createDownloadRule(connectorId, createDownloadRule, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Create an upload rule.
     * @param {string} connectorId
     * @param {CreateUploadRule} [createUploadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    ConnectorApi.prototype.createUploadRule = function (connectorId, createUploadRule, options) {
        var _this = this;
        return (0, exports.ConnectorApiFp)(this.configuration).createUploadRule(connectorId, createUploadRule, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Delete a download rule.
     * @param {string} connectorId
     * @param {string} downloadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    ConnectorApi.prototype.deleteDownloadRule = function (connectorId, downloadRuleId, options) {
        var _this = this;
        return (0, exports.ConnectorApiFp)(this.configuration).deleteDownloadRule(connectorId, downloadRuleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Delete an upload rule.
     * @param {string} connectorId
     * @param {string} uploadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    ConnectorApi.prototype.deleteUploadRule = function (connectorId, uploadRuleId, options) {
        var _this = this;
        return (0, exports.ConnectorApiFp)(this.configuration).deleteUploadRule(connectorId, uploadRuleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint for disabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Disable a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    ConnectorApi.prototype.disableConnector = function (connectorId, options) {
        var _this = this;
        return (0, exports.ConnectorApiFp)(this.configuration).disableConnector(connectorId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint for enabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Enable a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    ConnectorApi.prototype.enableConnector = function (connectorId, options) {
        var _this = this;
        return (0, exports.ConnectorApiFp)(this.configuration).enableConnector(connectorId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a connector.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    ConnectorApi.prototype.getConnector = function (connectorId, options) {
        var _this = this;
        return (0, exports.ConnectorApiFp)(this.configuration).getConnector(connectorId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of connectors.
     * @param {boolean} [activeOnly] When true only the active connectors will be returned. When false (default value) all connectors wil be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    ConnectorApi.prototype.getConnectors = function (activeOnly, options) {
        var _this = this;
        return (0, exports.ConnectorApiFp)(this.configuration).getConnectors(activeOnly, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a download rule.
     * @param {string} connectorId
     * @param {string} downloadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    ConnectorApi.prototype.getDownloadRule = function (connectorId, downloadRuleId, options) {
        var _this = this;
        return (0, exports.ConnectorApiFp)(this.configuration).getDownloadRule(connectorId, downloadRuleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of download rules.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    ConnectorApi.prototype.getDownloadRules = function (connectorId, options) {
        var _this = this;
        return (0, exports.ConnectorApiFp)(this.configuration).getDownloadRules(connectorId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve an upload rule.
     * @param {string} connectorId
     * @param {string} uploadRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    ConnectorApi.prototype.getUploadRule = function (connectorId, uploadRuleId, options) {
        var _this = this;
        return (0, exports.ConnectorApiFp)(this.configuration).getUploadRule(connectorId, uploadRuleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of upload rules.
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    ConnectorApi.prototype.getUploadRules = function (connectorId, options) {
        var _this = this;
        return (0, exports.ConnectorApiFp)(this.configuration).getUploadRules(connectorId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fields which can be updated:  - code  - active  - description  - sequence  - formatCode  - projectName  - targetLocalFolder  - protocol  - fileNameExpression  - disableHashing
     * @summary Update a download rule.
     * @param {string} connectorId
     * @param {string} downloadRuleId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {DownloadRule} [downloadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    ConnectorApi.prototype.updateDownloadRule = function (connectorId, downloadRuleId, ifMatch, downloadRule, options) {
        var _this = this;
        return (0, exports.ConnectorApiFp)(this.configuration).updateDownloadRule(connectorId, downloadRuleId, ifMatch, downloadRule, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fields which can be updated:  - code  - active  - description  - localFolder  - filePattern  - dataFormat
     * @summary Update an upload rule.
     * @param {string} connectorId
     * @param {string} uploadRuleId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {UploadRule} [uploadRule]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    ConnectorApi.prototype.updateUploadRule = function (connectorId, uploadRuleId, ifMatch, uploadRule, options) {
        var _this = this;
        return (0, exports.ConnectorApiFp)(this.configuration).updateUploadRule(connectorId, uploadRuleId, ifMatch, uploadRule, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ConnectorApi;
}(base_1.BaseAPI));
exports.ConnectorApi = ConnectorApi;
/**
 * DataFormatApi - axios parameter creator
 * @export
 */
var DataFormatApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve a list of data formats.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataFormats: function (pageOffset, pageToken, pageSize, sort, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/dataFormats";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (pageOffset !== undefined) {
                                localVarQueryParameter['pageOffset'] = pageOffset;
                            }
                            if (pageToken !== undefined) {
                                localVarQueryParameter['pageToken'] = pageToken;
                            }
                            if (pageSize !== undefined) {
                                localVarQueryParameter['pageSize'] = pageSize;
                            }
                            if (sort !== undefined) {
                                localVarQueryParameter['sort'] = sort;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.DataFormatApiAxiosParamCreator = DataFormatApiAxiosParamCreator;
/**
 * DataFormatApi - functional programming interface
 * @export
 */
var DataFormatApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.DataFormatApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve a list of data formats.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataFormats: function (pageOffset, pageToken, pageSize, sort, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getDataFormats(pageOffset, pageToken, pageSize, sort, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.DataFormatApiFp = DataFormatApiFp;
/**
 * DataFormatApi - factory interface
 * @export
 */
var DataFormatApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.DataFormatApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve a list of data formats.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataFormats: function (pageOffset, pageToken, pageSize, sort, options) {
            return localVarFp.getDataFormats(pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.DataFormatApiFactory = DataFormatApiFactory;
/**
 * DataFormatApi - object-oriented interface
 * @export
 * @class DataFormatApi
 * @extends {BaseAPI}
 */
var DataFormatApi = /** @class */ (function (_super) {
    __extends(DataFormatApi, _super);
    function DataFormatApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve a list of data formats.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFormatApi
     */
    DataFormatApi.prototype.getDataFormats = function (pageOffset, pageToken, pageSize, sort, options) {
        var _this = this;
        return (0, exports.DataFormatApiFp)(this.configuration).getDataFormats(pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return DataFormatApi;
}(base_1.BaseAPI));
exports.DataFormatApi = DataFormatApi;
/**
 * EntitledBundleApi - axios parameter creator
 * @export
 */
var EntitledBundleApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve an entitled bundle.
         * @param {string} entitledBundleId The ID of the entitled bundle to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitledBundle: function (entitledBundleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'entitledBundleId' is not null or undefined
                            (0, common_1.assertParamExists)('getEntitledBundle', 'entitledBundleId', entitledBundleId);
                            localVarPath = "/api/entitledbundles/{entitledBundleId}"
                                .replace("{".concat("entitledBundleId", "}"), encodeURIComponent(String(entitledBundleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of entitled bundles.
         * @param {string} [search] Search
         * @param {string} [userTags] User tags to filter on
         * @param {string} [technicalTags] Technical tags to filter on
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitledBundles: function (search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/entitledbundles";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (search !== undefined) {
                                localVarQueryParameter['search'] = search;
                            }
                            if (userTags !== undefined) {
                                localVarQueryParameter['userTags'] = userTags;
                            }
                            if (technicalTags !== undefined) {
                                localVarQueryParameter['technicalTags'] = technicalTags;
                            }
                            if (pageOffset !== undefined) {
                                localVarQueryParameter['pageOffset'] = pageOffset;
                            }
                            if (pageToken !== undefined) {
                                localVarQueryParameter['pageToken'] = pageToken;
                            }
                            if (pageSize !== undefined) {
                                localVarQueryParameter['pageSize'] = pageSize;
                            }
                            if (sort !== undefined) {
                                localVarQueryParameter['sort'] = sort;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.EntitledBundleApiAxiosParamCreator = EntitledBundleApiAxiosParamCreator;
/**
 * EntitledBundleApi - functional programming interface
 * @export
 */
var EntitledBundleApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.EntitledBundleApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve an entitled bundle.
         * @param {string} entitledBundleId The ID of the entitled bundle to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitledBundle: function (entitledBundleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getEntitledBundle(entitledBundleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of entitled bundles.
         * @param {string} [search] Search
         * @param {string} [userTags] User tags to filter on
         * @param {string} [technicalTags] Technical tags to filter on
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitledBundles: function (search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getEntitledBundles(search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.EntitledBundleApiFp = EntitledBundleApiFp;
/**
 * EntitledBundleApi - factory interface
 * @export
 */
var EntitledBundleApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.EntitledBundleApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve an entitled bundle.
         * @param {string} entitledBundleId The ID of the entitled bundle to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitledBundle: function (entitledBundleId, options) {
            return localVarFp.getEntitledBundle(entitledBundleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of entitled bundles.
         * @param {string} [search] Search
         * @param {string} [userTags] User tags to filter on
         * @param {string} [technicalTags] Technical tags to filter on
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitledBundles: function (search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options) {
            return localVarFp.getEntitledBundles(search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.EntitledBundleApiFactory = EntitledBundleApiFactory;
/**
 * EntitledBundleApi - object-oriented interface
 * @export
 * @class EntitledBundleApi
 * @extends {BaseAPI}
 */
var EntitledBundleApi = /** @class */ (function (_super) {
    __extends(EntitledBundleApi, _super);
    function EntitledBundleApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve an entitled bundle.
     * @param {string} entitledBundleId The ID of the entitled bundle to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitledBundleApi
     */
    EntitledBundleApi.prototype.getEntitledBundle = function (entitledBundleId, options) {
        var _this = this;
        return (0, exports.EntitledBundleApiFp)(this.configuration).getEntitledBundle(entitledBundleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of entitled bundles.
     * @param {string} [search] Search
     * @param {string} [userTags] User tags to filter on
     * @param {string} [technicalTags] Technical tags to filter on
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitledBundleApi
     */
    EntitledBundleApi.prototype.getEntitledBundles = function (search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options) {
        var _this = this;
        return (0, exports.EntitledBundleApiFp)(this.configuration).getEntitledBundles(search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return EntitledBundleApi;
}(base_1.BaseAPI));
exports.EntitledBundleApi = EntitledBundleApi;
/**
 * EntitlementDetailApi - axios parameter creator
 * @export
 */
var EntitlementDetailApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Endpoint for searching all matching activation code details for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search all matching activation code details for a Cwl pipeline.
         * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatchingActivationCodesForCwl: function (searchMatchingActivationCodesForCwlAnalysis, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/activationCodes:findAllMatchingForCwl";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(searchMatchingActivationCodesForCwlAnalysis, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint for searching all matching activation code details for a project and an analysis from a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search all matching activation code details for a Nextflow pipeline.
         * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatchingActivationCodesForNextflow: function (searchMatchingActivationCodesForNextflowAnalysis, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/activationCodes:findAllMatchingForNextflow";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(searchMatchingActivationCodesForNextflowAnalysis, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint for searching the best activation code detail for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search the best matching activation code detail for Cwl pipeline.
         * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBestMatchingActivationCodeForCwl: function (searchMatchingActivationCodesForCwlAnalysis, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/activationCodes:findBestMatchingForCwl";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(searchMatchingActivationCodesForCwlAnalysis, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint for searching the best activation code details for a project and an analysis for a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search the best matching activation code details for Nextflow pipeline.
         * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBestMatchingActivationCodesForNextflow: function (searchMatchingActivationCodesForNextflowAnalysis, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/activationCodes:findBestMatchingForNextflow";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(searchMatchingActivationCodesForNextflowAnalysis, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.EntitlementDetailApiAxiosParamCreator = EntitlementDetailApiAxiosParamCreator;
/**
 * EntitlementDetailApi - functional programming interface
 * @export
 */
var EntitlementDetailApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.EntitlementDetailApiAxiosParamCreator)(configuration);
    return {
        /**
         * Endpoint for searching all matching activation code details for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search all matching activation code details for a Cwl pipeline.
         * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatchingActivationCodesForCwl: function (searchMatchingActivationCodesForCwlAnalysis, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.findAllMatchingActivationCodesForCwl(searchMatchingActivationCodesForCwlAnalysis, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint for searching all matching activation code details for a project and an analysis from a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search all matching activation code details for a Nextflow pipeline.
         * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatchingActivationCodesForNextflow: function (searchMatchingActivationCodesForNextflowAnalysis, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.findAllMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint for searching the best activation code detail for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search the best matching activation code detail for Cwl pipeline.
         * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBestMatchingActivationCodeForCwl: function (searchMatchingActivationCodesForCwlAnalysis, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.findBestMatchingActivationCodeForCwl(searchMatchingActivationCodesForCwlAnalysis, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint for searching the best activation code details for a project and an analysis for a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search the best matching activation code details for Nextflow pipeline.
         * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBestMatchingActivationCodesForNextflow: function (searchMatchingActivationCodesForNextflowAnalysis, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.findBestMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.EntitlementDetailApiFp = EntitlementDetailApiFp;
/**
 * EntitlementDetailApi - factory interface
 * @export
 */
var EntitlementDetailApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.EntitlementDetailApiFp)(configuration);
    return {
        /**
         * Endpoint for searching all matching activation code details for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search all matching activation code details for a Cwl pipeline.
         * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatchingActivationCodesForCwl: function (searchMatchingActivationCodesForCwlAnalysis, options) {
            return localVarFp.findAllMatchingActivationCodesForCwl(searchMatchingActivationCodesForCwlAnalysis, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint for searching all matching activation code details for a project and an analysis from a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search all matching activation code details for a Nextflow pipeline.
         * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatchingActivationCodesForNextflow: function (searchMatchingActivationCodesForNextflowAnalysis, options) {
            return localVarFp.findAllMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint for searching the best activation code detail for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search the best matching activation code detail for Cwl pipeline.
         * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBestMatchingActivationCodeForCwl: function (searchMatchingActivationCodesForCwlAnalysis, options) {
            return localVarFp.findBestMatchingActivationCodeForCwl(searchMatchingActivationCodesForCwlAnalysis, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint for searching the best activation code details for a project and an analysis for a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search the best matching activation code details for Nextflow pipeline.
         * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBestMatchingActivationCodesForNextflow: function (searchMatchingActivationCodesForNextflowAnalysis, options) {
            return localVarFp.findBestMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.EntitlementDetailApiFactory = EntitlementDetailApiFactory;
/**
 * EntitlementDetailApi - object-oriented interface
 * @export
 * @class EntitlementDetailApi
 * @extends {BaseAPI}
 */
var EntitlementDetailApi = /** @class */ (function (_super) {
    __extends(EntitlementDetailApi, _super);
    function EntitlementDetailApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Endpoint for searching all matching activation code details for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search all matching activation code details for a Cwl pipeline.
     * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementDetailApi
     */
    EntitlementDetailApi.prototype.findAllMatchingActivationCodesForCwl = function (searchMatchingActivationCodesForCwlAnalysis, options) {
        var _this = this;
        return (0, exports.EntitlementDetailApiFp)(this.configuration).findAllMatchingActivationCodesForCwl(searchMatchingActivationCodesForCwlAnalysis, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint for searching all matching activation code details for a project and an analysis from a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search all matching activation code details for a Nextflow pipeline.
     * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementDetailApi
     */
    EntitlementDetailApi.prototype.findAllMatchingActivationCodesForNextflow = function (searchMatchingActivationCodesForNextflowAnalysis, options) {
        var _this = this;
        return (0, exports.EntitlementDetailApiFp)(this.configuration).findAllMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint for searching the best activation code detail for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search the best matching activation code detail for Cwl pipeline.
     * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementDetailApi
     */
    EntitlementDetailApi.prototype.findBestMatchingActivationCodeForCwl = function (searchMatchingActivationCodesForCwlAnalysis, options) {
        var _this = this;
        return (0, exports.EntitlementDetailApiFp)(this.configuration).findBestMatchingActivationCodeForCwl(searchMatchingActivationCodesForCwlAnalysis, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint for searching the best activation code details for a project and an analysis for a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search the best matching activation code details for Nextflow pipeline.
     * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementDetailApi
     */
    EntitlementDetailApi.prototype.findBestMatchingActivationCodesForNextflow = function (searchMatchingActivationCodesForNextflowAnalysis, options) {
        var _this = this;
        return (0, exports.EntitlementDetailApiFp)(this.configuration).findBestMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return EntitlementDetailApi;
}(base_1.BaseAPI));
exports.EntitlementDetailApi = EntitlementDetailApi;
/**
 * EventCodeApi - axios parameter creator
 * @export
 */
var EventCodeApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve event codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventCodes: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/eventCodes";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.EventCodeApiAxiosParamCreator = EventCodeApiAxiosParamCreator;
/**
 * EventCodeApi - functional programming interface
 * @export
 */
var EventCodeApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.EventCodeApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve event codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventCodes: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getEventCodes(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.EventCodeApiFp = EventCodeApiFp;
/**
 * EventCodeApi - factory interface
 * @export
 */
var EventCodeApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.EventCodeApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve event codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventCodes: function (options) {
            return localVarFp.getEventCodes(options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.EventCodeApiFactory = EventCodeApiFactory;
/**
 * EventCodeApi - object-oriented interface
 * @export
 * @class EventCodeApi
 * @extends {BaseAPI}
 */
var EventCodeApi = /** @class */ (function (_super) {
    __extends(EventCodeApi, _super);
    function EventCodeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve event codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventCodeApi
     */
    EventCodeApi.prototype.getEventCodes = function (options) {
        var _this = this;
        return (0, exports.EventCodeApiFp)(this.configuration).getEventCodes(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return EventCodeApi;
}(base_1.BaseAPI));
exports.EventCodeApi = EventCodeApi;
/**
 * EventLogApi - axios parameter creator
 * @export
 */
var EventLogApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve a list of event logs.
         * @param {string} [code] Code
         * @param {'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS'} [codeFilterType] Code filter type
         * @param {'ERROR' | 'WARN' | 'INFO'} [category] Category
         * @param {string} [dateFrom] Date from
         * @param {string} [dateUntil] Date until
         * @param {number} [rows] Amount of rows to fetch. Maximum 250. Defaults to 250
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventLogs: function (code, codeFilterType, category, dateFrom, dateUntil, rows, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/eventLog";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (code !== undefined) {
                                localVarQueryParameter['code'] = code;
                            }
                            if (codeFilterType !== undefined) {
                                localVarQueryParameter['codeFilterType'] = codeFilterType;
                            }
                            if (category !== undefined) {
                                localVarQueryParameter['category'] = category;
                            }
                            if (dateFrom !== undefined) {
                                localVarQueryParameter['dateFrom'] = dateFrom;
                            }
                            if (dateUntil !== undefined) {
                                localVarQueryParameter['dateUntil'] = dateUntil;
                            }
                            if (rows !== undefined) {
                                localVarQueryParameter['rows'] = rows;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.EventLogApiAxiosParamCreator = EventLogApiAxiosParamCreator;
/**
 * EventLogApi - functional programming interface
 * @export
 */
var EventLogApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.EventLogApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve a list of event logs.
         * @param {string} [code] Code
         * @param {'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS'} [codeFilterType] Code filter type
         * @param {'ERROR' | 'WARN' | 'INFO'} [category] Category
         * @param {string} [dateFrom] Date from
         * @param {string} [dateUntil] Date until
         * @param {number} [rows] Amount of rows to fetch. Maximum 250. Defaults to 250
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventLogs: function (code, codeFilterType, category, dateFrom, dateUntil, rows, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getEventLogs(code, codeFilterType, category, dateFrom, dateUntil, rows, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.EventLogApiFp = EventLogApiFp;
/**
 * EventLogApi - factory interface
 * @export
 */
var EventLogApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.EventLogApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve a list of event logs.
         * @param {string} [code] Code
         * @param {'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS'} [codeFilterType] Code filter type
         * @param {'ERROR' | 'WARN' | 'INFO'} [category] Category
         * @param {string} [dateFrom] Date from
         * @param {string} [dateUntil] Date until
         * @param {number} [rows] Amount of rows to fetch. Maximum 250. Defaults to 250
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventLogs: function (code, codeFilterType, category, dateFrom, dateUntil, rows, options) {
            return localVarFp.getEventLogs(code, codeFilterType, category, dateFrom, dateUntil, rows, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.EventLogApiFactory = EventLogApiFactory;
/**
 * EventLogApi - object-oriented interface
 * @export
 * @class EventLogApi
 * @extends {BaseAPI}
 */
var EventLogApi = /** @class */ (function (_super) {
    __extends(EventLogApi, _super);
    function EventLogApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve a list of event logs.
     * @param {string} [code] Code
     * @param {'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS'} [codeFilterType] Code filter type
     * @param {'ERROR' | 'WARN' | 'INFO'} [category] Category
     * @param {string} [dateFrom] Date from
     * @param {string} [dateUntil] Date until
     * @param {number} [rows] Amount of rows to fetch. Maximum 250. Defaults to 250
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventLogApi
     */
    EventLogApi.prototype.getEventLogs = function (code, codeFilterType, category, dateFrom, dateUntil, rows, options) {
        var _this = this;
        return (0, exports.EventLogApiFp)(this.configuration).getEventLogs(code, codeFilterType, category, dateFrom, dateUntil, rows, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return EventLogApi;
}(base_1.BaseAPI));
exports.EventLogApi = EventLogApi;
/**
 * MetadataModelApi - axios parameter creator
 * @export
 */
var MetadataModelApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve a metadata model. Only metadata models that the user has access to can be retrieved.
         * @param {string} metadataModelId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataModel: function (metadataModelId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'metadataModelId' is not null or undefined
                            (0, common_1.assertParamExists)('getMetadataModel', 'metadataModelId', metadataModelId);
                            localVarPath = "/api/metadataModels/{metadataModelId}"
                                .replace("{".concat("metadataModelId", "}"), encodeURIComponent(String(metadataModelId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the fields of a metadata model. Only metadata models that the user has access to can be retrieved.
         * @param {string} metadataModelId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataModelFields: function (metadataModelId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'metadataModelId' is not null or undefined
                            (0, common_1.assertParamExists)('getMetadataModelFields', 'metadataModelId', metadataModelId);
                            localVarPath = "/api/metadataModels/{metadataModelId}/fields"
                                .replace("{".concat("metadataModelId", "}"), encodeURIComponent(String(metadataModelId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Retrieve the metadata models for the tenant associated to the security context. This call returns a list of metadata models for the tenant in a non-hierarchical way. Instead of a model having a list of child models all models except the root model have a parent model identifier. This can be used to reconstruct the hierarchy.
         * @summary Retrieve the metadata models for the tenant associated to the security context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataModels: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/metadataModels";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Retrieve the tenant model for the tenant associated to the security context. The tenant model is a hierarchical structure where the top level tenant holds a list of child models (which in turn can hold child models).
         * @summary Retrieve the tenant model for the tenant associated to the security context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantModel: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/metadataModels/tenantModel";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.MetadataModelApiAxiosParamCreator = MetadataModelApiAxiosParamCreator;
/**
 * MetadataModelApi - functional programming interface
 * @export
 */
var MetadataModelApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.MetadataModelApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve a metadata model. Only metadata models that the user has access to can be retrieved.
         * @param {string} metadataModelId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataModel: function (metadataModelId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getMetadataModel(metadataModelId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the fields of a metadata model. Only metadata models that the user has access to can be retrieved.
         * @param {string} metadataModelId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataModelFields: function (metadataModelId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getMetadataModelFields(metadataModelId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieve the metadata models for the tenant associated to the security context. This call returns a list of metadata models for the tenant in a non-hierarchical way. Instead of a model having a list of child models all models except the root model have a parent model identifier. This can be used to reconstruct the hierarchy.
         * @summary Retrieve the metadata models for the tenant associated to the security context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataModels: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getMetadataModels(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieve the tenant model for the tenant associated to the security context. The tenant model is a hierarchical structure where the top level tenant holds a list of child models (which in turn can hold child models).
         * @summary Retrieve the tenant model for the tenant associated to the security context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantModel: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getTenantModel(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.MetadataModelApiFp = MetadataModelApiFp;
/**
 * MetadataModelApi - factory interface
 * @export
 */
var MetadataModelApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.MetadataModelApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve a metadata model. Only metadata models that the user has access to can be retrieved.
         * @param {string} metadataModelId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataModel: function (metadataModelId, options) {
            return localVarFp.getMetadataModel(metadataModelId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve the fields of a metadata model. Only metadata models that the user has access to can be retrieved.
         * @param {string} metadataModelId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataModelFields: function (metadataModelId, options) {
            return localVarFp.getMetadataModelFields(metadataModelId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieve the metadata models for the tenant associated to the security context. This call returns a list of metadata models for the tenant in a non-hierarchical way. Instead of a model having a list of child models all models except the root model have a parent model identifier. This can be used to reconstruct the hierarchy.
         * @summary Retrieve the metadata models for the tenant associated to the security context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataModels: function (options) {
            return localVarFp.getMetadataModels(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieve the tenant model for the tenant associated to the security context. The tenant model is a hierarchical structure where the top level tenant holds a list of child models (which in turn can hold child models).
         * @summary Retrieve the tenant model for the tenant associated to the security context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantModel: function (options) {
            return localVarFp.getTenantModel(options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.MetadataModelApiFactory = MetadataModelApiFactory;
/**
 * MetadataModelApi - object-oriented interface
 * @export
 * @class MetadataModelApi
 * @extends {BaseAPI}
 */
var MetadataModelApi = /** @class */ (function (_super) {
    __extends(MetadataModelApi, _super);
    function MetadataModelApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve a metadata model. Only metadata models that the user has access to can be retrieved.
     * @param {string} metadataModelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataModelApi
     */
    MetadataModelApi.prototype.getMetadataModel = function (metadataModelId, options) {
        var _this = this;
        return (0, exports.MetadataModelApiFp)(this.configuration).getMetadataModel(metadataModelId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve the fields of a metadata model. Only metadata models that the user has access to can be retrieved.
     * @param {string} metadataModelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataModelApi
     */
    MetadataModelApi.prototype.getMetadataModelFields = function (metadataModelId, options) {
        var _this = this;
        return (0, exports.MetadataModelApiFp)(this.configuration).getMetadataModelFields(metadataModelId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieve the metadata models for the tenant associated to the security context. This call returns a list of metadata models for the tenant in a non-hierarchical way. Instead of a model having a list of child models all models except the root model have a parent model identifier. This can be used to reconstruct the hierarchy.
     * @summary Retrieve the metadata models for the tenant associated to the security context.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataModelApi
     */
    MetadataModelApi.prototype.getMetadataModels = function (options) {
        var _this = this;
        return (0, exports.MetadataModelApiFp)(this.configuration).getMetadataModels(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieve the tenant model for the tenant associated to the security context. The tenant model is a hierarchical structure where the top level tenant holds a list of child models (which in turn can hold child models).
     * @summary Retrieve the tenant model for the tenant associated to the security context.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataModelApi
     */
    MetadataModelApi.prototype.getTenantModel = function (options) {
        var _this = this;
        return (0, exports.MetadataModelApiFp)(this.configuration).getTenantModel(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return MetadataModelApi;
}(base_1.BaseAPI));
exports.MetadataModelApi = MetadataModelApi;
/**
 * NotificationChannelApi - axios parameter creator
 * @export
 */
var NotificationChannelApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Create a notification channel
         * @param {CreateNotificationChannel} [createNotificationChannel] The new channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationChannel: function (createNotificationChannel, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/notificationChannels";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createNotificationChannel, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Delete a notification channel
         * @param {string} channelId The ID of the notification channel to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationChannel: function (channelId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'channelId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteNotificationChannel', 'channelId', channelId);
                            localVarPath = "/api/notificationChannels/{channelId}"
                                .replace("{".concat("channelId", "}"), encodeURIComponent(String(channelId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a notification channel
         * @param {string} channelId The ID of the notification channel to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationChannel: function (channelId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'channelId' is not null or undefined
                            (0, common_1.assertParamExists)('getNotificationChannel', 'channelId', channelId);
                            localVarPath = "/api/notificationChannels/{channelId}"
                                .replace("{".concat("channelId", "}"), encodeURIComponent(String(channelId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve notification channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationChannels: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/notificationChannels";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This will affect all subscriptions which use this address!Fields which can be updated:  - enabled  - address
         * @summary Update a notification channel
         * @param {string} channelId The ID of the notification channel to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {NotificationChannel} [notificationChannel] The updated channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationChannel: function (channelId, ifMatch, notificationChannel, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'channelId' is not null or undefined
                            (0, common_1.assertParamExists)('updateNotificationChannel', 'channelId', channelId);
                            localVarPath = "/api/notificationChannels/{channelId}"
                                .replace("{".concat("channelId", "}"), encodeURIComponent(String(channelId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (ifMatch !== undefined && ifMatch !== null) {
                                localVarHeaderParameter['If-Match'] = String(ifMatch);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(notificationChannel, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.NotificationChannelApiAxiosParamCreator = NotificationChannelApiAxiosParamCreator;
/**
 * NotificationChannelApi - functional programming interface
 * @export
 */
var NotificationChannelApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.NotificationChannelApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a notification channel
         * @param {CreateNotificationChannel} [createNotificationChannel] The new channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationChannel: function (createNotificationChannel, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createNotificationChannel(createNotificationChannel, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Delete a notification channel
         * @param {string} channelId The ID of the notification channel to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationChannel: function (channelId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteNotificationChannel(channelId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a notification channel
         * @param {string} channelId The ID of the notification channel to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationChannel: function (channelId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNotificationChannel(channelId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve notification channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationChannels: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNotificationChannels(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This will affect all subscriptions which use this address!Fields which can be updated:  - enabled  - address
         * @summary Update a notification channel
         * @param {string} channelId The ID of the notification channel to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {NotificationChannel} [notificationChannel] The updated channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationChannel: function (channelId, ifMatch, notificationChannel, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateNotificationChannel(channelId, ifMatch, notificationChannel, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.NotificationChannelApiFp = NotificationChannelApiFp;
/**
 * NotificationChannelApi - factory interface
 * @export
 */
var NotificationChannelApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.NotificationChannelApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a notification channel
         * @param {CreateNotificationChannel} [createNotificationChannel] The new channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationChannel: function (createNotificationChannel, options) {
            return localVarFp.createNotificationChannel(createNotificationChannel, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Delete a notification channel
         * @param {string} channelId The ID of the notification channel to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationChannel: function (channelId, options) {
            return localVarFp.deleteNotificationChannel(channelId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a notification channel
         * @param {string} channelId The ID of the notification channel to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationChannel: function (channelId, options) {
            return localVarFp.getNotificationChannel(channelId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve notification channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationChannels: function (options) {
            return localVarFp.getNotificationChannels(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This will affect all subscriptions which use this address!Fields which can be updated:  - enabled  - address
         * @summary Update a notification channel
         * @param {string} channelId The ID of the notification channel to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {NotificationChannel} [notificationChannel] The updated channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationChannel: function (channelId, ifMatch, notificationChannel, options) {
            return localVarFp.updateNotificationChannel(channelId, ifMatch, notificationChannel, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.NotificationChannelApiFactory = NotificationChannelApiFactory;
/**
 * NotificationChannelApi - object-oriented interface
 * @export
 * @class NotificationChannelApi
 * @extends {BaseAPI}
 */
var NotificationChannelApi = /** @class */ (function (_super) {
    __extends(NotificationChannelApi, _super);
    function NotificationChannelApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Create a notification channel
     * @param {CreateNotificationChannel} [createNotificationChannel] The new channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelApi
     */
    NotificationChannelApi.prototype.createNotificationChannel = function (createNotificationChannel, options) {
        var _this = this;
        return (0, exports.NotificationChannelApiFp)(this.configuration).createNotificationChannel(createNotificationChannel, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Delete a notification channel
     * @param {string} channelId The ID of the notification channel to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelApi
     */
    NotificationChannelApi.prototype.deleteNotificationChannel = function (channelId, options) {
        var _this = this;
        return (0, exports.NotificationChannelApiFp)(this.configuration).deleteNotificationChannel(channelId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a notification channel
     * @param {string} channelId The ID of the notification channel to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelApi
     */
    NotificationChannelApi.prototype.getNotificationChannel = function (channelId, options) {
        var _this = this;
        return (0, exports.NotificationChannelApiFp)(this.configuration).getNotificationChannel(channelId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve notification channels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelApi
     */
    NotificationChannelApi.prototype.getNotificationChannels = function (options) {
        var _this = this;
        return (0, exports.NotificationChannelApiFp)(this.configuration).getNotificationChannels(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This will affect all subscriptions which use this address!Fields which can be updated:  - enabled  - address
     * @summary Update a notification channel
     * @param {string} channelId The ID of the notification channel to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {NotificationChannel} [notificationChannel] The updated channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelApi
     */
    NotificationChannelApi.prototype.updateNotificationChannel = function (channelId, ifMatch, notificationChannel, options) {
        var _this = this;
        return (0, exports.NotificationChannelApiFp)(this.configuration).updateNotificationChannel(channelId, ifMatch, notificationChannel, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return NotificationChannelApi;
}(base_1.BaseAPI));
exports.NotificationChannelApi = NotificationChannelApi;
/**
 * PipelineApi - axios parameter creator
 * @export
 */
var PipelineApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline: function (pipelineId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'pipelineId' is not null or undefined
                            (0, common_1.assertParamExists)('getPipeline', 'pipelineId', pipelineId);
                            localVarPath = "/api/pipelines/{pipelineId}"
                                .replace("{".concat("pipelineId", "}"), encodeURIComponent(String(pipelineId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve input parameters for a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve input parameters for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineInputParameters: function (pipelineId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'pipelineId' is not null or undefined
                            (0, common_1.assertParamExists)('getPipelineInputParameters', 'pipelineId', pipelineId);
                            localVarPath = "/api/pipelines/{pipelineId}/inputParameters"
                                .replace("{".concat("pipelineId", "}"), encodeURIComponent(String(pipelineId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the reference sets of a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineReferenceSets: function (pipelineId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'pipelineId' is not null or undefined
                            (0, common_1.assertParamExists)('getPipelineReferenceSets', 'pipelineId', pipelineId);
                            localVarPath = "/api/pipelines/{pipelineId}/referenceSets"
                                .replace("{".concat("pipelineId", "}"), encodeURIComponent(String(pipelineId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of pipelines.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelines: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/pipelines";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.PipelineApiAxiosParamCreator = PipelineApiAxiosParamCreator;
/**
 * PipelineApi - functional programming interface
 * @export
 */
var PipelineApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.PipelineApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline: function (pipelineId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPipeline(pipelineId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve input parameters for a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve input parameters for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineInputParameters: function (pipelineId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPipelineInputParameters(pipelineId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the reference sets of a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineReferenceSets: function (pipelineId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPipelineReferenceSets(pipelineId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of pipelines.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelines: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPipelines(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.PipelineApiFp = PipelineApiFp;
/**
 * PipelineApi - factory interface
 * @export
 */
var PipelineApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.PipelineApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline: function (pipelineId, options) {
            return localVarFp.getPipeline(pipelineId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve input parameters for a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve input parameters for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineInputParameters: function (pipelineId, options) {
            return localVarFp.getPipelineInputParameters(pipelineId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve the reference sets of a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineReferenceSets: function (pipelineId, options) {
            return localVarFp.getPipelineReferenceSets(pipelineId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of pipelines.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelines: function (options) {
            return localVarFp.getPipelines(options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.PipelineApiFactory = PipelineApiFactory;
/**
 * PipelineApi - object-oriented interface
 * @export
 * @class PipelineApi
 * @extends {BaseAPI}
 */
var PipelineApi = /** @class */ (function (_super) {
    __extends(PipelineApi, _super);
    function PipelineApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    PipelineApi.prototype.getPipeline = function (pipelineId, options) {
        var _this = this;
        return (0, exports.PipelineApiFp)(this.configuration).getPipeline(pipelineId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve input parameters for a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve input parameters for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    PipelineApi.prototype.getPipelineInputParameters = function (pipelineId, options) {
        var _this = this;
        return (0, exports.PipelineApiFp)(this.configuration).getPipelineInputParameters(pipelineId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve the reference sets of a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    PipelineApi.prototype.getPipelineReferenceSets = function (pipelineId, options) {
        var _this = this;
        return (0, exports.PipelineApiFp)(this.configuration).getPipelineReferenceSets(pipelineId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of pipelines.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    PipelineApi.prototype.getPipelines = function (options) {
        var _this = this;
        return (0, exports.PipelineApiFp)(this.configuration).getPipelines(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return PipelineApi;
}(base_1.BaseAPI));
exports.PipelineApi = PipelineApi;
/**
 * ProjectApi - axios parameter creator
 * @export
 */
var ProjectApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Create a new project.
         * @param {CreateProject} [createProject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: function (createProject, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/projects";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createProject, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a project.
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: function (projectId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getProject', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a project bundle.
         * @param {string} projectId
         * @param {string} bundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectBundle: function (projectId, bundleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectBundle', 'projectId', projectId);
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectBundle', 'bundleId', bundleId);
                            localVarPath = "/api/projects/{projectId}/bundles/{bundleId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve project bundles.
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectBundles: function (projectId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectBundles', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/bundles"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of projects.
         * @param {string} [search] Search
         * @param {Array<string>} [userTags] User tags to filter on
         * @param {Array<string>} [technicalTags] Technical tags to filter on
         * @param {boolean} [includeHiddenProjects] Include hidden projects.
         * @param {string} [region] The ID of the region to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription - information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects: function (search, userTags, technicalTags, includeHiddenProjects, region, pageOffset, pageToken, pageSize, sort, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/projects";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (search !== undefined) {
                                localVarQueryParameter['search'] = search;
                            }
                            if (userTags) {
                                localVarQueryParameter['userTags'] = userTags;
                            }
                            if (technicalTags) {
                                localVarQueryParameter['technicalTags'] = technicalTags;
                            }
                            if (includeHiddenProjects !== undefined) {
                                localVarQueryParameter['includeHiddenProjects'] = includeHiddenProjects;
                            }
                            if (region !== undefined) {
                                localVarQueryParameter['region'] = region;
                            }
                            if (pageOffset !== undefined) {
                                localVarQueryParameter['pageOffset'] = pageOffset;
                            }
                            if (pageToken !== undefined) {
                                localVarQueryParameter['pageToken'] = pageToken;
                            }
                            if (pageSize !== undefined) {
                                localVarQueryParameter['pageSize'] = pageSize;
                            }
                            if (sort !== undefined) {
                                localVarQueryParameter['sort'] = sort;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Link a bundle to a project.
         * @param {string} projectId
         * @param {string} bundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkProjectBundle: function (projectId, bundleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('linkProjectBundle', 'projectId', projectId);
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('linkProjectBundle', 'bundleId', bundleId);
                            localVarPath = "/api/projects/{projectId}/bundles/{bundleId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink a bundle from a project.
         * @param {string} projectId
         * @param {string} bundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkProjectBundle: function (projectId, bundleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkProjectBundle', 'projectId', projectId);
                            // verify required parameter 'bundleId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkProjectBundle', 'bundleId', bundleId);
                            localVarPath = "/api/projects/{projectId}/bundles/{bundleId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("bundleId", "}"), encodeURIComponent(String(bundleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Fields which can be updated: - shortDescription - projectInformation - billingMode - dataSharingEnabled - tags - storageBundle - metaDataModel
         * @summary Update a project.
         * @param {string} projectId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {Project} [project]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: function (projectId, ifMatch, project, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('updateProject', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (ifMatch !== undefined && ifMatch !== null) {
                                localVarHeaderParameter['If-Match'] = String(ifMatch);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(project, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ProjectApiAxiosParamCreator = ProjectApiAxiosParamCreator;
/**
 * ProjectApi - functional programming interface
 * @export
 */
var ProjectApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ProjectApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a new project.
         * @param {CreateProject} [createProject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: function (createProject, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createProject(createProject, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a project.
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: function (projectId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProject(projectId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a project bundle.
         * @param {string} projectId
         * @param {string} bundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectBundle: function (projectId, bundleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProjectBundle(projectId, bundleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve project bundles.
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectBundles: function (projectId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProjectBundles(projectId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of projects.
         * @param {string} [search] Search
         * @param {Array<string>} [userTags] User tags to filter on
         * @param {Array<string>} [technicalTags] Technical tags to filter on
         * @param {boolean} [includeHiddenProjects] Include hidden projects.
         * @param {string} [region] The ID of the region to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription - information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects: function (search, userTags, technicalTags, includeHiddenProjects, region, pageOffset, pageToken, pageSize, sort, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProjects(search, userTags, technicalTags, includeHiddenProjects, region, pageOffset, pageToken, pageSize, sort, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Link a bundle to a project.
         * @param {string} projectId
         * @param {string} bundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkProjectBundle: function (projectId, bundleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.linkProjectBundle(projectId, bundleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink a bundle from a project.
         * @param {string} projectId
         * @param {string} bundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkProjectBundle: function (projectId, bundleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unlinkProjectBundle(projectId, bundleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fields which can be updated: - shortDescription - projectInformation - billingMode - dataSharingEnabled - tags - storageBundle - metaDataModel
         * @summary Update a project.
         * @param {string} projectId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {Project} [project]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: function (projectId, ifMatch, project, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateProject(projectId, ifMatch, project, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ProjectApiFp = ProjectApiFp;
/**
 * ProjectApi - factory interface
 * @export
 */
var ProjectApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ProjectApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a new project.
         * @param {CreateProject} [createProject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: function (createProject, options) {
            return localVarFp.createProject(createProject, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a project.
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: function (projectId, options) {
            return localVarFp.getProject(projectId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a project bundle.
         * @param {string} projectId
         * @param {string} bundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectBundle: function (projectId, bundleId, options) {
            return localVarFp.getProjectBundle(projectId, bundleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve project bundles.
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectBundles: function (projectId, options) {
            return localVarFp.getProjectBundles(projectId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of projects.
         * @param {string} [search] Search
         * @param {Array<string>} [userTags] User tags to filter on
         * @param {Array<string>} [technicalTags] Technical tags to filter on
         * @param {boolean} [includeHiddenProjects] Include hidden projects.
         * @param {string} [region] The ID of the region to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription - information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects: function (search, userTags, technicalTags, includeHiddenProjects, region, pageOffset, pageToken, pageSize, sort, options) {
            return localVarFp.getProjects(search, userTags, technicalTags, includeHiddenProjects, region, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Link a bundle to a project.
         * @param {string} projectId
         * @param {string} bundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkProjectBundle: function (projectId, bundleId, options) {
            return localVarFp.linkProjectBundle(projectId, bundleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Unlink a bundle from a project.
         * @param {string} projectId
         * @param {string} bundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkProjectBundle: function (projectId, bundleId, options) {
            return localVarFp.unlinkProjectBundle(projectId, bundleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fields which can be updated: - shortDescription - projectInformation - billingMode - dataSharingEnabled - tags - storageBundle - metaDataModel
         * @summary Update a project.
         * @param {string} projectId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {Project} [project]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: function (projectId, ifMatch, project, options) {
            return localVarFp.updateProject(projectId, ifMatch, project, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ProjectApiFactory = ProjectApiFactory;
/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
var ProjectApi = /** @class */ (function (_super) {
    __extends(ProjectApi, _super);
    function ProjectApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Create a new project.
     * @param {CreateProject} [createProject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    ProjectApi.prototype.createProject = function (createProject, options) {
        var _this = this;
        return (0, exports.ProjectApiFp)(this.configuration).createProject(createProject, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a project.
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    ProjectApi.prototype.getProject = function (projectId, options) {
        var _this = this;
        return (0, exports.ProjectApiFp)(this.configuration).getProject(projectId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a project bundle.
     * @param {string} projectId
     * @param {string} bundleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    ProjectApi.prototype.getProjectBundle = function (projectId, bundleId, options) {
        var _this = this;
        return (0, exports.ProjectApiFp)(this.configuration).getProjectBundle(projectId, bundleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve project bundles.
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    ProjectApi.prototype.getProjectBundles = function (projectId, options) {
        var _this = this;
        return (0, exports.ProjectApiFp)(this.configuration).getProjectBundles(projectId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of projects.
     * @param {string} [search] Search
     * @param {Array<string>} [userTags] User tags to filter on
     * @param {Array<string>} [technicalTags] Technical tags to filter on
     * @param {boolean} [includeHiddenProjects] Include hidden projects.
     * @param {string} [region] The ID of the region to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription - information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    ProjectApi.prototype.getProjects = function (search, userTags, technicalTags, includeHiddenProjects, region, pageOffset, pageToken, pageSize, sort, options) {
        var _this = this;
        return (0, exports.ProjectApiFp)(this.configuration).getProjects(search, userTags, technicalTags, includeHiddenProjects, region, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Link a bundle to a project.
     * @param {string} projectId
     * @param {string} bundleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    ProjectApi.prototype.linkProjectBundle = function (projectId, bundleId, options) {
        var _this = this;
        return (0, exports.ProjectApiFp)(this.configuration).linkProjectBundle(projectId, bundleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Unlink a bundle from a project.
     * @param {string} projectId
     * @param {string} bundleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    ProjectApi.prototype.unlinkProjectBundle = function (projectId, bundleId, options) {
        var _this = this;
        return (0, exports.ProjectApiFp)(this.configuration).unlinkProjectBundle(projectId, bundleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fields which can be updated: - shortDescription - projectInformation - billingMode - dataSharingEnabled - tags - storageBundle - metaDataModel
     * @summary Update a project.
     * @param {string} projectId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {Project} [project]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    ProjectApi.prototype.updateProject = function (projectId, ifMatch, project, options) {
        var _this = this;
        return (0, exports.ProjectApiFp)(this.configuration).updateProject(projectId, ifMatch, project, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ProjectApi;
}(base_1.BaseAPI));
exports.ProjectApi = ProjectApi;
/**
 * ProjectAnalysisApi - axios parameter creator
 * @export
 */
var ProjectAnalysisApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Abort an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to abort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortAnalysis: function (projectId, analysisId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('abortAnalysis', 'projectId', projectId);
                            // verify required parameter 'analysisId' is not null or undefined
                            (0, common_1.assertParamExists)('abortAnalysis', 'analysisId', analysisId);
                            localVarPath = "/api/projects/{projectId}/analyses/{analysisId}:abort"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("analysisId", "}"), encodeURIComponent(String(analysisId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Create and start an analysis for a CWL pipeline.
         * @param {string} projectId
         * @param {CreateCwlAnalysis} [createCwlAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCwlAnalysis: function (projectId, createCwlAnalysis, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('createCwlAnalysis', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/analysis:cwl"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createCwlAnalysis, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Create and start an analysis for a Nextflow pipeline.
         * @param {string} projectId
         * @param {CreateNextflowAnalysis} [createNextflowAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNextflowAnalysis: function (projectId, createNextflowAnalysis, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('createNextflowAnalysis', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/analysis:nextflow"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createNextflowAnalysis, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the list of project analyses.
         * @param {string} projectId
         * @param {string} [reference] The reference to filter on.
         * @param {string} [userreference] The user-reference to filter on.
         * @param {string} [status] The status to filter on.
         * @param {string} [usertag] The user-tags to filter on.
         * @param {string} [technicaltag] The technical-tags to filter on.
         * @param {string} [referencetag] The reference-data-tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyses: function (projectId, reference, userreference, status, usertag, technicaltag, referencetag, pageOffset, pageToken, pageSize, sort, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getAnalyses', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/analyses"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (reference !== undefined) {
                                localVarQueryParameter['reference'] = reference;
                            }
                            if (userreference !== undefined) {
                                localVarQueryParameter['userreference'] = userreference;
                            }
                            if (status !== undefined) {
                                localVarQueryParameter['status'] = status;
                            }
                            if (usertag !== undefined) {
                                localVarQueryParameter['usertag'] = usertag;
                            }
                            if (technicaltag !== undefined) {
                                localVarQueryParameter['technicaltag'] = technicaltag;
                            }
                            if (referencetag !== undefined) {
                                localVarQueryParameter['referencetag'] = referencetag;
                            }
                            if (pageOffset !== undefined) {
                                localVarQueryParameter['pageOffset'] = pageOffset;
                            }
                            if (pageToken !== undefined) {
                                localVarQueryParameter['pageToken'] = pageToken;
                            }
                            if (pageSize !== undefined) {
                                localVarQueryParameter['pageSize'] = pageSize;
                            }
                            if (sort !== undefined) {
                                localVarQueryParameter['sort'] = sort;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysis: function (projectId, analysisId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getAnalysis', 'projectId', projectId);
                            // verify required parameter 'analysisId' is not null or undefined
                            (0, common_1.assertParamExists)('getAnalysis', 'analysisId', analysisId);
                            localVarPath = "/api/projects/{projectId}/analyses/{analysisId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("analysisId", "}"), encodeURIComponent(String(analysisId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the configurations of an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to retrieve the configuration for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisConfigurations: function (projectId, analysisId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getAnalysisConfigurations', 'projectId', projectId);
                            // verify required parameter 'analysisId' is not null or undefined
                            (0, common_1.assertParamExists)('getAnalysisConfigurations', 'analysisId', analysisId);
                            localVarPath = "/api/projects/{projectId}/analyses/{analysisId}/configurations"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("analysisId", "}"), encodeURIComponent(String(analysisId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the inputs of an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to retrieve the inputs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisInputs: function (projectId, analysisId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getAnalysisInputs', 'projectId', projectId);
                            // verify required parameter 'analysisId' is not null or undefined
                            (0, common_1.assertParamExists)('getAnalysisInputs', 'analysisId', analysisId);
                            localVarPath = "/api/projects/{projectId}/analyses/{analysisId}/inputs"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("analysisId", "}"), encodeURIComponent(String(analysisId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the outputs of an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to retrieve the outputs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisOutputs: function (projectId, analysisId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getAnalysisOutputs', 'projectId', projectId);
                            // verify required parameter 'analysisId' is not null or undefined
                            (0, common_1.assertParamExists)('getAnalysisOutputs', 'analysisId', analysisId);
                            localVarPath = "/api/projects/{projectId}/analyses/{analysisId}/outputs"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("analysisId", "}"), encodeURIComponent(String(analysisId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the individual steps of an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to retrieve the individual steps for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisSteps: function (projectId, analysisId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getAnalysisSteps', 'projectId', projectId);
                            // verify required parameter 'analysisId' is not null or undefined
                            (0, common_1.assertParamExists)('getAnalysisSteps', 'analysisId', analysisId);
                            localVarPath = "/api/projects/{projectId}/analyses/{analysisId}/steps"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("analysisId", "}"), encodeURIComponent(String(analysisId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the raw output of an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis for which to retrieve the raw output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hGetExecutionOutputObject: function (projectId, analysisId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('hGetExecutionOutputObject', 'projectId', projectId);
                            // verify required parameter 'analysisId' is not null or undefined
                            (0, common_1.assertParamExists)('hGetExecutionOutputObject', 'analysisId', analysisId);
                            localVarPath = "/api/projects/{projectId}/analyses/{analysisId}/rawOutput"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("analysisId", "}"), encodeURIComponent(String(analysisId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Attributes which can be updated:    - tags
         * @summary Update an analysis.
         * @param {string} projectId
         * @param {string} analysisId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {Analysis} [analysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnalysis: function (projectId, analysisId, ifMatch, analysis, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('updateAnalysis', 'projectId', projectId);
                            // verify required parameter 'analysisId' is not null or undefined
                            (0, common_1.assertParamExists)('updateAnalysis', 'analysisId', analysisId);
                            localVarPath = "/api/projects/{projectId}/analyses/{analysisId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("analysisId", "}"), encodeURIComponent(String(analysisId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (ifMatch !== undefined && ifMatch !== null) {
                                localVarHeaderParameter['If-Match'] = String(ifMatch);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(analysis, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ProjectAnalysisApiAxiosParamCreator = ProjectAnalysisApiAxiosParamCreator;
/**
 * ProjectAnalysisApi - functional programming interface
 * @export
 */
var ProjectAnalysisApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ProjectAnalysisApiAxiosParamCreator)(configuration);
    return {
        /**
         * Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Abort an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to abort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortAnalysis: function (projectId, analysisId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.abortAnalysis(projectId, analysisId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Create and start an analysis for a CWL pipeline.
         * @param {string} projectId
         * @param {CreateCwlAnalysis} [createCwlAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCwlAnalysis: function (projectId, createCwlAnalysis, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createCwlAnalysis(projectId, createCwlAnalysis, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Create and start an analysis for a Nextflow pipeline.
         * @param {string} projectId
         * @param {CreateNextflowAnalysis} [createNextflowAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNextflowAnalysis: function (projectId, createNextflowAnalysis, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createNextflowAnalysis(projectId, createNextflowAnalysis, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the list of project analyses.
         * @param {string} projectId
         * @param {string} [reference] The reference to filter on.
         * @param {string} [userreference] The user-reference to filter on.
         * @param {string} [status] The status to filter on.
         * @param {string} [usertag] The user-tags to filter on.
         * @param {string} [technicaltag] The technical-tags to filter on.
         * @param {string} [referencetag] The reference-data-tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyses: function (projectId, reference, userreference, status, usertag, technicaltag, referencetag, pageOffset, pageToken, pageSize, sort, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAnalyses(projectId, reference, userreference, status, usertag, technicaltag, referencetag, pageOffset, pageToken, pageSize, sort, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysis: function (projectId, analysisId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAnalysis(projectId, analysisId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the configurations of an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to retrieve the configuration for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisConfigurations: function (projectId, analysisId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAnalysisConfigurations(projectId, analysisId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the inputs of an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to retrieve the inputs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisInputs: function (projectId, analysisId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAnalysisInputs(projectId, analysisId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the outputs of an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to retrieve the outputs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisOutputs: function (projectId, analysisId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAnalysisOutputs(projectId, analysisId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the individual steps of an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to retrieve the individual steps for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisSteps: function (projectId, analysisId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAnalysisSteps(projectId, analysisId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the raw output of an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis for which to retrieve the raw output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hGetExecutionOutputObject: function (projectId, analysisId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.hGetExecutionOutputObject(projectId, analysisId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Attributes which can be updated:    - tags
         * @summary Update an analysis.
         * @param {string} projectId
         * @param {string} analysisId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {Analysis} [analysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnalysis: function (projectId, analysisId, ifMatch, analysis, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateAnalysis(projectId, analysisId, ifMatch, analysis, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ProjectAnalysisApiFp = ProjectAnalysisApiFp;
/**
 * ProjectAnalysisApi - factory interface
 * @export
 */
var ProjectAnalysisApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ProjectAnalysisApiFp)(configuration);
    return {
        /**
         * Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Abort an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to abort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortAnalysis: function (projectId, analysisId, options) {
            return localVarFp.abortAnalysis(projectId, analysisId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Create and start an analysis for a CWL pipeline.
         * @param {string} projectId
         * @param {CreateCwlAnalysis} [createCwlAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCwlAnalysis: function (projectId, createCwlAnalysis, options) {
            return localVarFp.createCwlAnalysis(projectId, createCwlAnalysis, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Create and start an analysis for a Nextflow pipeline.
         * @param {string} projectId
         * @param {CreateNextflowAnalysis} [createNextflowAnalysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNextflowAnalysis: function (projectId, createNextflowAnalysis, options) {
            return localVarFp.createNextflowAnalysis(projectId, createNextflowAnalysis, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve the list of project analyses.
         * @param {string} projectId
         * @param {string} [reference] The reference to filter on.
         * @param {string} [userreference] The user-reference to filter on.
         * @param {string} [status] The status to filter on.
         * @param {string} [usertag] The user-tags to filter on.
         * @param {string} [technicaltag] The technical-tags to filter on.
         * @param {string} [referencetag] The reference-data-tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyses: function (projectId, reference, userreference, status, usertag, technicaltag, referencetag, pageOffset, pageToken, pageSize, sort, options) {
            return localVarFp.getAnalyses(projectId, reference, userreference, status, usertag, technicaltag, referencetag, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysis: function (projectId, analysisId, options) {
            return localVarFp.getAnalysis(projectId, analysisId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve the configurations of an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to retrieve the configuration for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisConfigurations: function (projectId, analysisId, options) {
            return localVarFp.getAnalysisConfigurations(projectId, analysisId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve the inputs of an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to retrieve the inputs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisInputs: function (projectId, analysisId, options) {
            return localVarFp.getAnalysisInputs(projectId, analysisId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve the outputs of an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to retrieve the outputs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisOutputs: function (projectId, analysisId, options) {
            return localVarFp.getAnalysisOutputs(projectId, analysisId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve the individual steps of an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis to retrieve the individual steps for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisSteps: function (projectId, analysisId, options) {
            return localVarFp.getAnalysisSteps(projectId, analysisId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve the raw output of an analysis.
         * @param {string} projectId
         * @param {string} analysisId The ID of the analysis for which to retrieve the raw output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hGetExecutionOutputObject: function (projectId, analysisId, options) {
            return localVarFp.hGetExecutionOutputObject(projectId, analysisId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Attributes which can be updated:    - tags
         * @summary Update an analysis.
         * @param {string} projectId
         * @param {string} analysisId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {Analysis} [analysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnalysis: function (projectId, analysisId, ifMatch, analysis, options) {
            return localVarFp.updateAnalysis(projectId, analysisId, ifMatch, analysis, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ProjectAnalysisApiFactory = ProjectAnalysisApiFactory;
/**
 * ProjectAnalysisApi - object-oriented interface
 * @export
 * @class ProjectAnalysisApi
 * @extends {BaseAPI}
 */
var ProjectAnalysisApi = /** @class */ (function (_super) {
    __extends(ProjectAnalysisApi, _super);
    function ProjectAnalysisApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Abort an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to abort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    ProjectAnalysisApi.prototype.abortAnalysis = function (projectId, analysisId, options) {
        var _this = this;
        return (0, exports.ProjectAnalysisApiFp)(this.configuration).abortAnalysis(projectId, analysisId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Create and start an analysis for a CWL pipeline.
     * @param {string} projectId
     * @param {CreateCwlAnalysis} [createCwlAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    ProjectAnalysisApi.prototype.createCwlAnalysis = function (projectId, createCwlAnalysis, options) {
        var _this = this;
        return (0, exports.ProjectAnalysisApiFp)(this.configuration).createCwlAnalysis(projectId, createCwlAnalysis, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Create and start an analysis for a Nextflow pipeline.
     * @param {string} projectId
     * @param {CreateNextflowAnalysis} [createNextflowAnalysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    ProjectAnalysisApi.prototype.createNextflowAnalysis = function (projectId, createNextflowAnalysis, options) {
        var _this = this;
        return (0, exports.ProjectAnalysisApiFp)(this.configuration).createNextflowAnalysis(projectId, createNextflowAnalysis, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve the list of project analyses.
     * @param {string} projectId
     * @param {string} [reference] The reference to filter on.
     * @param {string} [userreference] The user-reference to filter on.
     * @param {string} [status] The status to filter on.
     * @param {string} [usertag] The user-tags to filter on.
     * @param {string} [technicaltag] The technical-tags to filter on.
     * @param {string} [referencetag] The reference-data-tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    ProjectAnalysisApi.prototype.getAnalyses = function (projectId, reference, userreference, status, usertag, technicaltag, referencetag, pageOffset, pageToken, pageSize, sort, options) {
        var _this = this;
        return (0, exports.ProjectAnalysisApiFp)(this.configuration).getAnalyses(projectId, reference, userreference, status, usertag, technicaltag, referencetag, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    ProjectAnalysisApi.prototype.getAnalysis = function (projectId, analysisId, options) {
        var _this = this;
        return (0, exports.ProjectAnalysisApiFp)(this.configuration).getAnalysis(projectId, analysisId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve the configurations of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the configuration for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    ProjectAnalysisApi.prototype.getAnalysisConfigurations = function (projectId, analysisId, options) {
        var _this = this;
        return (0, exports.ProjectAnalysisApiFp)(this.configuration).getAnalysisConfigurations(projectId, analysisId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve the inputs of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the inputs for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    ProjectAnalysisApi.prototype.getAnalysisInputs = function (projectId, analysisId, options) {
        var _this = this;
        return (0, exports.ProjectAnalysisApiFp)(this.configuration).getAnalysisInputs(projectId, analysisId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve the outputs of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the outputs for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    ProjectAnalysisApi.prototype.getAnalysisOutputs = function (projectId, analysisId, options) {
        var _this = this;
        return (0, exports.ProjectAnalysisApiFp)(this.configuration).getAnalysisOutputs(projectId, analysisId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve the individual steps of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis to retrieve the individual steps for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    ProjectAnalysisApi.prototype.getAnalysisSteps = function (projectId, analysisId, options) {
        var _this = this;
        return (0, exports.ProjectAnalysisApiFp)(this.configuration).getAnalysisSteps(projectId, analysisId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve the raw output of an analysis.
     * @param {string} projectId
     * @param {string} analysisId The ID of the analysis for which to retrieve the raw output
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    ProjectAnalysisApi.prototype.hGetExecutionOutputObject = function (projectId, analysisId, options) {
        var _this = this;
        return (0, exports.ProjectAnalysisApiFp)(this.configuration).hGetExecutionOutputObject(projectId, analysisId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Attributes which can be updated:    - tags
     * @summary Update an analysis.
     * @param {string} projectId
     * @param {string} analysisId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {Analysis} [analysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    ProjectAnalysisApi.prototype.updateAnalysis = function (projectId, analysisId, ifMatch, analysis, options) {
        var _this = this;
        return (0, exports.ProjectAnalysisApiFp)(this.configuration).updateAnalysis(projectId, analysisId, ifMatch, analysis, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ProjectAnalysisApi;
}(base_1.BaseAPI));
exports.ProjectAnalysisApi = ProjectAnalysisApi;
/**
 * ProjectBaseApi - axios parameter creator
 * @export
 */
var ProjectBaseApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Creates the connection details to snowflake instance.
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBaseConnectionDetails: function (projectId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('createBaseConnectionDetails', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/base:connectionDetails"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ProjectBaseApiAxiosParamCreator = ProjectBaseApiAxiosParamCreator;
/**
 * ProjectBaseApi - functional programming interface
 * @export
 */
var ProjectBaseApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ProjectBaseApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Creates the connection details to snowflake instance.
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBaseConnectionDetails: function (projectId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createBaseConnectionDetails(projectId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ProjectBaseApiFp = ProjectBaseApiFp;
/**
 * ProjectBaseApi - factory interface
 * @export
 */
var ProjectBaseApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ProjectBaseApiFp)(configuration);
    return {
        /**
         *
         * @summary Creates the connection details to snowflake instance.
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBaseConnectionDetails: function (projectId, options) {
            return localVarFp.createBaseConnectionDetails(projectId, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ProjectBaseApiFactory = ProjectBaseApiFactory;
/**
 * ProjectBaseApi - object-oriented interface
 * @export
 * @class ProjectBaseApi
 * @extends {BaseAPI}
 */
var ProjectBaseApi = /** @class */ (function (_super) {
    __extends(ProjectBaseApi, _super);
    function ProjectBaseApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Creates the connection details to snowflake instance.
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectBaseApi
     */
    ProjectBaseApi.prototype.createBaseConnectionDetails = function (projectId, options) {
        var _this = this;
        return (0, exports.ProjectBaseApiFp)(this.configuration).createBaseConnectionDetails(projectId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ProjectBaseApi;
}(base_1.BaseAPI));
exports.ProjectBaseApi = ProjectBaseApi;
/**
 * ProjectBaseJobApi - axios parameter creator
 * @export
 */
var ProjectBaseJobApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve a base job.
         * @param {string} projectId
         * @param {string} baseJobId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseJob: function (projectId, baseJobId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getBaseJob', 'projectId', projectId);
                            // verify required parameter 'baseJobId' is not null or undefined
                            (0, common_1.assertParamExists)('getBaseJob', 'baseJobId', baseJobId);
                            localVarPath = "/api/projects/{projectId}/base/jobs/{baseJobId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("baseJobId", "}"), encodeURIComponent(String(baseJobId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of base jobs
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseJobs: function (projectId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getBaseJobs', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/base/jobs"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ProjectBaseJobApiAxiosParamCreator = ProjectBaseJobApiAxiosParamCreator;
/**
 * ProjectBaseJobApi - functional programming interface
 * @export
 */
var ProjectBaseJobApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ProjectBaseJobApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve a base job.
         * @param {string} projectId
         * @param {string} baseJobId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseJob: function (projectId, baseJobId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getBaseJob(projectId, baseJobId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of base jobs
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseJobs: function (projectId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getBaseJobs(projectId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ProjectBaseJobApiFp = ProjectBaseJobApiFp;
/**
 * ProjectBaseJobApi - factory interface
 * @export
 */
var ProjectBaseJobApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ProjectBaseJobApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve a base job.
         * @param {string} projectId
         * @param {string} baseJobId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseJob: function (projectId, baseJobId, options) {
            return localVarFp.getBaseJob(projectId, baseJobId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of base jobs
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseJobs: function (projectId, options) {
            return localVarFp.getBaseJobs(projectId, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ProjectBaseJobApiFactory = ProjectBaseJobApiFactory;
/**
 * ProjectBaseJobApi - object-oriented interface
 * @export
 * @class ProjectBaseJobApi
 * @extends {BaseAPI}
 */
var ProjectBaseJobApi = /** @class */ (function (_super) {
    __extends(ProjectBaseJobApi, _super);
    function ProjectBaseJobApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve a base job.
     * @param {string} projectId
     * @param {string} baseJobId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectBaseJobApi
     */
    ProjectBaseJobApi.prototype.getBaseJob = function (projectId, baseJobId, options) {
        var _this = this;
        return (0, exports.ProjectBaseJobApiFp)(this.configuration).getBaseJob(projectId, baseJobId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of base jobs
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectBaseJobApi
     */
    ProjectBaseJobApi.prototype.getBaseJobs = function (projectId, options) {
        var _this = this;
        return (0, exports.ProjectBaseJobApiFp)(this.configuration).getBaseJobs(projectId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ProjectBaseJobApi;
}(base_1.BaseAPI));
exports.ProjectBaseJobApi = ProjectBaseJobApi;
/**
 * ProjectBaseTableApi - axios parameter creator
 * @export
 */
var ProjectBaseTableApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve a liste of base tables.
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseTables: function (projectId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getBaseTables', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/base/tables"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Load data in the specified table
         * @summary Load data in a base table.
         * @param {string} projectId
         * @param {string} tableId
         * @param {LoadDataInBaseRequest} [loadDataInBaseRequest] Load data request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadData: function (projectId, tableId, loadDataInBaseRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('loadData', 'projectId', projectId);
                            // verify required parameter 'tableId' is not null or undefined
                            (0, common_1.assertParamExists)('loadData', 'tableId', tableId);
                            localVarPath = "/api/projects/{projectId}/base/tables/{tableId}:loadData"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("tableId", "}"), encodeURIComponent(String(tableId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(loadDataInBaseRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ProjectBaseTableApiAxiosParamCreator = ProjectBaseTableApiAxiosParamCreator;
/**
 * ProjectBaseTableApi - functional programming interface
 * @export
 */
var ProjectBaseTableApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ProjectBaseTableApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve a liste of base tables.
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseTables: function (projectId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getBaseTables(projectId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Load data in the specified table
         * @summary Load data in a base table.
         * @param {string} projectId
         * @param {string} tableId
         * @param {LoadDataInBaseRequest} [loadDataInBaseRequest] Load data request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadData: function (projectId, tableId, loadDataInBaseRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.loadData(projectId, tableId, loadDataInBaseRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ProjectBaseTableApiFp = ProjectBaseTableApiFp;
/**
 * ProjectBaseTableApi - factory interface
 * @export
 */
var ProjectBaseTableApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ProjectBaseTableApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve a liste of base tables.
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseTables: function (projectId, options) {
            return localVarFp.getBaseTables(projectId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Load data in the specified table
         * @summary Load data in a base table.
         * @param {string} projectId
         * @param {string} tableId
         * @param {LoadDataInBaseRequest} [loadDataInBaseRequest] Load data request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadData: function (projectId, tableId, loadDataInBaseRequest, options) {
            return localVarFp.loadData(projectId, tableId, loadDataInBaseRequest, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ProjectBaseTableApiFactory = ProjectBaseTableApiFactory;
/**
 * ProjectBaseTableApi - object-oriented interface
 * @export
 * @class ProjectBaseTableApi
 * @extends {BaseAPI}
 */
var ProjectBaseTableApi = /** @class */ (function (_super) {
    __extends(ProjectBaseTableApi, _super);
    function ProjectBaseTableApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve a liste of base tables.
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectBaseTableApi
     */
    ProjectBaseTableApi.prototype.getBaseTables = function (projectId, options) {
        var _this = this;
        return (0, exports.ProjectBaseTableApiFp)(this.configuration).getBaseTables(projectId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Load data in the specified table
     * @summary Load data in a base table.
     * @param {string} projectId
     * @param {string} tableId
     * @param {LoadDataInBaseRequest} [loadDataInBaseRequest] Load data request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectBaseTableApi
     */
    ProjectBaseTableApi.prototype.loadData = function (projectId, tableId, loadDataInBaseRequest, options) {
        var _this = this;
        return (0, exports.ProjectBaseTableApiFp)(this.configuration).loadData(projectId, tableId, loadDataInBaseRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ProjectBaseTableApi;
}(base_1.BaseAPI));
exports.ProjectBaseTableApi = ProjectBaseTableApi;
/**
 * ProjectCustomEventsApi - axios parameter creator
 * @export
 */
var ProjectCustomEventsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Create a new custom event.
         * @param {string} projectId
         * @param {CreateCustomEvent} createCustomEvent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomEvent: function (projectId, createCustomEvent, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('createCustomEvent', 'projectId', projectId);
                            // verify required parameter 'createCustomEvent' is not null or undefined
                            (0, common_1.assertParamExists)('createCustomEvent', 'createCustomEvent', createCustomEvent);
                            localVarPath = "/api/projects/{projectId}/customEvents"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createCustomEvent, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ProjectCustomEventsApiAxiosParamCreator = ProjectCustomEventsApiAxiosParamCreator;
/**
 * ProjectCustomEventsApi - functional programming interface
 * @export
 */
var ProjectCustomEventsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ProjectCustomEventsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a new custom event.
         * @param {string} projectId
         * @param {CreateCustomEvent} createCustomEvent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomEvent: function (projectId, createCustomEvent, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createCustomEvent(projectId, createCustomEvent, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ProjectCustomEventsApiFp = ProjectCustomEventsApiFp;
/**
 * ProjectCustomEventsApi - factory interface
 * @export
 */
var ProjectCustomEventsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ProjectCustomEventsApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a new custom event.
         * @param {string} projectId
         * @param {CreateCustomEvent} createCustomEvent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomEvent: function (projectId, createCustomEvent, options) {
            return localVarFp.createCustomEvent(projectId, createCustomEvent, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ProjectCustomEventsApiFactory = ProjectCustomEventsApiFactory;
/**
 * ProjectCustomEventsApi - object-oriented interface
 * @export
 * @class ProjectCustomEventsApi
 * @extends {BaseAPI}
 */
var ProjectCustomEventsApi = /** @class */ (function (_super) {
    __extends(ProjectCustomEventsApi, _super);
    function ProjectCustomEventsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Create a new custom event.
     * @param {string} projectId
     * @param {CreateCustomEvent} createCustomEvent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomEventsApi
     */
    ProjectCustomEventsApi.prototype.createCustomEvent = function (projectId, createCustomEvent, options) {
        var _this = this;
        return (0, exports.ProjectCustomEventsApiFp)(this.configuration).createCustomEvent(projectId, createCustomEvent, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ProjectCustomEventsApi;
}(base_1.BaseAPI));
exports.ProjectCustomEventsApi = ProjectCustomEventsApi;
/**
 * ProjectCustomNotificationSubscriptionsApi - axios parameter creator
 * @export
 */
var ProjectCustomNotificationSubscriptionsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Create a custom notification subscription
         * @param {string} projectId The ID of the project
         * @param {CreateCustomNotificationSubscription} [createCustomNotificationSubscription] The new subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationSubscription: function (projectId, createCustomNotificationSubscription, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('createNotificationSubscription', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/customNotificationSubscriptions"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createCustomNotificationSubscription, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Delete a custom notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the custom notification subscription to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationSubscription: function (projectId, subscriptionId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteNotificationSubscription', 'projectId', projectId);
                            // verify required parameter 'subscriptionId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteNotificationSubscription', 'subscriptionId', subscriptionId);
                            localVarPath = "/api/projects/{projectId}/customNotificationSubscriptions/{subscriptionId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("subscriptionId", "}"), encodeURIComponent(String(subscriptionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscription: function (projectId, subscriptionId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getNotificationSubscription', 'projectId', projectId);
                            // verify required parameter 'subscriptionId' is not null or undefined
                            (0, common_1.assertParamExists)('getNotificationSubscription', 'subscriptionId', subscriptionId);
                            localVarPath = "/api/projects/{projectId}/customNotificationSubscriptions/{subscriptionId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("subscriptionId", "}"), encodeURIComponent(String(subscriptionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve notification subscriptions
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscriptions: function (projectId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getNotificationSubscriptions', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/customNotificationSubscriptions"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel
         * @summary Update a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the custom notification subscription to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {CustomNotificationSubscription} [customNotificationSubscription] The updated subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationSubscription: function (projectId, subscriptionId, ifMatch, customNotificationSubscription, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('updateNotificationSubscription', 'projectId', projectId);
                            // verify required parameter 'subscriptionId' is not null or undefined
                            (0, common_1.assertParamExists)('updateNotificationSubscription', 'subscriptionId', subscriptionId);
                            localVarPath = "/api/projects/{projectId}/customNotificationSubscriptions/{subscriptionId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("subscriptionId", "}"), encodeURIComponent(String(subscriptionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (ifMatch !== undefined && ifMatch !== null) {
                                localVarHeaderParameter['If-Match'] = String(ifMatch);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(customNotificationSubscription, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ProjectCustomNotificationSubscriptionsApiAxiosParamCreator = ProjectCustomNotificationSubscriptionsApiAxiosParamCreator;
/**
 * ProjectCustomNotificationSubscriptionsApi - functional programming interface
 * @export
 */
var ProjectCustomNotificationSubscriptionsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ProjectCustomNotificationSubscriptionsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a custom notification subscription
         * @param {string} projectId The ID of the project
         * @param {CreateCustomNotificationSubscription} [createCustomNotificationSubscription] The new subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationSubscription: function (projectId, createCustomNotificationSubscription, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createNotificationSubscription(projectId, createCustomNotificationSubscription, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Delete a custom notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the custom notification subscription to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationSubscription: function (projectId, subscriptionId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteNotificationSubscription(projectId, subscriptionId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscription: function (projectId, subscriptionId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNotificationSubscription(projectId, subscriptionId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve notification subscriptions
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscriptions: function (projectId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNotificationSubscriptions(projectId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel
         * @summary Update a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the custom notification subscription to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {CustomNotificationSubscription} [customNotificationSubscription] The updated subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationSubscription: function (projectId, subscriptionId, ifMatch, customNotificationSubscription, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateNotificationSubscription(projectId, subscriptionId, ifMatch, customNotificationSubscription, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ProjectCustomNotificationSubscriptionsApiFp = ProjectCustomNotificationSubscriptionsApiFp;
/**
 * ProjectCustomNotificationSubscriptionsApi - factory interface
 * @export
 */
var ProjectCustomNotificationSubscriptionsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ProjectCustomNotificationSubscriptionsApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a custom notification subscription
         * @param {string} projectId The ID of the project
         * @param {CreateCustomNotificationSubscription} [createCustomNotificationSubscription] The new subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationSubscription: function (projectId, createCustomNotificationSubscription, options) {
            return localVarFp.createNotificationSubscription(projectId, createCustomNotificationSubscription, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Delete a custom notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the custom notification subscription to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationSubscription: function (projectId, subscriptionId, options) {
            return localVarFp.deleteNotificationSubscription(projectId, subscriptionId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscription: function (projectId, subscriptionId, options) {
            return localVarFp.getNotificationSubscription(projectId, subscriptionId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve notification subscriptions
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscriptions: function (projectId, options) {
            return localVarFp.getNotificationSubscriptions(projectId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel
         * @summary Update a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the custom notification subscription to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {CustomNotificationSubscription} [customNotificationSubscription] The updated subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationSubscription: function (projectId, subscriptionId, ifMatch, customNotificationSubscription, options) {
            return localVarFp.updateNotificationSubscription(projectId, subscriptionId, ifMatch, customNotificationSubscription, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ProjectCustomNotificationSubscriptionsApiFactory = ProjectCustomNotificationSubscriptionsApiFactory;
/**
 * ProjectCustomNotificationSubscriptionsApi - object-oriented interface
 * @export
 * @class ProjectCustomNotificationSubscriptionsApi
 * @extends {BaseAPI}
 */
var ProjectCustomNotificationSubscriptionsApi = /** @class */ (function (_super) {
    __extends(ProjectCustomNotificationSubscriptionsApi, _super);
    function ProjectCustomNotificationSubscriptionsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Create a custom notification subscription
     * @param {string} projectId The ID of the project
     * @param {CreateCustomNotificationSubscription} [createCustomNotificationSubscription] The new subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomNotificationSubscriptionsApi
     */
    ProjectCustomNotificationSubscriptionsApi.prototype.createNotificationSubscription = function (projectId, createCustomNotificationSubscription, options) {
        var _this = this;
        return (0, exports.ProjectCustomNotificationSubscriptionsApiFp)(this.configuration).createNotificationSubscription(projectId, createCustomNotificationSubscription, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Delete a custom notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the custom notification subscription to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomNotificationSubscriptionsApi
     */
    ProjectCustomNotificationSubscriptionsApi.prototype.deleteNotificationSubscription = function (projectId, subscriptionId, options) {
        var _this = this;
        return (0, exports.ProjectCustomNotificationSubscriptionsApiFp)(this.configuration).deleteNotificationSubscription(projectId, subscriptionId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomNotificationSubscriptionsApi
     */
    ProjectCustomNotificationSubscriptionsApi.prototype.getNotificationSubscription = function (projectId, subscriptionId, options) {
        var _this = this;
        return (0, exports.ProjectCustomNotificationSubscriptionsApiFp)(this.configuration).getNotificationSubscription(projectId, subscriptionId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve notification subscriptions
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomNotificationSubscriptionsApi
     */
    ProjectCustomNotificationSubscriptionsApi.prototype.getNotificationSubscriptions = function (projectId, options) {
        var _this = this;
        return (0, exports.ProjectCustomNotificationSubscriptionsApiFp)(this.configuration).getNotificationSubscriptions(projectId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel
     * @summary Update a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the custom notification subscription to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {CustomNotificationSubscription} [customNotificationSubscription] The updated subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomNotificationSubscriptionsApi
     */
    ProjectCustomNotificationSubscriptionsApi.prototype.updateNotificationSubscription = function (projectId, subscriptionId, ifMatch, customNotificationSubscription, options) {
        var _this = this;
        return (0, exports.ProjectCustomNotificationSubscriptionsApiFp)(this.configuration).updateNotificationSubscription(projectId, subscriptionId, ifMatch, customNotificationSubscription, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ProjectCustomNotificationSubscriptionsApi;
}(base_1.BaseAPI));
exports.ProjectCustomNotificationSubscriptionsApi = ProjectCustomNotificationSubscriptionsApi;
/**
 * ProjectDataApi - axios parameter creator
 * @export
 */
var ProjectDataApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Add secondary data to data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {string} secondaryDataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSecondaryData: function (projectId, dataId, secondaryDataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('addSecondaryData', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('addSecondaryData', 'dataId', dataId);
                            // verify required parameter 'secondaryDataId' is not null or undefined
                            (0, common_1.assertParamExists)('addSecondaryData', 'secondaryDataId', secondaryDataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}/secondaryData/{secondaryDataId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)))
                                .replace("{".concat("secondaryDataId", "}"), encodeURIComponent(String(secondaryDataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint for scheduling this data for archival. This will also archive all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for archival.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveData: function (projectId, dataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('archiveData', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('archiveData', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}:archive"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Complete a trackable folder upload session. By completing the folder upload session, and specifying how many files you have uploaded, ICA can ensure that all uploaded files are accounted for.
         * @summary Complete a trackable folder upload session.
         * @param {string} projectId
         * @param {string} dataId
         * @param {string} folderUploadSessionId
         * @param {CompleteFolderUploadSession} [completeFolderUploadSession] The info required to complete the folder upload session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeFolderUploadSession: function (projectId, dataId, folderUploadSessionId, completeFolderUploadSession, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('completeFolderUploadSession', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('completeFolderUploadSession', 'dataId', dataId);
                            // verify required parameter 'folderUploadSessionId' is not null or undefined
                            (0, common_1.assertParamExists)('completeFolderUploadSession', 'folderUploadSessionId', folderUploadSessionId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}/folderUploadSessions/{folderUploadSessionId}:complete"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)))
                                .replace("{".concat("folderUploadSessionId", "}"), encodeURIComponent(String(folderUploadSessionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(completeFolderUploadSession, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Create data in this project.
         * @param {string} projectId
         * @param {CreateData} [createData] The data to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataInProject: function (projectId, createData, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('createDataInProject', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/data"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createData, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Can be used to download a file directly from the region where it is located, no connector is needed.
         * @summary Retrieve a download URL for this data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDownloadUrlForData: function (projectId, dataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('createDownloadUrlForData', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('createDownloadUrlForData', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}:createDownloadUrl"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint can be used to ensure that all uploaded files within the requested session are accounted for. This call has to be used together with the :complete endpoint once upload is done.
         * @summary Create a trackable folder upload session.
         * @param {string} projectId
         * @param {string} dataId
         * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolderUploadSession: function (projectId, dataId, createTemporaryCredentials, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('createFolderUploadSession', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('createFolderUploadSession', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}/folderUploadSessions"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createTemporaryCredentials, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Can be used to view a file directly from the region where it is located, no connector is needed. Only small files can be viewed, otherwise a response with status 400 will be returned if the file is too big.
         * @summary Retrieve an URL for this data to use for inline view in a browser.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInlineViewUrlForData: function (projectId, dataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('createInlineViewUrlForData', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('createInlineViewUrlForData', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}:createInlineViewUrl"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Can be used to upload or download a file directly from the region where it is located, no connector is needed.
         * @summary Retrieve temporary credentials for this data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemporaryCredentialsForData: function (projectId, dataId, createTemporaryCredentials, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('createTemporaryCredentialsForData', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('createTemporaryCredentialsForData', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}:createTemporaryCredentials"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createTemporaryCredentials, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Can be used to upload a file directly from the region where it is located, no connector is needed. Only small files can be uploaded, otherwise a response with status 400 will be returned if the file is too big.
         * @summary Retrieve an upload URL for this data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {string} [fileType]
         * @param {string} [hash]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUploadUrlForData: function (projectId, dataId, fileType, hash, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('createUploadUrlForData', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('createUploadUrlForData', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}:createUploadUrl"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (fileType !== undefined) {
                                localVarQueryParameter['fileType'] = fileType;
                            }
                            if (hash !== undefined) {
                                localVarQueryParameter['hash'] = hash;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint for scheduling this data for deletion. This will also delete all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for deletion.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteData: function (projectId, dataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteData', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteData', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}:delete"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of data eligible for linking to the current project.
         * @param {string} projectId
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned. This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataEligibleForLinking: function (projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getDataEligibleForLinking', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/data/eligibleForLinking"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (fullText !== undefined) {
                                localVarQueryParameter['fullText'] = fullText;
                            }
                            if (id) {
                                localVarQueryParameter['id'] = id;
                            }
                            if (filename) {
                                localVarQueryParameter['filename'] = filename;
                            }
                            if (filenameMatchMode !== undefined) {
                                localVarQueryParameter['filenameMatchMode'] = filenameMatchMode;
                            }
                            if (filePath) {
                                localVarQueryParameter['filePath'] = filePath;
                            }
                            if (filePathMatchMode !== undefined) {
                                localVarQueryParameter['filePathMatchMode'] = filePathMatchMode;
                            }
                            if (status) {
                                localVarQueryParameter['status'] = status;
                            }
                            if (formatId) {
                                localVarQueryParameter['formatId'] = formatId;
                            }
                            if (formatCode) {
                                localVarQueryParameter['formatCode'] = formatCode;
                            }
                            if (type !== undefined) {
                                localVarQueryParameter['type'] = type;
                            }
                            if (parentFolderId) {
                                localVarQueryParameter['parentFolderId'] = parentFolderId;
                            }
                            if (parentFolderPath !== undefined) {
                                localVarQueryParameter['parentFolderPath'] = parentFolderPath;
                            }
                            if (creationDateAfter !== undefined) {
                                localVarQueryParameter['creationDateAfter'] = (creationDateAfter instanceof Date) ?
                                    creationDateAfter.toISOString() :
                                    creationDateAfter;
                            }
                            if (creationDateBefore !== undefined) {
                                localVarQueryParameter['creationDateBefore'] = (creationDateBefore instanceof Date) ?
                                    creationDateBefore.toISOString() :
                                    creationDateBefore;
                            }
                            if (statusDateAfter !== undefined) {
                                localVarQueryParameter['statusDateAfter'] = (statusDateAfter instanceof Date) ?
                                    statusDateAfter.toISOString() :
                                    statusDateAfter;
                            }
                            if (statusDateBefore !== undefined) {
                                localVarQueryParameter['statusDateBefore'] = (statusDateBefore instanceof Date) ?
                                    statusDateBefore.toISOString() :
                                    statusDateBefore;
                            }
                            if (userTag) {
                                localVarQueryParameter['userTag'] = userTag;
                            }
                            if (userTagMatchMode !== undefined) {
                                localVarQueryParameter['userTagMatchMode'] = userTagMatchMode;
                            }
                            if (runInputTag) {
                                localVarQueryParameter['runInputTag'] = runInputTag;
                            }
                            if (runInputTagMatchMode !== undefined) {
                                localVarQueryParameter['runInputTagMatchMode'] = runInputTagMatchMode;
                            }
                            if (runOutputTag) {
                                localVarQueryParameter['runOutputTag'] = runOutputTag;
                            }
                            if (runOutputTagMatchMode !== undefined) {
                                localVarQueryParameter['runOutputTagMatchMode'] = runOutputTagMatchMode;
                            }
                            if (connectorTag) {
                                localVarQueryParameter['connectorTag'] = connectorTag;
                            }
                            if (connectorTagMatchMode !== undefined) {
                                localVarQueryParameter['connectorTagMatchMode'] = connectorTagMatchMode;
                            }
                            if (technicalTag) {
                                localVarQueryParameter['technicalTag'] = technicalTag;
                            }
                            if (technicalTagMatchMode !== undefined) {
                                localVarQueryParameter['technicalTagMatchMode'] = technicalTagMatchMode;
                            }
                            if (notInRun !== undefined) {
                                localVarQueryParameter['notInRun'] = notInRun;
                            }
                            if (notLinkedToSample !== undefined) {
                                localVarQueryParameter['notLinkedToSample'] = notLinkedToSample;
                            }
                            if (pageOffset !== undefined) {
                                localVarQueryParameter['pageOffset'] = pageOffset;
                            }
                            if (pageToken !== undefined) {
                                localVarQueryParameter['pageToken'] = pageToken;
                            }
                            if (pageSize !== undefined) {
                                localVarQueryParameter['pageSize'] = pageSize;
                            }
                            if (sort !== undefined) {
                                localVarQueryParameter['sort'] = sort;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Retrieve folder upload session details, including the current status of your upload session.
         * @summary Retrieve folder upload session details.
         * @param {string} projectId
         * @param {string} dataId
         * @param {string} folderUploadSessionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderUploadSession: function (projectId, dataId, folderUploadSessionId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getFolderUploadSession', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('getFolderUploadSession', 'dataId', dataId);
                            // verify required parameter 'folderUploadSessionId' is not null or undefined
                            (0, common_1.assertParamExists)('getFolderUploadSession', 'folderUploadSessionId', folderUploadSessionId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}/folderUploadSessions/{folderUploadSessionId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)))
                                .replace("{".concat("folderUploadSessionId", "}"), encodeURIComponent(String(folderUploadSessionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of project data not linked to a sample.
         * @param {string} projectId
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNonSampleProjectData: function (projectId, pageOffset, pageToken, pageSize, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getNonSampleProjectData', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/data/nonSampleData"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (pageOffset !== undefined) {
                                localVarQueryParameter['pageOffset'] = pageOffset;
                            }
                            if (pageToken !== undefined) {
                                localVarQueryParameter['pageToken'] = pageToken;
                            }
                            if (pageSize !== undefined) {
                                localVarQueryParameter['pageSize'] = pageSize;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a project data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectData: function (projectId, dataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectData', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectData', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the children of this data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDataChildren: function (projectId, dataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectDataChildren', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectDataChildren', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}/children"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the list of project data.
         * @param {string} projectId
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned.  This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDataList: function (projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectDataList', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/data"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (fullText !== undefined) {
                                localVarQueryParameter['fullText'] = fullText;
                            }
                            if (id) {
                                localVarQueryParameter['id'] = id;
                            }
                            if (filename) {
                                localVarQueryParameter['filename'] = filename;
                            }
                            if (filenameMatchMode !== undefined) {
                                localVarQueryParameter['filenameMatchMode'] = filenameMatchMode;
                            }
                            if (filePath) {
                                localVarQueryParameter['filePath'] = filePath;
                            }
                            if (filePathMatchMode !== undefined) {
                                localVarQueryParameter['filePathMatchMode'] = filePathMatchMode;
                            }
                            if (status) {
                                localVarQueryParameter['status'] = status;
                            }
                            if (formatId) {
                                localVarQueryParameter['formatId'] = formatId;
                            }
                            if (formatCode) {
                                localVarQueryParameter['formatCode'] = formatCode;
                            }
                            if (type !== undefined) {
                                localVarQueryParameter['type'] = type;
                            }
                            if (parentFolderId) {
                                localVarQueryParameter['parentFolderId'] = parentFolderId;
                            }
                            if (parentFolderPath !== undefined) {
                                localVarQueryParameter['parentFolderPath'] = parentFolderPath;
                            }
                            if (creationDateAfter !== undefined) {
                                localVarQueryParameter['creationDateAfter'] = (creationDateAfter instanceof Date) ?
                                    creationDateAfter.toISOString() :
                                    creationDateAfter;
                            }
                            if (creationDateBefore !== undefined) {
                                localVarQueryParameter['creationDateBefore'] = (creationDateBefore instanceof Date) ?
                                    creationDateBefore.toISOString() :
                                    creationDateBefore;
                            }
                            if (statusDateAfter !== undefined) {
                                localVarQueryParameter['statusDateAfter'] = (statusDateAfter instanceof Date) ?
                                    statusDateAfter.toISOString() :
                                    statusDateAfter;
                            }
                            if (statusDateBefore !== undefined) {
                                localVarQueryParameter['statusDateBefore'] = (statusDateBefore instanceof Date) ?
                                    statusDateBefore.toISOString() :
                                    statusDateBefore;
                            }
                            if (userTag) {
                                localVarQueryParameter['userTag'] = userTag;
                            }
                            if (userTagMatchMode !== undefined) {
                                localVarQueryParameter['userTagMatchMode'] = userTagMatchMode;
                            }
                            if (runInputTag) {
                                localVarQueryParameter['runInputTag'] = runInputTag;
                            }
                            if (runInputTagMatchMode !== undefined) {
                                localVarQueryParameter['runInputTagMatchMode'] = runInputTagMatchMode;
                            }
                            if (runOutputTag) {
                                localVarQueryParameter['runOutputTag'] = runOutputTag;
                            }
                            if (runOutputTagMatchMode !== undefined) {
                                localVarQueryParameter['runOutputTagMatchMode'] = runOutputTagMatchMode;
                            }
                            if (connectorTag) {
                                localVarQueryParameter['connectorTag'] = connectorTag;
                            }
                            if (connectorTagMatchMode !== undefined) {
                                localVarQueryParameter['connectorTagMatchMode'] = connectorTagMatchMode;
                            }
                            if (technicalTag) {
                                localVarQueryParameter['technicalTag'] = technicalTag;
                            }
                            if (technicalTagMatchMode !== undefined) {
                                localVarQueryParameter['technicalTagMatchMode'] = technicalTagMatchMode;
                            }
                            if (notInRun !== undefined) {
                                localVarQueryParameter['notInRun'] = notInRun;
                            }
                            if (notLinkedToSample !== undefined) {
                                localVarQueryParameter['notLinkedToSample'] = notLinkedToSample;
                            }
                            if (pageOffset !== undefined) {
                                localVarQueryParameter['pageOffset'] = pageOffset;
                            }
                            if (pageToken !== undefined) {
                                localVarQueryParameter['pageToken'] = pageToken;
                            }
                            if (pageSize !== undefined) {
                                localVarQueryParameter['pageSize'] = pageSize;
                            }
                            if (sort !== undefined) {
                                localVarQueryParameter['sort'] = sort;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of projects to which this data is linked.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsLinkedToData: function (projectId, dataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectsLinkedToData', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectsLinkedToData', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}/linkedProjects"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of secondary data for data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecondaryData: function (projectId, dataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getSecondaryData', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('getSecondaryData', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}/secondaryData"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Link data to this project.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataToProject: function (projectId, dataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('linkDataToProject', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('linkDataToProject', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Remove secondary data from data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {string} secondaryDataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSecondaryData: function (projectId, dataId, secondaryDataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('removeSecondaryData', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('removeSecondaryData', 'dataId', dataId);
                            // verify required parameter 'secondaryDataId' is not null or undefined
                            (0, common_1.assertParamExists)('removeSecondaryData', 'secondaryDataId', secondaryDataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}/secondaryData/{secondaryDataId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)))
                                .replace("{".concat("secondaryDataId", "}"), encodeURIComponent(String(secondaryDataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint for scheduling a download for the data specified by the ID to a connector. This download will only start when the connector is running. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule a download.
         * @param {string} projectId
         * @param {string} dataId
         * @param {ScheduleDownload} scheduleDownload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleDownloadForData: function (projectId, dataId, scheduleDownload, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('scheduleDownloadForData', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('scheduleDownloadForData', 'dataId', dataId);
                            // verify required parameter 'scheduleDownload' is not null or undefined
                            (0, common_1.assertParamExists)('scheduleDownloadForData', 'scheduleDownload', scheduleDownload);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}:scheduleDownload"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(scheduleDownload, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint for scheduling this data for unarchival. This will also unarchive all files and directories below that data. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for unarchival.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveData: function (projectId, dataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('unarchiveData', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('unarchiveData', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}:unarchive"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink data from this project.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataFromProject: function (projectId, dataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkDataFromProject', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkDataFromProject', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}:unlink"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Fields which can be updated for files:  - data.willBeArchivedAt  - data.willBeDeletedAt  - data.format  - data.tags  Fields which can be updated for folders:  - data.tags
         * @summary Update this project data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {ProjectData} [projectData] The updated project data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectData: function (projectId, dataId, projectData, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('updateProjectData', 'projectId', projectId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('updateProjectData', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/data/{dataId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(projectData, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ProjectDataApiAxiosParamCreator = ProjectDataApiAxiosParamCreator;
/**
 * ProjectDataApi - functional programming interface
 * @export
 */
var ProjectDataApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ProjectDataApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Add secondary data to data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {string} secondaryDataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSecondaryData: function (projectId, dataId, secondaryDataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.addSecondaryData(projectId, dataId, secondaryDataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint for scheduling this data for archival. This will also archive all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for archival.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveData: function (projectId, dataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.archiveData(projectId, dataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Complete a trackable folder upload session. By completing the folder upload session, and specifying how many files you have uploaded, ICA can ensure that all uploaded files are accounted for.
         * @summary Complete a trackable folder upload session.
         * @param {string} projectId
         * @param {string} dataId
         * @param {string} folderUploadSessionId
         * @param {CompleteFolderUploadSession} [completeFolderUploadSession] The info required to complete the folder upload session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeFolderUploadSession: function (projectId, dataId, folderUploadSessionId, completeFolderUploadSession, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.completeFolderUploadSession(projectId, dataId, folderUploadSessionId, completeFolderUploadSession, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Create data in this project.
         * @param {string} projectId
         * @param {CreateData} [createData] The data to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataInProject: function (projectId, createData, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createDataInProject(projectId, createData, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Can be used to download a file directly from the region where it is located, no connector is needed.
         * @summary Retrieve a download URL for this data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDownloadUrlForData: function (projectId, dataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createDownloadUrlForData(projectId, dataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint can be used to ensure that all uploaded files within the requested session are accounted for. This call has to be used together with the :complete endpoint once upload is done.
         * @summary Create a trackable folder upload session.
         * @param {string} projectId
         * @param {string} dataId
         * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolderUploadSession: function (projectId, dataId, createTemporaryCredentials, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createFolderUploadSession(projectId, dataId, createTemporaryCredentials, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Can be used to view a file directly from the region where it is located, no connector is needed. Only small files can be viewed, otherwise a response with status 400 will be returned if the file is too big.
         * @summary Retrieve an URL for this data to use for inline view in a browser.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInlineViewUrlForData: function (projectId, dataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createInlineViewUrlForData(projectId, dataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Can be used to upload or download a file directly from the region where it is located, no connector is needed.
         * @summary Retrieve temporary credentials for this data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemporaryCredentialsForData: function (projectId, dataId, createTemporaryCredentials, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createTemporaryCredentialsForData(projectId, dataId, createTemporaryCredentials, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Can be used to upload a file directly from the region where it is located, no connector is needed. Only small files can be uploaded, otherwise a response with status 400 will be returned if the file is too big.
         * @summary Retrieve an upload URL for this data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {string} [fileType]
         * @param {string} [hash]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUploadUrlForData: function (projectId, dataId, fileType, hash, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createUploadUrlForData(projectId, dataId, fileType, hash, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint for scheduling this data for deletion. This will also delete all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for deletion.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteData: function (projectId, dataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteData(projectId, dataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of data eligible for linking to the current project.
         * @param {string} projectId
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned. This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataEligibleForLinking: function (projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getDataEligibleForLinking(projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieve folder upload session details, including the current status of your upload session.
         * @summary Retrieve folder upload session details.
         * @param {string} projectId
         * @param {string} dataId
         * @param {string} folderUploadSessionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderUploadSession: function (projectId, dataId, folderUploadSessionId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getFolderUploadSession(projectId, dataId, folderUploadSessionId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of project data not linked to a sample.
         * @param {string} projectId
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNonSampleProjectData: function (projectId, pageOffset, pageToken, pageSize, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNonSampleProjectData(projectId, pageOffset, pageToken, pageSize, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a project data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectData: function (projectId, dataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProjectData(projectId, dataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the children of this data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDataChildren: function (projectId, dataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProjectDataChildren(projectId, dataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the list of project data.
         * @param {string} projectId
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned.  This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDataList: function (projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProjectDataList(projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of projects to which this data is linked.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsLinkedToData: function (projectId, dataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProjectsLinkedToData(projectId, dataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of secondary data for data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecondaryData: function (projectId, dataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSecondaryData(projectId, dataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Link data to this project.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataToProject: function (projectId, dataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.linkDataToProject(projectId, dataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Remove secondary data from data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {string} secondaryDataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSecondaryData: function (projectId, dataId, secondaryDataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.removeSecondaryData(projectId, dataId, secondaryDataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint for scheduling a download for the data specified by the ID to a connector. This download will only start when the connector is running. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule a download.
         * @param {string} projectId
         * @param {string} dataId
         * @param {ScheduleDownload} scheduleDownload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleDownloadForData: function (projectId, dataId, scheduleDownload, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.scheduleDownloadForData(projectId, dataId, scheduleDownload, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint for scheduling this data for unarchival. This will also unarchive all files and directories below that data. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for unarchival.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveData: function (projectId, dataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unarchiveData(projectId, dataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink data from this project.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataFromProject: function (projectId, dataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unlinkDataFromProject(projectId, dataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fields which can be updated for files:  - data.willBeArchivedAt  - data.willBeDeletedAt  - data.format  - data.tags  Fields which can be updated for folders:  - data.tags
         * @summary Update this project data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {ProjectData} [projectData] The updated project data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectData: function (projectId, dataId, projectData, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateProjectData(projectId, dataId, projectData, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ProjectDataApiFp = ProjectDataApiFp;
/**
 * ProjectDataApi - factory interface
 * @export
 */
var ProjectDataApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ProjectDataApiFp)(configuration);
    return {
        /**
         *
         * @summary Add secondary data to data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {string} secondaryDataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSecondaryData: function (projectId, dataId, secondaryDataId, options) {
            return localVarFp.addSecondaryData(projectId, dataId, secondaryDataId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint for scheduling this data for archival. This will also archive all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for archival.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveData: function (projectId, dataId, options) {
            return localVarFp.archiveData(projectId, dataId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Complete a trackable folder upload session. By completing the folder upload session, and specifying how many files you have uploaded, ICA can ensure that all uploaded files are accounted for.
         * @summary Complete a trackable folder upload session.
         * @param {string} projectId
         * @param {string} dataId
         * @param {string} folderUploadSessionId
         * @param {CompleteFolderUploadSession} [completeFolderUploadSession] The info required to complete the folder upload session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeFolderUploadSession: function (projectId, dataId, folderUploadSessionId, completeFolderUploadSession, options) {
            return localVarFp.completeFolderUploadSession(projectId, dataId, folderUploadSessionId, completeFolderUploadSession, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Create data in this project.
         * @param {string} projectId
         * @param {CreateData} [createData] The data to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataInProject: function (projectId, createData, options) {
            return localVarFp.createDataInProject(projectId, createData, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Can be used to download a file directly from the region where it is located, no connector is needed.
         * @summary Retrieve a download URL for this data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDownloadUrlForData: function (projectId, dataId, options) {
            return localVarFp.createDownloadUrlForData(projectId, dataId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint can be used to ensure that all uploaded files within the requested session are accounted for. This call has to be used together with the :complete endpoint once upload is done.
         * @summary Create a trackable folder upload session.
         * @param {string} projectId
         * @param {string} dataId
         * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolderUploadSession: function (projectId, dataId, createTemporaryCredentials, options) {
            return localVarFp.createFolderUploadSession(projectId, dataId, createTemporaryCredentials, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Can be used to view a file directly from the region where it is located, no connector is needed. Only small files can be viewed, otherwise a response with status 400 will be returned if the file is too big.
         * @summary Retrieve an URL for this data to use for inline view in a browser.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInlineViewUrlForData: function (projectId, dataId, options) {
            return localVarFp.createInlineViewUrlForData(projectId, dataId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Can be used to upload or download a file directly from the region where it is located, no connector is needed.
         * @summary Retrieve temporary credentials for this data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemporaryCredentialsForData: function (projectId, dataId, createTemporaryCredentials, options) {
            return localVarFp.createTemporaryCredentialsForData(projectId, dataId, createTemporaryCredentials, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Can be used to upload a file directly from the region where it is located, no connector is needed. Only small files can be uploaded, otherwise a response with status 400 will be returned if the file is too big.
         * @summary Retrieve an upload URL for this data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {string} [fileType]
         * @param {string} [hash]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUploadUrlForData: function (projectId, dataId, fileType, hash, options) {
            return localVarFp.createUploadUrlForData(projectId, dataId, fileType, hash, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint for scheduling this data for deletion. This will also delete all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for deletion.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteData: function (projectId, dataId, options) {
            return localVarFp.deleteData(projectId, dataId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of data eligible for linking to the current project.
         * @param {string} projectId
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned. This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataEligibleForLinking: function (projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options) {
            return localVarFp.getDataEligibleForLinking(projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieve folder upload session details, including the current status of your upload session.
         * @summary Retrieve folder upload session details.
         * @param {string} projectId
         * @param {string} dataId
         * @param {string} folderUploadSessionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderUploadSession: function (projectId, dataId, folderUploadSessionId, options) {
            return localVarFp.getFolderUploadSession(projectId, dataId, folderUploadSessionId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of project data not linked to a sample.
         * @param {string} projectId
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNonSampleProjectData: function (projectId, pageOffset, pageToken, pageSize, options) {
            return localVarFp.getNonSampleProjectData(projectId, pageOffset, pageToken, pageSize, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a project data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectData: function (projectId, dataId, options) {
            return localVarFp.getProjectData(projectId, dataId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve the children of this data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDataChildren: function (projectId, dataId, options) {
            return localVarFp.getProjectDataChildren(projectId, dataId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve the list of project data.
         * @param {string} projectId
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned.  This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDataList: function (projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options) {
            return localVarFp.getProjectDataList(projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of projects to which this data is linked.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsLinkedToData: function (projectId, dataId, options) {
            return localVarFp.getProjectsLinkedToData(projectId, dataId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of secondary data for data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecondaryData: function (projectId, dataId, options) {
            return localVarFp.getSecondaryData(projectId, dataId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Link data to this project.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataToProject: function (projectId, dataId, options) {
            return localVarFp.linkDataToProject(projectId, dataId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Remove secondary data from data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {string} secondaryDataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSecondaryData: function (projectId, dataId, secondaryDataId, options) {
            return localVarFp.removeSecondaryData(projectId, dataId, secondaryDataId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint for scheduling a download for the data specified by the ID to a connector. This download will only start when the connector is running. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule a download.
         * @param {string} projectId
         * @param {string} dataId
         * @param {ScheduleDownload} scheduleDownload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleDownloadForData: function (projectId, dataId, scheduleDownload, options) {
            return localVarFp.scheduleDownloadForData(projectId, dataId, scheduleDownload, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint for scheduling this data for unarchival. This will also unarchive all files and directories below that data. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for unarchival.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveData: function (projectId, dataId, options) {
            return localVarFp.unarchiveData(projectId, dataId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Unlink data from this project.
         * @param {string} projectId
         * @param {string} dataId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataFromProject: function (projectId, dataId, options) {
            return localVarFp.unlinkDataFromProject(projectId, dataId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fields which can be updated for files:  - data.willBeArchivedAt  - data.willBeDeletedAt  - data.format  - data.tags  Fields which can be updated for folders:  - data.tags
         * @summary Update this project data.
         * @param {string} projectId
         * @param {string} dataId
         * @param {ProjectData} [projectData] The updated project data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectData: function (projectId, dataId, projectData, options) {
            return localVarFp.updateProjectData(projectId, dataId, projectData, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ProjectDataApiFactory = ProjectDataApiFactory;
/**
 * ProjectDataApi - object-oriented interface
 * @export
 * @class ProjectDataApi
 * @extends {BaseAPI}
 */
var ProjectDataApi = /** @class */ (function (_super) {
    __extends(ProjectDataApi, _super);
    function ProjectDataApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Add secondary data to data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} secondaryDataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.addSecondaryData = function (projectId, dataId, secondaryDataId, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).addSecondaryData(projectId, dataId, secondaryDataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint for scheduling this data for archival. This will also archive all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for archival.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.archiveData = function (projectId, dataId, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).archiveData(projectId, dataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Complete a trackable folder upload session. By completing the folder upload session, and specifying how many files you have uploaded, ICA can ensure that all uploaded files are accounted for.
     * @summary Complete a trackable folder upload session.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} folderUploadSessionId
     * @param {CompleteFolderUploadSession} [completeFolderUploadSession] The info required to complete the folder upload session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.completeFolderUploadSession = function (projectId, dataId, folderUploadSessionId, completeFolderUploadSession, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).completeFolderUploadSession(projectId, dataId, folderUploadSessionId, completeFolderUploadSession, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Create data in this project.
     * @param {string} projectId
     * @param {CreateData} [createData] The data to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.createDataInProject = function (projectId, createData, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).createDataInProject(projectId, createData, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Can be used to download a file directly from the region where it is located, no connector is needed.
     * @summary Retrieve a download URL for this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.createDownloadUrlForData = function (projectId, dataId, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).createDownloadUrlForData(projectId, dataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint can be used to ensure that all uploaded files within the requested session are accounted for. This call has to be used together with the :complete endpoint once upload is done.
     * @summary Create a trackable folder upload session.
     * @param {string} projectId
     * @param {string} dataId
     * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.createFolderUploadSession = function (projectId, dataId, createTemporaryCredentials, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).createFolderUploadSession(projectId, dataId, createTemporaryCredentials, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Can be used to view a file directly from the region where it is located, no connector is needed. Only small files can be viewed, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve an URL for this data to use for inline view in a browser.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.createInlineViewUrlForData = function (projectId, dataId, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).createInlineViewUrlForData(projectId, dataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Can be used to upload or download a file directly from the region where it is located, no connector is needed.
     * @summary Retrieve temporary credentials for this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.createTemporaryCredentialsForData = function (projectId, dataId, createTemporaryCredentials, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).createTemporaryCredentialsForData(projectId, dataId, createTemporaryCredentials, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Can be used to upload a file directly from the region where it is located, no connector is needed. Only small files can be uploaded, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve an upload URL for this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} [fileType]
     * @param {string} [hash]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.createUploadUrlForData = function (projectId, dataId, fileType, hash, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).createUploadUrlForData(projectId, dataId, fileType, hash, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint for scheduling this data for deletion. This will also delete all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for deletion.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.deleteData = function (projectId, dataId, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).deleteData(projectId, dataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of data eligible for linking to the current project.
     * @param {string} projectId
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned. This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.getDataEligibleForLinking = function (projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).getDataEligibleForLinking(projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieve folder upload session details, including the current status of your upload session.
     * @summary Retrieve folder upload session details.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} folderUploadSessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.getFolderUploadSession = function (projectId, dataId, folderUploadSessionId, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).getFolderUploadSession(projectId, dataId, folderUploadSessionId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of project data not linked to a sample.
     * @param {string} projectId
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.getNonSampleProjectData = function (projectId, pageOffset, pageToken, pageSize, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).getNonSampleProjectData(projectId, pageOffset, pageToken, pageSize, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a project data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.getProjectData = function (projectId, dataId, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).getProjectData(projectId, dataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve the children of this data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.getProjectDataChildren = function (projectId, dataId, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).getProjectDataChildren(projectId, dataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve the list of project data.
     * @param {string} projectId
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned.  This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.getProjectDataList = function (projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).getProjectDataList(projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of projects to which this data is linked.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.getProjectsLinkedToData = function (projectId, dataId, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).getProjectsLinkedToData(projectId, dataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of secondary data for data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.getSecondaryData = function (projectId, dataId, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).getSecondaryData(projectId, dataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Link data to this project.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.linkDataToProject = function (projectId, dataId, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).linkDataToProject(projectId, dataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Remove secondary data from data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {string} secondaryDataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.removeSecondaryData = function (projectId, dataId, secondaryDataId, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).removeSecondaryData(projectId, dataId, secondaryDataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint for scheduling a download for the data specified by the ID to a connector. This download will only start when the connector is running. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule a download.
     * @param {string} projectId
     * @param {string} dataId
     * @param {ScheduleDownload} scheduleDownload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.scheduleDownloadForData = function (projectId, dataId, scheduleDownload, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).scheduleDownloadForData(projectId, dataId, scheduleDownload, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint for scheduling this data for unarchival. This will also unarchive all files and directories below that data. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for unarchival.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.unarchiveData = function (projectId, dataId, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).unarchiveData(projectId, dataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Unlink data from this project.
     * @param {string} projectId
     * @param {string} dataId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.unlinkDataFromProject = function (projectId, dataId, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).unlinkDataFromProject(projectId, dataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fields which can be updated for files:  - data.willBeArchivedAt  - data.willBeDeletedAt  - data.format  - data.tags  Fields which can be updated for folders:  - data.tags
     * @summary Update this project data.
     * @param {string} projectId
     * @param {string} dataId
     * @param {ProjectData} [projectData] The updated project data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    ProjectDataApi.prototype.updateProjectData = function (projectId, dataId, projectData, options) {
        var _this = this;
        return (0, exports.ProjectDataApiFp)(this.configuration).updateProjectData(projectId, dataId, projectData, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ProjectDataApi;
}(base_1.BaseAPI));
exports.ProjectDataApi = ProjectDataApi;
/**
 * ProjectDataTransferApi - axios parameter creator
 * @export
 */
var ProjectDataTransferApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Endpoint for aborting a data transfer.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Abort a data transfer.
         * @param {string} projectId
         * @param {string} dataTransferId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortDataTransfer: function (projectId, dataTransferId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('abortDataTransfer', 'projectId', projectId);
                            // verify required parameter 'dataTransferId' is not null or undefined
                            (0, common_1.assertParamExists)('abortDataTransfer', 'dataTransferId', dataTransferId);
                            localVarPath = "/api/projects/{projectId}/dataTransfers/{dataTransferId}:abort"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataTransferId", "}"), encodeURIComponent(String(dataTransferId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a data transfer.
         * @param {string} projectId
         * @param {string} dataTransferId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTransfer: function (projectId, dataTransferId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getDataTransfer', 'projectId', projectId);
                            // verify required parameter 'dataTransferId' is not null or undefined
                            (0, common_1.assertParamExists)('getDataTransfer', 'dataTransferId', dataTransferId);
                            localVarPath = "/api/projects/{projectId}/dataTransfers/{dataTransferId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("dataTransferId", "}"), encodeURIComponent(String(dataTransferId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Retrieve a list of data transfers for the current app (session), excluding web browser transfers.
         * @summary Retrieve a list of data transfers.
         * @param {string} projectId
         * @param {string} [connector] The ID of the connector to filter on.
         * @param {string} [direction] The direction to filter on.
         * @param {string} [status] The status to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - direction - connector - protocol - dataTransferred - status - statusMessage - duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTransfers: function (projectId, connector, direction, status, pageOffset, pageToken, pageSize, sort, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getDataTransfers', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/dataTransfers"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (connector !== undefined) {
                                localVarQueryParameter['connector'] = connector;
                            }
                            if (direction !== undefined) {
                                localVarQueryParameter['direction'] = direction;
                            }
                            if (status !== undefined) {
                                localVarQueryParameter['status'] = status;
                            }
                            if (pageOffset !== undefined) {
                                localVarQueryParameter['pageOffset'] = pageOffset;
                            }
                            if (pageToken !== undefined) {
                                localVarQueryParameter['pageToken'] = pageToken;
                            }
                            if (pageSize !== undefined) {
                                localVarQueryParameter['pageSize'] = pageSize;
                            }
                            if (sort !== undefined) {
                                localVarQueryParameter['sort'] = sort;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ProjectDataTransferApiAxiosParamCreator = ProjectDataTransferApiAxiosParamCreator;
/**
 * ProjectDataTransferApi - functional programming interface
 * @export
 */
var ProjectDataTransferApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ProjectDataTransferApiAxiosParamCreator)(configuration);
    return {
        /**
         * Endpoint for aborting a data transfer.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Abort a data transfer.
         * @param {string} projectId
         * @param {string} dataTransferId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortDataTransfer: function (projectId, dataTransferId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.abortDataTransfer(projectId, dataTransferId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a data transfer.
         * @param {string} projectId
         * @param {string} dataTransferId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTransfer: function (projectId, dataTransferId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getDataTransfer(projectId, dataTransferId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieve a list of data transfers for the current app (session), excluding web browser transfers.
         * @summary Retrieve a list of data transfers.
         * @param {string} projectId
         * @param {string} [connector] The ID of the connector to filter on.
         * @param {string} [direction] The direction to filter on.
         * @param {string} [status] The status to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - direction - connector - protocol - dataTransferred - status - statusMessage - duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTransfers: function (projectId, connector, direction, status, pageOffset, pageToken, pageSize, sort, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getDataTransfers(projectId, connector, direction, status, pageOffset, pageToken, pageSize, sort, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ProjectDataTransferApiFp = ProjectDataTransferApiFp;
/**
 * ProjectDataTransferApi - factory interface
 * @export
 */
var ProjectDataTransferApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ProjectDataTransferApiFp)(configuration);
    return {
        /**
         * Endpoint for aborting a data transfer.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Abort a data transfer.
         * @param {string} projectId
         * @param {string} dataTransferId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortDataTransfer: function (projectId, dataTransferId, options) {
            return localVarFp.abortDataTransfer(projectId, dataTransferId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a data transfer.
         * @param {string} projectId
         * @param {string} dataTransferId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTransfer: function (projectId, dataTransferId, options) {
            return localVarFp.getDataTransfer(projectId, dataTransferId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieve a list of data transfers for the current app (session), excluding web browser transfers.
         * @summary Retrieve a list of data transfers.
         * @param {string} projectId
         * @param {string} [connector] The ID of the connector to filter on.
         * @param {string} [direction] The direction to filter on.
         * @param {string} [status] The status to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - direction - connector - protocol - dataTransferred - status - statusMessage - duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTransfers: function (projectId, connector, direction, status, pageOffset, pageToken, pageSize, sort, options) {
            return localVarFp.getDataTransfers(projectId, connector, direction, status, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ProjectDataTransferApiFactory = ProjectDataTransferApiFactory;
/**
 * ProjectDataTransferApi - object-oriented interface
 * @export
 * @class ProjectDataTransferApi
 * @extends {BaseAPI}
 */
var ProjectDataTransferApi = /** @class */ (function (_super) {
    __extends(ProjectDataTransferApi, _super);
    function ProjectDataTransferApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Endpoint for aborting a data transfer.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Abort a data transfer.
     * @param {string} projectId
     * @param {string} dataTransferId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataTransferApi
     */
    ProjectDataTransferApi.prototype.abortDataTransfer = function (projectId, dataTransferId, options) {
        var _this = this;
        return (0, exports.ProjectDataTransferApiFp)(this.configuration).abortDataTransfer(projectId, dataTransferId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a data transfer.
     * @param {string} projectId
     * @param {string} dataTransferId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataTransferApi
     */
    ProjectDataTransferApi.prototype.getDataTransfer = function (projectId, dataTransferId, options) {
        var _this = this;
        return (0, exports.ProjectDataTransferApiFp)(this.configuration).getDataTransfer(projectId, dataTransferId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieve a list of data transfers for the current app (session), excluding web browser transfers.
     * @summary Retrieve a list of data transfers.
     * @param {string} projectId
     * @param {string} [connector] The ID of the connector to filter on.
     * @param {string} [direction] The direction to filter on.
     * @param {string} [status] The status to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - direction - connector - protocol - dataTransferred - status - statusMessage - duration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataTransferApi
     */
    ProjectDataTransferApi.prototype.getDataTransfers = function (projectId, connector, direction, status, pageOffset, pageToken, pageSize, sort, options) {
        var _this = this;
        return (0, exports.ProjectDataTransferApiFp)(this.configuration).getDataTransfers(projectId, connector, direction, status, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ProjectDataTransferApi;
}(base_1.BaseAPI));
exports.ProjectDataTransferApi = ProjectDataTransferApi;
/**
 * ProjectNotificationSubscriptionsApi - axios parameter creator
 * @export
 */
var ProjectNotificationSubscriptionsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Create a notification subscription
         * @param {string} projectId The ID of the project
         * @param {CreateNotificationSubscription} [createNotificationSubscription] The new subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationSubscription1: function (projectId, createNotificationSubscription, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('createNotificationSubscription1', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/notificationSubscriptions"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createNotificationSubscription, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Delete a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationSubscription1: function (projectId, subscriptionId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteNotificationSubscription1', 'projectId', projectId);
                            // verify required parameter 'subscriptionId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteNotificationSubscription1', 'subscriptionId', subscriptionId);
                            localVarPath = "/api/projects/{projectId}/notificationSubscriptions/{subscriptionId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("subscriptionId", "}"), encodeURIComponent(String(subscriptionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscription1: function (projectId, subscriptionId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getNotificationSubscription1', 'projectId', projectId);
                            // verify required parameter 'subscriptionId' is not null or undefined
                            (0, common_1.assertParamExists)('getNotificationSubscription1', 'subscriptionId', subscriptionId);
                            localVarPath = "/api/projects/{projectId}/notificationSubscriptions/{subscriptionId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("subscriptionId", "}"), encodeURIComponent(String(subscriptionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve notification subscriptions
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscriptions1: function (projectId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getNotificationSubscriptions1', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/notificationSubscriptions"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel
         * @summary Update a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {NotificationSubscription} [notificationSubscription] The updated subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationSubscription1: function (projectId, subscriptionId, ifMatch, notificationSubscription, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('updateNotificationSubscription1', 'projectId', projectId);
                            // verify required parameter 'subscriptionId' is not null or undefined
                            (0, common_1.assertParamExists)('updateNotificationSubscription1', 'subscriptionId', subscriptionId);
                            localVarPath = "/api/projects/{projectId}/notificationSubscriptions/{subscriptionId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("subscriptionId", "}"), encodeURIComponent(String(subscriptionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (ifMatch !== undefined && ifMatch !== null) {
                                localVarHeaderParameter['If-Match'] = String(ifMatch);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(notificationSubscription, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ProjectNotificationSubscriptionsApiAxiosParamCreator = ProjectNotificationSubscriptionsApiAxiosParamCreator;
/**
 * ProjectNotificationSubscriptionsApi - functional programming interface
 * @export
 */
var ProjectNotificationSubscriptionsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ProjectNotificationSubscriptionsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a notification subscription
         * @param {string} projectId The ID of the project
         * @param {CreateNotificationSubscription} [createNotificationSubscription] The new subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationSubscription1: function (projectId, createNotificationSubscription, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createNotificationSubscription1(projectId, createNotificationSubscription, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Delete a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationSubscription1: function (projectId, subscriptionId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteNotificationSubscription1(projectId, subscriptionId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscription1: function (projectId, subscriptionId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNotificationSubscription1(projectId, subscriptionId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve notification subscriptions
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscriptions1: function (projectId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNotificationSubscriptions1(projectId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel
         * @summary Update a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {NotificationSubscription} [notificationSubscription] The updated subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationSubscription1: function (projectId, subscriptionId, ifMatch, notificationSubscription, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateNotificationSubscription1(projectId, subscriptionId, ifMatch, notificationSubscription, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ProjectNotificationSubscriptionsApiFp = ProjectNotificationSubscriptionsApiFp;
/**
 * ProjectNotificationSubscriptionsApi - factory interface
 * @export
 */
var ProjectNotificationSubscriptionsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ProjectNotificationSubscriptionsApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a notification subscription
         * @param {string} projectId The ID of the project
         * @param {CreateNotificationSubscription} [createNotificationSubscription] The new subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationSubscription1: function (projectId, createNotificationSubscription, options) {
            return localVarFp.createNotificationSubscription1(projectId, createNotificationSubscription, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Delete a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationSubscription1: function (projectId, subscriptionId, options) {
            return localVarFp.deleteNotificationSubscription1(projectId, subscriptionId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscription1: function (projectId, subscriptionId, options) {
            return localVarFp.getNotificationSubscription1(projectId, subscriptionId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve notification subscriptions
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscriptions1: function (projectId, options) {
            return localVarFp.getNotificationSubscriptions1(projectId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel
         * @summary Update a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {NotificationSubscription} [notificationSubscription] The updated subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationSubscription1: function (projectId, subscriptionId, ifMatch, notificationSubscription, options) {
            return localVarFp.updateNotificationSubscription1(projectId, subscriptionId, ifMatch, notificationSubscription, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ProjectNotificationSubscriptionsApiFactory = ProjectNotificationSubscriptionsApiFactory;
/**
 * ProjectNotificationSubscriptionsApi - object-oriented interface
 * @export
 * @class ProjectNotificationSubscriptionsApi
 * @extends {BaseAPI}
 */
var ProjectNotificationSubscriptionsApi = /** @class */ (function (_super) {
    __extends(ProjectNotificationSubscriptionsApi, _super);
    function ProjectNotificationSubscriptionsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Create a notification subscription
     * @param {string} projectId The ID of the project
     * @param {CreateNotificationSubscription} [createNotificationSubscription] The new subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectNotificationSubscriptionsApi
     */
    ProjectNotificationSubscriptionsApi.prototype.createNotificationSubscription1 = function (projectId, createNotificationSubscription, options) {
        var _this = this;
        return (0, exports.ProjectNotificationSubscriptionsApiFp)(this.configuration).createNotificationSubscription1(projectId, createNotificationSubscription, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Delete a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectNotificationSubscriptionsApi
     */
    ProjectNotificationSubscriptionsApi.prototype.deleteNotificationSubscription1 = function (projectId, subscriptionId, options) {
        var _this = this;
        return (0, exports.ProjectNotificationSubscriptionsApiFp)(this.configuration).deleteNotificationSubscription1(projectId, subscriptionId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectNotificationSubscriptionsApi
     */
    ProjectNotificationSubscriptionsApi.prototype.getNotificationSubscription1 = function (projectId, subscriptionId, options) {
        var _this = this;
        return (0, exports.ProjectNotificationSubscriptionsApiFp)(this.configuration).getNotificationSubscription1(projectId, subscriptionId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve notification subscriptions
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectNotificationSubscriptionsApi
     */
    ProjectNotificationSubscriptionsApi.prototype.getNotificationSubscriptions1 = function (projectId, options) {
        var _this = this;
        return (0, exports.ProjectNotificationSubscriptionsApiFp)(this.configuration).getNotificationSubscriptions1(projectId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel
     * @summary Update a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {NotificationSubscription} [notificationSubscription] The updated subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectNotificationSubscriptionsApi
     */
    ProjectNotificationSubscriptionsApi.prototype.updateNotificationSubscription1 = function (projectId, subscriptionId, ifMatch, notificationSubscription, options) {
        var _this = this;
        return (0, exports.ProjectNotificationSubscriptionsApiFp)(this.configuration).updateNotificationSubscription1(projectId, subscriptionId, ifMatch, notificationSubscription, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ProjectNotificationSubscriptionsApi;
}(base_1.BaseAPI));
exports.ProjectNotificationSubscriptionsApi = ProjectNotificationSubscriptionsApi;
/**
 * ProjectPermissionApi - axios parameter creator
 * @export
 */
var ProjectPermissionApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Create a project permission.
         * @param {string} projectId
         * @param {CreateProjectPermission} [createProjectPermission]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectPermission: function (projectId, createProjectPermission, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('createProjectPermission', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/permissions"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createProjectPermission, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a project permission.
         * @param {string} projectId
         * @param {string} permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPermission: function (projectId, permissionId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectPermission', 'projectId', projectId);
                            // verify required parameter 'permissionId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectPermission', 'permissionId', permissionId);
                            localVarPath = "/api/projects/{projectId}/permissions/{permissionId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("permissionId", "}"), encodeURIComponent(String(permissionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of project permissions.
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPermissions: function (projectId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectPermissions', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/permissions"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Fields which can be updated: - uploadAllowed - downloadAllowed - roleProject - roleFlow - roleBase - roleBench
         * @summary Update a project permission.
         * @param {string} projectId
         * @param {string} permissionId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {ProjectPermission} [projectPermission]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectPermission: function (projectId, permissionId, ifMatch, projectPermission, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('updateProjectPermission', 'projectId', projectId);
                            // verify required parameter 'permissionId' is not null or undefined
                            (0, common_1.assertParamExists)('updateProjectPermission', 'permissionId', permissionId);
                            localVarPath = "/api/projects/{projectId}/permissions/{permissionId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("permissionId", "}"), encodeURIComponent(String(permissionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (ifMatch !== undefined && ifMatch !== null) {
                                localVarHeaderParameter['If-Match'] = String(ifMatch);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(projectPermission, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ProjectPermissionApiAxiosParamCreator = ProjectPermissionApiAxiosParamCreator;
/**
 * ProjectPermissionApi - functional programming interface
 * @export
 */
var ProjectPermissionApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ProjectPermissionApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a project permission.
         * @param {string} projectId
         * @param {CreateProjectPermission} [createProjectPermission]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectPermission: function (projectId, createProjectPermission, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createProjectPermission(projectId, createProjectPermission, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a project permission.
         * @param {string} projectId
         * @param {string} permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPermission: function (projectId, permissionId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProjectPermission(projectId, permissionId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of project permissions.
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPermissions: function (projectId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProjectPermissions(projectId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fields which can be updated: - uploadAllowed - downloadAllowed - roleProject - roleFlow - roleBase - roleBench
         * @summary Update a project permission.
         * @param {string} projectId
         * @param {string} permissionId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {ProjectPermission} [projectPermission]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectPermission: function (projectId, permissionId, ifMatch, projectPermission, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateProjectPermission(projectId, permissionId, ifMatch, projectPermission, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ProjectPermissionApiFp = ProjectPermissionApiFp;
/**
 * ProjectPermissionApi - factory interface
 * @export
 */
var ProjectPermissionApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ProjectPermissionApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a project permission.
         * @param {string} projectId
         * @param {CreateProjectPermission} [createProjectPermission]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectPermission: function (projectId, createProjectPermission, options) {
            return localVarFp.createProjectPermission(projectId, createProjectPermission, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a project permission.
         * @param {string} projectId
         * @param {string} permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPermission: function (projectId, permissionId, options) {
            return localVarFp.getProjectPermission(projectId, permissionId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of project permissions.
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPermissions: function (projectId, options) {
            return localVarFp.getProjectPermissions(projectId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fields which can be updated: - uploadAllowed - downloadAllowed - roleProject - roleFlow - roleBase - roleBench
         * @summary Update a project permission.
         * @param {string} projectId
         * @param {string} permissionId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {ProjectPermission} [projectPermission]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectPermission: function (projectId, permissionId, ifMatch, projectPermission, options) {
            return localVarFp.updateProjectPermission(projectId, permissionId, ifMatch, projectPermission, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ProjectPermissionApiFactory = ProjectPermissionApiFactory;
/**
 * ProjectPermissionApi - object-oriented interface
 * @export
 * @class ProjectPermissionApi
 * @extends {BaseAPI}
 */
var ProjectPermissionApi = /** @class */ (function (_super) {
    __extends(ProjectPermissionApi, _super);
    function ProjectPermissionApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Create a project permission.
     * @param {string} projectId
     * @param {CreateProjectPermission} [createProjectPermission]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPermissionApi
     */
    ProjectPermissionApi.prototype.createProjectPermission = function (projectId, createProjectPermission, options) {
        var _this = this;
        return (0, exports.ProjectPermissionApiFp)(this.configuration).createProjectPermission(projectId, createProjectPermission, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a project permission.
     * @param {string} projectId
     * @param {string} permissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPermissionApi
     */
    ProjectPermissionApi.prototype.getProjectPermission = function (projectId, permissionId, options) {
        var _this = this;
        return (0, exports.ProjectPermissionApiFp)(this.configuration).getProjectPermission(projectId, permissionId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of project permissions.
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPermissionApi
     */
    ProjectPermissionApi.prototype.getProjectPermissions = function (projectId, options) {
        var _this = this;
        return (0, exports.ProjectPermissionApiFp)(this.configuration).getProjectPermissions(projectId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fields which can be updated: - uploadAllowed - downloadAllowed - roleProject - roleFlow - roleBase - roleBench
     * @summary Update a project permission.
     * @param {string} projectId
     * @param {string} permissionId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {ProjectPermission} [projectPermission]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPermissionApi
     */
    ProjectPermissionApi.prototype.updateProjectPermission = function (projectId, permissionId, ifMatch, projectPermission, options) {
        var _this = this;
        return (0, exports.ProjectPermissionApiFp)(this.configuration).updateProjectPermission(projectId, permissionId, ifMatch, projectPermission, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ProjectPermissionApi;
}(base_1.BaseAPI));
exports.ProjectPermissionApi = ProjectPermissionApi;
/**
 * ProjectPipelineApi - axios parameter creator
 * @export
 */
var ProjectPipelineApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Create a CWL pipeline within a project.
         * @param {string} projectId The ID of the project
         * @param {string} code The code of the CWL pipeline
         * @param {string} description The description of the CWL pipeline
         * @param {any} workflowCwlFile The CWL workflow file.
         * @param {any} parametersXmlFile
         * @param {string} analysisStorageId The id of the storage to use for the pipeline.
         * @param {Array<any>} [toolCwlFiles]
         * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
         * @param {Links} [links]
         * @param {string} [versionComment]
         * @param {Array<string>} [categories]
         * @param {string} [htmlDocumentation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCwlPipeline: function (projectId, code, description, workflowCwlFile, parametersXmlFile, analysisStorageId, toolCwlFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarFormParams, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('createCwlPipeline', 'projectId', projectId);
                            // verify required parameter 'code' is not null or undefined
                            (0, common_1.assertParamExists)('createCwlPipeline', 'code', code);
                            // verify required parameter 'description' is not null or undefined
                            (0, common_1.assertParamExists)('createCwlPipeline', 'description', description);
                            // verify required parameter 'workflowCwlFile' is not null or undefined
                            (0, common_1.assertParamExists)('createCwlPipeline', 'workflowCwlFile', workflowCwlFile);
                            // verify required parameter 'parametersXmlFile' is not null or undefined
                            (0, common_1.assertParamExists)('createCwlPipeline', 'parametersXmlFile', parametersXmlFile);
                            // verify required parameter 'analysisStorageId' is not null or undefined
                            (0, common_1.assertParamExists)('createCwlPipeline', 'analysisStorageId', analysisStorageId);
                            localVarPath = "/api/projects/{projectId}/pipelines:createCwlPipeline"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (code !== undefined) {
                                localVarFormParams.append('code', code);
                            }
                            if (description !== undefined) {
                                localVarFormParams.append('description', description);
                            }
                            if (workflowCwlFile !== undefined) {
                                localVarFormParams.append('workflowCwlFile', workflowCwlFile);
                            }
                            if (toolCwlFiles) {
                                toolCwlFiles.forEach(function (element) {
                                    localVarFormParams.append('toolCwlFiles', element);
                                });
                            }
                            if (parametersXmlFile !== undefined) {
                                localVarFormParams.append('parametersXmlFile', parametersXmlFile);
                            }
                            if (metadataModelFile !== undefined) {
                                localVarFormParams.append('metadataModelFile', metadataModelFile);
                            }
                            if (links !== undefined) {
                                localVarFormParams.append('links', new Blob([JSON.stringify(links)], { type: "application/json", }));
                            }
                            if (versionComment !== undefined) {
                                localVarFormParams.append('versionComment', versionComment);
                            }
                            if (categories) {
                                localVarFormParams.append('categories', categories.join(base_1.COLLECTION_FORMATS.csv));
                            }
                            if (htmlDocumentation !== undefined) {
                                localVarFormParams.append('htmlDocumentation', htmlDocumentation);
                            }
                            if (analysisStorageId !== undefined) {
                                localVarFormParams.append('analysisStorageId', analysisStorageId);
                            }
                            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = localVarFormParams;
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Create a Nextflow pipeline within a project.
         * @param {string} projectId The ID of the project
         * @param {string} code The code of the pipeline
         * @param {string} description The description of the pipeline
         * @param {any} mainNextflowFile The main Nextflow file.
         * @param {any} parametersXmlFile
         * @param {string} analysisStorageId The id of the storage to use for the pipeline.
         * @param {Array<any>} [otherNextflowFiles]
         * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
         * @param {Links} [links]
         * @param {string} [versionComment]
         * @param {Array<string>} [categories]
         * @param {string} [htmlDocumentation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNextflowPipeline: function (projectId, code, description, mainNextflowFile, parametersXmlFile, analysisStorageId, otherNextflowFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarFormParams, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('createNextflowPipeline', 'projectId', projectId);
                            // verify required parameter 'code' is not null or undefined
                            (0, common_1.assertParamExists)('createNextflowPipeline', 'code', code);
                            // verify required parameter 'description' is not null or undefined
                            (0, common_1.assertParamExists)('createNextflowPipeline', 'description', description);
                            // verify required parameter 'mainNextflowFile' is not null or undefined
                            (0, common_1.assertParamExists)('createNextflowPipeline', 'mainNextflowFile', mainNextflowFile);
                            // verify required parameter 'parametersXmlFile' is not null or undefined
                            (0, common_1.assertParamExists)('createNextflowPipeline', 'parametersXmlFile', parametersXmlFile);
                            // verify required parameter 'analysisStorageId' is not null or undefined
                            (0, common_1.assertParamExists)('createNextflowPipeline', 'analysisStorageId', analysisStorageId);
                            localVarPath = "/api/projects/{projectId}/pipelines:createNextflowPipeline"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (code !== undefined) {
                                localVarFormParams.append('code', code);
                            }
                            if (description !== undefined) {
                                localVarFormParams.append('description', description);
                            }
                            if (mainNextflowFile !== undefined) {
                                localVarFormParams.append('mainNextflowFile', mainNextflowFile);
                            }
                            if (otherNextflowFiles) {
                                otherNextflowFiles.forEach(function (element) {
                                    localVarFormParams.append('otherNextflowFiles', element);
                                });
                            }
                            if (parametersXmlFile !== undefined) {
                                localVarFormParams.append('parametersXmlFile', parametersXmlFile);
                            }
                            if (metadataModelFile !== undefined) {
                                localVarFormParams.append('metadataModelFile', metadataModelFile);
                            }
                            if (links !== undefined) {
                                localVarFormParams.append('links', new Blob([JSON.stringify(links)], { type: "application/json", }));
                            }
                            if (versionComment !== undefined) {
                                localVarFormParams.append('versionComment', versionComment);
                            }
                            if (categories) {
                                localVarFormParams.append('categories', categories.join(base_1.COLLECTION_FORMATS.csv));
                            }
                            if (htmlDocumentation !== undefined) {
                                localVarFormParams.append('htmlDocumentation', htmlDocumentation);
                            }
                            if (analysisStorageId !== undefined) {
                                localVarFormParams.append('analysisStorageId', analysisStorageId);
                            }
                            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = localVarFormParams;
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Retrieve a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the project pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipeline: function (projectId, pipelineId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectPipeline', 'projectId', projectId);
                            // verify required parameter 'pipelineId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectPipeline', 'pipelineId', pipelineId);
                            localVarPath = "/api/projects/{projectId}/pipelines/{pipelineId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("pipelineId", "}"), encodeURIComponent(String(pipelineId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Retrieve input parameters for a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve input parameters for a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the project pipeline to retrieve input parameters for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipelineInputParameters: function (projectId, pipelineId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectPipelineInputParameters', 'projectId', projectId);
                            // verify required parameter 'pipelineId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectPipelineInputParameters', 'pipelineId', pipelineId);
                            localVarPath = "/api/projects/{projectId}/pipelines/{pipelineId}/inputParameters"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("pipelineId", "}"), encodeURIComponent(String(pipelineId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve the reference sets of a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipelineReferenceSets: function (projectId, pipelineId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectPipelineReferenceSets', 'projectId', projectId);
                            // verify required parameter 'pipelineId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectPipelineReferenceSets', 'pipelineId', pipelineId);
                            localVarPath = "/api/projects/{projectId}/pipelines/{pipelineId}/referenceSets"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("pipelineId", "}"), encodeURIComponent(String(pipelineId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Retrieve a list of project pipelines. This includes pipelines from linked bundles.
         * @summary Retrieve a list of project pipelines.
         * @param {string} projectId The ID of the project to retrieve pipelines for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipelines: function (projectId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectPipelines', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/pipelines"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Link a pipeline to a project.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPipelineToProject: function (projectId, pipelineId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('linkPipelineToProject', 'projectId', projectId);
                            // verify required parameter 'pipelineId' is not null or undefined
                            (0, common_1.assertParamExists)('linkPipelineToProject', 'pipelineId', pipelineId);
                            localVarPath = "/api/projects/{projectId}/pipelines/{pipelineId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("pipelineId", "}"), encodeURIComponent(String(pipelineId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Release a pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePipeline: function (projectId, pipelineId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('releasePipeline', 'projectId', projectId);
                            // verify required parameter 'pipelineId' is not null or undefined
                            (0, common_1.assertParamExists)('releasePipeline', 'pipelineId', pipelineId);
                            localVarPath = "/api/projects/{projectId}/pipelines/{pipelineId}:release"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("pipelineId", "}"), encodeURIComponent(String(pipelineId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink a pipeline from a project.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPipelineFromProject: function (projectId, pipelineId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkPipelineFromProject', 'projectId', projectId);
                            // verify required parameter 'pipelineId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkPipelineFromProject', 'pipelineId', pipelineId);
                            localVarPath = "/api/projects/{projectId}/pipelines/{pipelineId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("pipelineId", "}"), encodeURIComponent(String(pipelineId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ProjectPipelineApiAxiosParamCreator = ProjectPipelineApiAxiosParamCreator;
/**
 * ProjectPipelineApi - functional programming interface
 * @export
 */
var ProjectPipelineApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ProjectPipelineApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a CWL pipeline within a project.
         * @param {string} projectId The ID of the project
         * @param {string} code The code of the CWL pipeline
         * @param {string} description The description of the CWL pipeline
         * @param {any} workflowCwlFile The CWL workflow file.
         * @param {any} parametersXmlFile
         * @param {string} analysisStorageId The id of the storage to use for the pipeline.
         * @param {Array<any>} [toolCwlFiles]
         * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
         * @param {Links} [links]
         * @param {string} [versionComment]
         * @param {Array<string>} [categories]
         * @param {string} [htmlDocumentation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCwlPipeline: function (projectId, code, description, workflowCwlFile, parametersXmlFile, analysisStorageId, toolCwlFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createCwlPipeline(projectId, code, description, workflowCwlFile, parametersXmlFile, analysisStorageId, toolCwlFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Create a Nextflow pipeline within a project.
         * @param {string} projectId The ID of the project
         * @param {string} code The code of the pipeline
         * @param {string} description The description of the pipeline
         * @param {any} mainNextflowFile The main Nextflow file.
         * @param {any} parametersXmlFile
         * @param {string} analysisStorageId The id of the storage to use for the pipeline.
         * @param {Array<any>} [otherNextflowFiles]
         * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
         * @param {Links} [links]
         * @param {string} [versionComment]
         * @param {Array<string>} [categories]
         * @param {string} [htmlDocumentation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNextflowPipeline: function (projectId, code, description, mainNextflowFile, parametersXmlFile, analysisStorageId, otherNextflowFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createNextflowPipeline(projectId, code, description, mainNextflowFile, parametersXmlFile, analysisStorageId, otherNextflowFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieve a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the project pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipeline: function (projectId, pipelineId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProjectPipeline(projectId, pipelineId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieve input parameters for a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve input parameters for a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the project pipeline to retrieve input parameters for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipelineInputParameters: function (projectId, pipelineId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProjectPipelineInputParameters(projectId, pipelineId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve the reference sets of a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipelineReferenceSets: function (projectId, pipelineId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProjectPipelineReferenceSets(projectId, pipelineId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieve a list of project pipelines. This includes pipelines from linked bundles.
         * @summary Retrieve a list of project pipelines.
         * @param {string} projectId The ID of the project to retrieve pipelines for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipelines: function (projectId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProjectPipelines(projectId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Link a pipeline to a project.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPipelineToProject: function (projectId, pipelineId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.linkPipelineToProject(projectId, pipelineId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Release a pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePipeline: function (projectId, pipelineId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.releasePipeline(projectId, pipelineId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink a pipeline from a project.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPipelineFromProject: function (projectId, pipelineId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unlinkPipelineFromProject(projectId, pipelineId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ProjectPipelineApiFp = ProjectPipelineApiFp;
/**
 * ProjectPipelineApi - factory interface
 * @export
 */
var ProjectPipelineApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ProjectPipelineApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a CWL pipeline within a project.
         * @param {string} projectId The ID of the project
         * @param {string} code The code of the CWL pipeline
         * @param {string} description The description of the CWL pipeline
         * @param {any} workflowCwlFile The CWL workflow file.
         * @param {any} parametersXmlFile
         * @param {string} analysisStorageId The id of the storage to use for the pipeline.
         * @param {Array<any>} [toolCwlFiles]
         * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
         * @param {Links} [links]
         * @param {string} [versionComment]
         * @param {Array<string>} [categories]
         * @param {string} [htmlDocumentation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCwlPipeline: function (projectId, code, description, workflowCwlFile, parametersXmlFile, analysisStorageId, toolCwlFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options) {
            return localVarFp.createCwlPipeline(projectId, code, description, workflowCwlFile, parametersXmlFile, analysisStorageId, toolCwlFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Create a Nextflow pipeline within a project.
         * @param {string} projectId The ID of the project
         * @param {string} code The code of the pipeline
         * @param {string} description The description of the pipeline
         * @param {any} mainNextflowFile The main Nextflow file.
         * @param {any} parametersXmlFile
         * @param {string} analysisStorageId The id of the storage to use for the pipeline.
         * @param {Array<any>} [otherNextflowFiles]
         * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
         * @param {Links} [links]
         * @param {string} [versionComment]
         * @param {Array<string>} [categories]
         * @param {string} [htmlDocumentation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNextflowPipeline: function (projectId, code, description, mainNextflowFile, parametersXmlFile, analysisStorageId, otherNextflowFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options) {
            return localVarFp.createNextflowPipeline(projectId, code, description, mainNextflowFile, parametersXmlFile, analysisStorageId, otherNextflowFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieve a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the project pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipeline: function (projectId, pipelineId, options) {
            return localVarFp.getProjectPipeline(projectId, pipelineId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieve input parameters for a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve input parameters for a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the project pipeline to retrieve input parameters for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipelineInputParameters: function (projectId, pipelineId, options) {
            return localVarFp.getProjectPipelineInputParameters(projectId, pipelineId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve the reference sets of a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipelineReferenceSets: function (projectId, pipelineId, options) {
            return localVarFp.getProjectPipelineReferenceSets(projectId, pipelineId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieve a list of project pipelines. This includes pipelines from linked bundles.
         * @summary Retrieve a list of project pipelines.
         * @param {string} projectId The ID of the project to retrieve pipelines for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipelines: function (projectId, options) {
            return localVarFp.getProjectPipelines(projectId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Link a pipeline to a project.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPipelineToProject: function (projectId, pipelineId, options) {
            return localVarFp.linkPipelineToProject(projectId, pipelineId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Release a pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePipeline: function (projectId, pipelineId, options) {
            return localVarFp.releasePipeline(projectId, pipelineId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Unlink a pipeline from a project.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPipelineFromProject: function (projectId, pipelineId, options) {
            return localVarFp.unlinkPipelineFromProject(projectId, pipelineId, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ProjectPipelineApiFactory = ProjectPipelineApiFactory;
/**
 * ProjectPipelineApi - object-oriented interface
 * @export
 * @class ProjectPipelineApi
 * @extends {BaseAPI}
 */
var ProjectPipelineApi = /** @class */ (function (_super) {
    __extends(ProjectPipelineApi, _super);
    function ProjectPipelineApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Create a CWL pipeline within a project.
     * @param {string} projectId The ID of the project
     * @param {string} code The code of the CWL pipeline
     * @param {string} description The description of the CWL pipeline
     * @param {any} workflowCwlFile The CWL workflow file.
     * @param {any} parametersXmlFile
     * @param {string} analysisStorageId The id of the storage to use for the pipeline.
     * @param {Array<any>} [toolCwlFiles]
     * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
     * @param {Links} [links]
     * @param {string} [versionComment]
     * @param {Array<string>} [categories]
     * @param {string} [htmlDocumentation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    ProjectPipelineApi.prototype.createCwlPipeline = function (projectId, code, description, workflowCwlFile, parametersXmlFile, analysisStorageId, toolCwlFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options) {
        var _this = this;
        return (0, exports.ProjectPipelineApiFp)(this.configuration).createCwlPipeline(projectId, code, description, workflowCwlFile, parametersXmlFile, analysisStorageId, toolCwlFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Create a Nextflow pipeline within a project.
     * @param {string} projectId The ID of the project
     * @param {string} code The code of the pipeline
     * @param {string} description The description of the pipeline
     * @param {any} mainNextflowFile The main Nextflow file.
     * @param {any} parametersXmlFile
     * @param {string} analysisStorageId The id of the storage to use for the pipeline.
     * @param {Array<any>} [otherNextflowFiles]
     * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
     * @param {Links} [links]
     * @param {string} [versionComment]
     * @param {Array<string>} [categories]
     * @param {string} [htmlDocumentation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    ProjectPipelineApi.prototype.createNextflowPipeline = function (projectId, code, description, mainNextflowFile, parametersXmlFile, analysisStorageId, otherNextflowFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options) {
        var _this = this;
        return (0, exports.ProjectPipelineApiFp)(this.configuration).createNextflowPipeline(projectId, code, description, mainNextflowFile, parametersXmlFile, analysisStorageId, otherNextflowFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieve a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the project pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    ProjectPipelineApi.prototype.getProjectPipeline = function (projectId, pipelineId, options) {
        var _this = this;
        return (0, exports.ProjectPipelineApiFp)(this.configuration).getProjectPipeline(projectId, pipelineId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieve input parameters for a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve input parameters for a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the project pipeline to retrieve input parameters for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    ProjectPipelineApi.prototype.getProjectPipelineInputParameters = function (projectId, pipelineId, options) {
        var _this = this;
        return (0, exports.ProjectPipelineApiFp)(this.configuration).getProjectPipelineInputParameters(projectId, pipelineId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve the reference sets of a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    ProjectPipelineApi.prototype.getProjectPipelineReferenceSets = function (projectId, pipelineId, options) {
        var _this = this;
        return (0, exports.ProjectPipelineApiFp)(this.configuration).getProjectPipelineReferenceSets(projectId, pipelineId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieve a list of project pipelines. This includes pipelines from linked bundles.
     * @summary Retrieve a list of project pipelines.
     * @param {string} projectId The ID of the project to retrieve pipelines for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    ProjectPipelineApi.prototype.getProjectPipelines = function (projectId, options) {
        var _this = this;
        return (0, exports.ProjectPipelineApiFp)(this.configuration).getProjectPipelines(projectId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Link a pipeline to a project.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    ProjectPipelineApi.prototype.linkPipelineToProject = function (projectId, pipelineId, options) {
        var _this = this;
        return (0, exports.ProjectPipelineApiFp)(this.configuration).linkPipelineToProject(projectId, pipelineId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Release a pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    ProjectPipelineApi.prototype.releasePipeline = function (projectId, pipelineId, options) {
        var _this = this;
        return (0, exports.ProjectPipelineApiFp)(this.configuration).releasePipeline(projectId, pipelineId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Unlink a pipeline from a project.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    ProjectPipelineApi.prototype.unlinkPipelineFromProject = function (projectId, pipelineId, options) {
        var _this = this;
        return (0, exports.ProjectPipelineApiFp)(this.configuration).unlinkPipelineFromProject(projectId, pipelineId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ProjectPipelineApi;
}(base_1.BaseAPI));
exports.ProjectPipelineApi = ProjectPipelineApi;
/**
 * ProjectSampleApi - axios parameter creator
 * @export
 */
var ProjectSampleApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Add a metadata model to a sample.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {string} metadataModelId The ID of the metadata model
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        addMetadataModelToSample: function (projectId, sampleId, metadataModelId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('addMetadataModelToSample', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('addMetadataModelToSample', 'sampleId', sampleId);
                            // verify required parameter 'metadataModelId' is not null or undefined
                            (0, common_1.assertParamExists)('addMetadataModelToSample', 'metadataModelId', metadataModelId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}/metadata/{metadataModelId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)))
                                .replace("{".concat("metadataModelId", "}"), encodeURIComponent(String(metadataModelId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Completes the sample after data has been linked to it. The sample status will be set to \'Available\' and a sample completed event will be triggered as well.
         * @summary Completes the sample after data has been linked to it.
         * @param {string} projectId
         * @param {string} sampleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeProjectSample: function (projectId, sampleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('completeProjectSample', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('completeProjectSample', 'sampleId', sampleId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}:complete"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Create a new sample in this project
         * @param {string} projectId
         * @param {CreateSample} [createSample]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSampleInProject: function (projectId, createSample, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('createSampleInProject', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/samples"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createSample, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint deleting a sample together with all of its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample together with all of its data.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deepDeleteSample: function (projectId, sampleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('deepDeleteSample', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('deepDeleteSample', 'sampleId', sampleId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}:deleteDeep"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint for deleting a sample while unlinking its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample and unlink its data.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAndUnlinkSample: function (projectId, sampleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteAndUnlinkSample', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteAndUnlinkSample', 'sampleId', sampleId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}:deleteUnlink"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint for deleting a sample as well as its input data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample as well as its input data.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSampleWithInput: function (projectId, sampleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteSampleWithInput', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteSampleWithInput', 'sampleId', sampleId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}:deleteWithInput"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a project sample.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSample: function (projectId, sampleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectSample', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectSample', 'sampleId', sampleId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint for retrieving project samples. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Retrieve project samples.
         * @param {string} projectId
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {FindProjectSamples} [findProjectSamples]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSamples: function (projectId, pageOffset, pageToken, pageSize, sort, findProjectSamples, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectSamples', 'projectId', projectId);
                            localVarPath = "/api/projects/{projectId}/samples:search"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (pageOffset !== undefined) {
                                localVarQueryParameter['pageOffset'] = pageOffset;
                            }
                            if (pageToken !== undefined) {
                                localVarQueryParameter['pageToken'] = pageToken;
                            }
                            if (pageSize !== undefined) {
                                localVarQueryParameter['pageSize'] = pageSize;
                            }
                            if (sort !== undefined) {
                                localVarQueryParameter['sort'] = sort;
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(findProjectSamples, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of projects for this sample.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForSample: function (projectId, sampleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectsForSample', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('getProjectsForSample', 'sampleId', sampleId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}/projects"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the list of sample data.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample to retrieve data for
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleDataList: function (projectId, sampleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, pageOffset, pageToken, pageSize, sort, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getSampleDataList', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('getSampleDataList', 'sampleId', sampleId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}/data"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (fullText !== undefined) {
                                localVarQueryParameter['fullText'] = fullText;
                            }
                            if (id) {
                                localVarQueryParameter['id'] = id;
                            }
                            if (filename) {
                                localVarQueryParameter['filename'] = filename;
                            }
                            if (filenameMatchMode !== undefined) {
                                localVarQueryParameter['filenameMatchMode'] = filenameMatchMode;
                            }
                            if (filePath) {
                                localVarQueryParameter['filePath'] = filePath;
                            }
                            if (filePathMatchMode !== undefined) {
                                localVarQueryParameter['filePathMatchMode'] = filePathMatchMode;
                            }
                            if (status) {
                                localVarQueryParameter['status'] = status;
                            }
                            if (formatId) {
                                localVarQueryParameter['formatId'] = formatId;
                            }
                            if (formatCode) {
                                localVarQueryParameter['formatCode'] = formatCode;
                            }
                            if (type !== undefined) {
                                localVarQueryParameter['type'] = type;
                            }
                            if (parentFolderId) {
                                localVarQueryParameter['parentFolderId'] = parentFolderId;
                            }
                            if (parentFolderPath !== undefined) {
                                localVarQueryParameter['parentFolderPath'] = parentFolderPath;
                            }
                            if (creationDateAfter !== undefined) {
                                localVarQueryParameter['creationDateAfter'] = (creationDateAfter instanceof Date) ?
                                    creationDateAfter.toISOString() :
                                    creationDateAfter;
                            }
                            if (creationDateBefore !== undefined) {
                                localVarQueryParameter['creationDateBefore'] = (creationDateBefore instanceof Date) ?
                                    creationDateBefore.toISOString() :
                                    creationDateBefore;
                            }
                            if (statusDateAfter !== undefined) {
                                localVarQueryParameter['statusDateAfter'] = (statusDateAfter instanceof Date) ?
                                    statusDateAfter.toISOString() :
                                    statusDateAfter;
                            }
                            if (statusDateBefore !== undefined) {
                                localVarQueryParameter['statusDateBefore'] = (statusDateBefore instanceof Date) ?
                                    statusDateBefore.toISOString() :
                                    statusDateBefore;
                            }
                            if (userTag) {
                                localVarQueryParameter['userTag'] = userTag;
                            }
                            if (userTagMatchMode !== undefined) {
                                localVarQueryParameter['userTagMatchMode'] = userTagMatchMode;
                            }
                            if (runInputTag) {
                                localVarQueryParameter['runInputTag'] = runInputTag;
                            }
                            if (runInputTagMatchMode !== undefined) {
                                localVarQueryParameter['runInputTagMatchMode'] = runInputTagMatchMode;
                            }
                            if (runOutputTag) {
                                localVarQueryParameter['runOutputTag'] = runOutputTag;
                            }
                            if (runOutputTagMatchMode !== undefined) {
                                localVarQueryParameter['runOutputTagMatchMode'] = runOutputTagMatchMode;
                            }
                            if (connectorTag) {
                                localVarQueryParameter['connectorTag'] = connectorTag;
                            }
                            if (connectorTagMatchMode !== undefined) {
                                localVarQueryParameter['connectorTagMatchMode'] = connectorTagMatchMode;
                            }
                            if (technicalTag) {
                                localVarQueryParameter['technicalTag'] = technicalTag;
                            }
                            if (technicalTagMatchMode !== undefined) {
                                localVarQueryParameter['technicalTagMatchMode'] = technicalTagMatchMode;
                            }
                            if (notInRun !== undefined) {
                                localVarQueryParameter['notInRun'] = notInRun;
                            }
                            if (pageOffset !== undefined) {
                                localVarQueryParameter['pageOffset'] = pageOffset;
                            }
                            if (pageToken !== undefined) {
                                localVarQueryParameter['pageToken'] = pageToken;
                            }
                            if (pageSize !== undefined) {
                                localVarQueryParameter['pageSize'] = pageSize;
                            }
                            if (sort !== undefined) {
                                localVarQueryParameter['sort'] = sort;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve sample history.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleHistory: function (projectId, sampleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getSampleHistory', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('getSampleHistory', 'sampleId', sampleId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}/history"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
         * @summary Retrieve a metadata field.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {string} fieldId The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleMetadataField: function (projectId, sampleId, fieldId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getSampleMetadataField', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('getSampleMetadataField', 'sampleId', sampleId);
                            // verify required parameter 'fieldId' is not null or undefined
                            (0, common_1.assertParamExists)('getSampleMetadataField', 'fieldId', fieldId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}/metadata/field/{fieldId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)))
                                .replace("{".concat("fieldId", "}"), encodeURIComponent(String(fieldId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
         * @summary Retrieves the number of occurrences of a given field.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {string} fieldId The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleMetadataFieldCount: function (projectId, sampleId, fieldId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('getSampleMetadataFieldCount', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('getSampleMetadataFieldCount', 'sampleId', sampleId);
                            // verify required parameter 'fieldId' is not null or undefined
                            (0, common_1.assertParamExists)('getSampleMetadataFieldCount', 'fieldId', fieldId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}/metadata/{fieldId}/fieldCount"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)))
                                .replace("{".concat("fieldId", "}"), encodeURIComponent(String(fieldId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Link data to a sample.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {string} dataId The ID of the data to link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataToSample: function (projectId, sampleId, dataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('linkDataToSample', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('linkDataToSample', 'sampleId', sampleId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('linkDataToSample', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}/data/{dataId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Link a sample to a project.
         * @param {string} projectId
         * @param {string} sampleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkSampleToProject: function (projectId, sampleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('linkSampleToProject', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('linkSampleToProject', 'sampleId', sampleId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint for marking a sample as deleted.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Mark a sample deleted.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markSampleDeleted: function (projectId, sampleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('markSampleDeleted', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('markSampleDeleted', 'sampleId', sampleId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}:deleteMark"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink data from a sample.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {string} dataId The ID of the data to unlink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataFromSample: function (projectId, sampleId, dataId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkDataFromSample', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkDataFromSample', 'sampleId', sampleId);
                            // verify required parameter 'dataId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkDataFromSample', 'dataId', dataId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}/data/{dataId}:unlink"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)))
                                .replace("{".concat("dataId", "}"), encodeURIComponent(String(dataId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink a sample from a project.
         * @param {string} projectId
         * @param {string} sampleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkSampleFromProject: function (projectId, sampleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkSampleFromProject', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('unlinkSampleFromProject', 'sampleId', sampleId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}:unlink"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Fields which can be updated: - sample.name - sample.description - sample.status - sample.tags
         * @summary Update a project sample.
         * @param {string} projectId
         * @param {string} sampleId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {ProjectSample} [projectSample]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSample: function (projectId, sampleId, ifMatch, projectSample, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('updateProjectSample', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('updateProjectSample', 'sampleId', sampleId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (ifMatch !== undefined && ifMatch !== null) {
                                localVarHeaderParameter['If-Match'] = String(ifMatch);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(projectSample, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint for updating metadata fields.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Update metadata fields.
         * @param {string} projectId
         * @param {string} sampleId
         * @param {UpdateMetadata} [updateMetadata]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSampleMetadataFields: function (projectId, sampleId, updateMetadata, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            (0, common_1.assertParamExists)('updateSampleMetadataFields', 'projectId', projectId);
                            // verify required parameter 'sampleId' is not null or undefined
                            (0, common_1.assertParamExists)('updateSampleMetadataFields', 'sampleId', sampleId);
                            localVarPath = "/api/projects/{projectId}/samples/{sampleId}/metadata:updateFields"
                                .replace("{".concat("projectId", "}"), encodeURIComponent(String(projectId)))
                                .replace("{".concat("sampleId", "}"), encodeURIComponent(String(sampleId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateMetadata, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ProjectSampleApiAxiosParamCreator = ProjectSampleApiAxiosParamCreator;
/**
 * ProjectSampleApi - functional programming interface
 * @export
 */
var ProjectSampleApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ProjectSampleApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Add a metadata model to a sample.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {string} metadataModelId The ID of the metadata model
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        addMetadataModelToSample: function (projectId, sampleId, metadataModelId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.addMetadataModelToSample(projectId, sampleId, metadataModelId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Completes the sample after data has been linked to it. The sample status will be set to \'Available\' and a sample completed event will be triggered as well.
         * @summary Completes the sample after data has been linked to it.
         * @param {string} projectId
         * @param {string} sampleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeProjectSample: function (projectId, sampleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.completeProjectSample(projectId, sampleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Create a new sample in this project
         * @param {string} projectId
         * @param {CreateSample} [createSample]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSampleInProject: function (projectId, createSample, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createSampleInProject(projectId, createSample, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint deleting a sample together with all of its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample together with all of its data.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deepDeleteSample: function (projectId, sampleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deepDeleteSample(projectId, sampleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint for deleting a sample while unlinking its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample and unlink its data.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAndUnlinkSample: function (projectId, sampleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteAndUnlinkSample(projectId, sampleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint for deleting a sample as well as its input data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample as well as its input data.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSampleWithInput: function (projectId, sampleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteSampleWithInput(projectId, sampleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a project sample.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSample: function (projectId, sampleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProjectSample(projectId, sampleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint for retrieving project samples. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Retrieve project samples.
         * @param {string} projectId
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {FindProjectSamples} [findProjectSamples]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSamples: function (projectId, pageOffset, pageToken, pageSize, sort, findProjectSamples, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProjectSamples(projectId, pageOffset, pageToken, pageSize, sort, findProjectSamples, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of projects for this sample.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForSample: function (projectId, sampleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProjectsForSample(projectId, sampleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve the list of sample data.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample to retrieve data for
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleDataList: function (projectId, sampleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, pageOffset, pageToken, pageSize, sort, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSampleDataList(projectId, sampleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, pageOffset, pageToken, pageSize, sort, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve sample history.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleHistory: function (projectId, sampleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSampleHistory(projectId, sampleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
         * @summary Retrieve a metadata field.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {string} fieldId The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleMetadataField: function (projectId, sampleId, fieldId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSampleMetadataField(projectId, sampleId, fieldId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
         * @summary Retrieves the number of occurrences of a given field.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {string} fieldId The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleMetadataFieldCount: function (projectId, sampleId, fieldId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSampleMetadataFieldCount(projectId, sampleId, fieldId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Link data to a sample.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {string} dataId The ID of the data to link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataToSample: function (projectId, sampleId, dataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.linkDataToSample(projectId, sampleId, dataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Link a sample to a project.
         * @param {string} projectId
         * @param {string} sampleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkSampleToProject: function (projectId, sampleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.linkSampleToProject(projectId, sampleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint for marking a sample as deleted.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Mark a sample deleted.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markSampleDeleted: function (projectId, sampleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.markSampleDeleted(projectId, sampleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink data from a sample.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {string} dataId The ID of the data to unlink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataFromSample: function (projectId, sampleId, dataId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unlinkDataFromSample(projectId, sampleId, dataId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Unlink a sample from a project.
         * @param {string} projectId
         * @param {string} sampleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkSampleFromProject: function (projectId, sampleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unlinkSampleFromProject(projectId, sampleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fields which can be updated: - sample.name - sample.description - sample.status - sample.tags
         * @summary Update a project sample.
         * @param {string} projectId
         * @param {string} sampleId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {ProjectSample} [projectSample]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSample: function (projectId, sampleId, ifMatch, projectSample, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateProjectSample(projectId, sampleId, ifMatch, projectSample, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint for updating metadata fields.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Update metadata fields.
         * @param {string} projectId
         * @param {string} sampleId
         * @param {UpdateMetadata} [updateMetadata]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSampleMetadataFields: function (projectId, sampleId, updateMetadata, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateSampleMetadataFields(projectId, sampleId, updateMetadata, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ProjectSampleApiFp = ProjectSampleApiFp;
/**
 * ProjectSampleApi - factory interface
 * @export
 */
var ProjectSampleApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ProjectSampleApiFp)(configuration);
    return {
        /**
         *
         * @summary Add a metadata model to a sample.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {string} metadataModelId The ID of the metadata model
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        addMetadataModelToSample: function (projectId, sampleId, metadataModelId, options) {
            return localVarFp.addMetadataModelToSample(projectId, sampleId, metadataModelId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Completes the sample after data has been linked to it. The sample status will be set to \'Available\' and a sample completed event will be triggered as well.
         * @summary Completes the sample after data has been linked to it.
         * @param {string} projectId
         * @param {string} sampleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeProjectSample: function (projectId, sampleId, options) {
            return localVarFp.completeProjectSample(projectId, sampleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Create a new sample in this project
         * @param {string} projectId
         * @param {CreateSample} [createSample]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSampleInProject: function (projectId, createSample, options) {
            return localVarFp.createSampleInProject(projectId, createSample, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint deleting a sample together with all of its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample together with all of its data.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deepDeleteSample: function (projectId, sampleId, options) {
            return localVarFp.deepDeleteSample(projectId, sampleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint for deleting a sample while unlinking its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample and unlink its data.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAndUnlinkSample: function (projectId, sampleId, options) {
            return localVarFp.deleteAndUnlinkSample(projectId, sampleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint for deleting a sample as well as its input data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample as well as its input data.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSampleWithInput: function (projectId, sampleId, options) {
            return localVarFp.deleteSampleWithInput(projectId, sampleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a project sample.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSample: function (projectId, sampleId, options) {
            return localVarFp.getProjectSample(projectId, sampleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint for retrieving project samples. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Retrieve project samples.
         * @param {string} projectId
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {FindProjectSamples} [findProjectSamples]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSamples: function (projectId, pageOffset, pageToken, pageSize, sort, findProjectSamples, options) {
            return localVarFp.getProjectSamples(projectId, pageOffset, pageToken, pageSize, sort, findProjectSamples, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of projects for this sample.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForSample: function (projectId, sampleId, options) {
            return localVarFp.getProjectsForSample(projectId, sampleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve the list of sample data.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample to retrieve data for
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleDataList: function (projectId, sampleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, pageOffset, pageToken, pageSize, sort, options) {
            return localVarFp.getSampleDataList(projectId, sampleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve sample history.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleHistory: function (projectId, sampleId, options) {
            return localVarFp.getSampleHistory(projectId, sampleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
         * @summary Retrieve a metadata field.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {string} fieldId The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleMetadataField: function (projectId, sampleId, fieldId, options) {
            return localVarFp.getSampleMetadataField(projectId, sampleId, fieldId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
         * @summary Retrieves the number of occurrences of a given field.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {string} fieldId The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleMetadataFieldCount: function (projectId, sampleId, fieldId, options) {
            return localVarFp.getSampleMetadataFieldCount(projectId, sampleId, fieldId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Link data to a sample.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {string} dataId The ID of the data to link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataToSample: function (projectId, sampleId, dataId, options) {
            return localVarFp.linkDataToSample(projectId, sampleId, dataId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Link a sample to a project.
         * @param {string} projectId
         * @param {string} sampleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkSampleToProject: function (projectId, sampleId, options) {
            return localVarFp.linkSampleToProject(projectId, sampleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint for marking a sample as deleted.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Mark a sample deleted.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markSampleDeleted: function (projectId, sampleId, options) {
            return localVarFp.markSampleDeleted(projectId, sampleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Unlink data from a sample.
         * @param {string} projectId
         * @param {string} sampleId The ID of the sample
         * @param {string} dataId The ID of the data to unlink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataFromSample: function (projectId, sampleId, dataId, options) {
            return localVarFp.unlinkDataFromSample(projectId, sampleId, dataId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Unlink a sample from a project.
         * @param {string} projectId
         * @param {string} sampleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkSampleFromProject: function (projectId, sampleId, options) {
            return localVarFp.unlinkSampleFromProject(projectId, sampleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fields which can be updated: - sample.name - sample.description - sample.status - sample.tags
         * @summary Update a project sample.
         * @param {string} projectId
         * @param {string} sampleId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {ProjectSample} [projectSample]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSample: function (projectId, sampleId, ifMatch, projectSample, options) {
            return localVarFp.updateProjectSample(projectId, sampleId, ifMatch, projectSample, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint for updating metadata fields.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Update metadata fields.
         * @param {string} projectId
         * @param {string} sampleId
         * @param {UpdateMetadata} [updateMetadata]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSampleMetadataFields: function (projectId, sampleId, updateMetadata, options) {
            return localVarFp.updateSampleMetadataFields(projectId, sampleId, updateMetadata, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ProjectSampleApiFactory = ProjectSampleApiFactory;
/**
 * ProjectSampleApi - object-oriented interface
 * @export
 * @class ProjectSampleApi
 * @extends {BaseAPI}
 */
var ProjectSampleApi = /** @class */ (function (_super) {
    __extends(ProjectSampleApi, _super);
    function ProjectSampleApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Add a metadata model to a sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} metadataModelId The ID of the metadata model
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.addMetadataModelToSample = function (projectId, sampleId, metadataModelId, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).addMetadataModelToSample(projectId, sampleId, metadataModelId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Completes the sample after data has been linked to it. The sample status will be set to \'Available\' and a sample completed event will be triggered as well.
     * @summary Completes the sample after data has been linked to it.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.completeProjectSample = function (projectId, sampleId, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).completeProjectSample(projectId, sampleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Create a new sample in this project
     * @param {string} projectId
     * @param {CreateSample} [createSample]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.createSampleInProject = function (projectId, createSample, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).createSampleInProject(projectId, createSample, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint deleting a sample together with all of its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample together with all of its data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.deepDeleteSample = function (projectId, sampleId, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).deepDeleteSample(projectId, sampleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint for deleting a sample while unlinking its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample and unlink its data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.deleteAndUnlinkSample = function (projectId, sampleId, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).deleteAndUnlinkSample(projectId, sampleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint for deleting a sample as well as its input data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample as well as its input data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.deleteSampleWithInput = function (projectId, sampleId, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).deleteSampleWithInput(projectId, sampleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a project sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.getProjectSample = function (projectId, sampleId, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).getProjectSample(projectId, sampleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint for retrieving project samples. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Retrieve project samples.
     * @param {string} projectId
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {FindProjectSamples} [findProjectSamples]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.getProjectSamples = function (projectId, pageOffset, pageToken, pageSize, sort, findProjectSamples, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).getProjectSamples(projectId, pageOffset, pageToken, pageSize, sort, findProjectSamples, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of projects for this sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.getProjectsForSample = function (projectId, sampleId, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).getProjectsForSample(projectId, sampleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve the list of sample data.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample to retrieve data for
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.getSampleDataList = function (projectId, sampleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, pageOffset, pageToken, pageSize, sort, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).getSampleDataList(projectId, sampleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve sample history.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.getSampleHistory = function (projectId, sampleId, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).getSampleHistory(projectId, sampleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
     * @summary Retrieve a metadata field.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} fieldId The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.getSampleMetadataField = function (projectId, sampleId, fieldId, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).getSampleMetadataField(projectId, sampleId, fieldId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
     * @summary Retrieves the number of occurrences of a given field.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} fieldId The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.getSampleMetadataFieldCount = function (projectId, sampleId, fieldId, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).getSampleMetadataFieldCount(projectId, sampleId, fieldId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Link data to a sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} dataId The ID of the data to link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.linkDataToSample = function (projectId, sampleId, dataId, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).linkDataToSample(projectId, sampleId, dataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Link a sample to a project.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.linkSampleToProject = function (projectId, sampleId, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).linkSampleToProject(projectId, sampleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint for marking a sample as deleted.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Mark a sample deleted.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.markSampleDeleted = function (projectId, sampleId, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).markSampleDeleted(projectId, sampleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Unlink data from a sample.
     * @param {string} projectId
     * @param {string} sampleId The ID of the sample
     * @param {string} dataId The ID of the data to unlink
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.unlinkDataFromSample = function (projectId, sampleId, dataId, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).unlinkDataFromSample(projectId, sampleId, dataId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Unlink a sample from a project.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.unlinkSampleFromProject = function (projectId, sampleId, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).unlinkSampleFromProject(projectId, sampleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fields which can be updated: - sample.name - sample.description - sample.status - sample.tags
     * @summary Update a project sample.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {ProjectSample} [projectSample]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.updateProjectSample = function (projectId, sampleId, ifMatch, projectSample, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).updateProjectSample(projectId, sampleId, ifMatch, projectSample, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint for updating metadata fields.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Update metadata fields.
     * @param {string} projectId
     * @param {string} sampleId
     * @param {UpdateMetadata} [updateMetadata]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    ProjectSampleApi.prototype.updateSampleMetadataFields = function (projectId, sampleId, updateMetadata, options) {
        var _this = this;
        return (0, exports.ProjectSampleApiFp)(this.configuration).updateSampleMetadataFields(projectId, sampleId, updateMetadata, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ProjectSampleApi;
}(base_1.BaseAPI));
exports.ProjectSampleApi = ProjectSampleApi;
/**
 * RegionApi - axios parameter creator
 * @export
 */
var RegionApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve a region. Only the regions the user has access to through his/her entitlements can be retrieved.
         * @param {string} regionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegion: function (regionId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'regionId' is not null or undefined
                            (0, common_1.assertParamExists)('getRegion', 'regionId', regionId);
                            localVarPath = "/api/regions/{regionId}"
                                .replace("{".concat("regionId", "}"), encodeURIComponent(String(regionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of regions. Only the regions the user has access to through his/her entitlements are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegions: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/regions";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.RegionApiAxiosParamCreator = RegionApiAxiosParamCreator;
/**
 * RegionApi - functional programming interface
 * @export
 */
var RegionApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.RegionApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve a region. Only the regions the user has access to through his/her entitlements can be retrieved.
         * @param {string} regionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegion: function (regionId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getRegion(regionId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of regions. Only the regions the user has access to through his/her entitlements are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegions: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getRegions(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.RegionApiFp = RegionApiFp;
/**
 * RegionApi - factory interface
 * @export
 */
var RegionApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.RegionApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve a region. Only the regions the user has access to through his/her entitlements can be retrieved.
         * @param {string} regionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegion: function (regionId, options) {
            return localVarFp.getRegion(regionId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of regions. Only the regions the user has access to through his/her entitlements are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegions: function (options) {
            return localVarFp.getRegions(options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.RegionApiFactory = RegionApiFactory;
/**
 * RegionApi - object-oriented interface
 * @export
 * @class RegionApi
 * @extends {BaseAPI}
 */
var RegionApi = /** @class */ (function (_super) {
    __extends(RegionApi, _super);
    function RegionApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve a region. Only the regions the user has access to through his/her entitlements can be retrieved.
     * @param {string} regionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    RegionApi.prototype.getRegion = function (regionId, options) {
        var _this = this;
        return (0, exports.RegionApiFp)(this.configuration).getRegion(regionId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of regions. Only the regions the user has access to through his/her entitlements are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    RegionApi.prototype.getRegions = function (options) {
        var _this = this;
        return (0, exports.RegionApiFp)(this.configuration).getRegions(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return RegionApi;
}(base_1.BaseAPI));
exports.RegionApi = RegionApi;
/**
 * SampleApi - axios parameter creator
 * @export
 */
var SampleApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve a list of samples.
         * @param {string} region The ID of the region to filter on. This parameter is required.
         * @param {string} [search] To search through multiple fields of data.
         * @param {string} [userTags] The user tags to filter on.
         * @param {string} [technicalTags] The technical tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamples: function (region, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'region' is not null or undefined
                            (0, common_1.assertParamExists)('getSamples', 'region', region);
                            localVarPath = "/api/samples";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (region !== undefined) {
                                localVarQueryParameter['region'] = region;
                            }
                            if (search !== undefined) {
                                localVarQueryParameter['search'] = search;
                            }
                            if (userTags !== undefined) {
                                localVarQueryParameter['userTags'] = userTags;
                            }
                            if (technicalTags !== undefined) {
                                localVarQueryParameter['technicalTags'] = technicalTags;
                            }
                            if (pageOffset !== undefined) {
                                localVarQueryParameter['pageOffset'] = pageOffset;
                            }
                            if (pageToken !== undefined) {
                                localVarQueryParameter['pageToken'] = pageToken;
                            }
                            if (pageSize !== undefined) {
                                localVarQueryParameter['pageSize'] = pageSize;
                            }
                            if (sort !== undefined) {
                                localVarQueryParameter['sort'] = sort;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.SampleApiAxiosParamCreator = SampleApiAxiosParamCreator;
/**
 * SampleApi - functional programming interface
 * @export
 */
var SampleApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.SampleApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve a list of samples.
         * @param {string} region The ID of the region to filter on. This parameter is required.
         * @param {string} [search] To search through multiple fields of data.
         * @param {string} [userTags] The user tags to filter on.
         * @param {string} [technicalTags] The technical tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamples: function (region, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSamples(region, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.SampleApiFp = SampleApiFp;
/**
 * SampleApi - factory interface
 * @export
 */
var SampleApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.SampleApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve a list of samples.
         * @param {string} region The ID of the region to filter on. This parameter is required.
         * @param {string} [search] To search through multiple fields of data.
         * @param {string} [userTags] The user tags to filter on.
         * @param {string} [technicalTags] The technical tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamples: function (region, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options) {
            return localVarFp.getSamples(region, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.SampleApiFactory = SampleApiFactory;
/**
 * SampleApi - object-oriented interface
 * @export
 * @class SampleApi
 * @extends {BaseAPI}
 */
var SampleApi = /** @class */ (function (_super) {
    __extends(SampleApi, _super);
    function SampleApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve a list of samples.
     * @param {string} region The ID of the region to filter on. This parameter is required.
     * @param {string} [search] To search through multiple fields of data.
     * @param {string} [userTags] The user tags to filter on.
     * @param {string} [technicalTags] The technical tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SampleApi
     */
    SampleApi.prototype.getSamples = function (region, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options) {
        var _this = this;
        return (0, exports.SampleApiFp)(this.configuration).getSamples(region, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return SampleApi;
}(base_1.BaseAPI));
exports.SampleApi = SampleApi;
/**
 * StorageBundleApi - axios parameter creator
 * @export
 */
var StorageBundleApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve a list of storage bundles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageBundles: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/storageBundles";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.StorageBundleApiAxiosParamCreator = StorageBundleApiAxiosParamCreator;
/**
 * StorageBundleApi - functional programming interface
 * @export
 */
var StorageBundleApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.StorageBundleApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve a list of storage bundles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageBundles: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getStorageBundles(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.StorageBundleApiFp = StorageBundleApiFp;
/**
 * StorageBundleApi - factory interface
 * @export
 */
var StorageBundleApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.StorageBundleApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve a list of storage bundles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageBundles: function (options) {
            return localVarFp.getStorageBundles(options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.StorageBundleApiFactory = StorageBundleApiFactory;
/**
 * StorageBundleApi - object-oriented interface
 * @export
 * @class StorageBundleApi
 * @extends {BaseAPI}
 */
var StorageBundleApi = /** @class */ (function (_super) {
    __extends(StorageBundleApi, _super);
    function StorageBundleApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve a list of storage bundles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageBundleApi
     */
    StorageBundleApi.prototype.getStorageBundles = function (options) {
        var _this = this;
        return (0, exports.StorageBundleApiFp)(this.configuration).getStorageBundles(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return StorageBundleApi;
}(base_1.BaseAPI));
exports.StorageBundleApi = StorageBundleApi;
/**
 * StorageConfigurationApi - axios parameter creator
 * @export
 */
var StorageConfigurationApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Create a new storage configuration
         * @param {CreateStorageConfiguration} [createStorageConfiguration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorageConfiguration: function (createStorageConfiguration, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/storageConfigurations";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createStorageConfiguration, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a storage configuration.
         * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageConfiguration: function (storageConfigurationId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'storageConfigurationId' is not null or undefined
                            (0, common_1.assertParamExists)('getStorageConfiguration', 'storageConfigurationId', storageConfigurationId);
                            localVarPath = "/api/storageConfigurations/{storageConfigurationId}"
                                .replace("{".concat("storageConfigurationId", "}"), encodeURIComponent(String(storageConfigurationId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a storage configuration detail.
         * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageConfigurationDetails: function (storageConfigurationId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'storageConfigurationId' is not null or undefined
                            (0, common_1.assertParamExists)('getStorageConfigurationDetails', 'storageConfigurationId', storageConfigurationId);
                            localVarPath = "/api/storageConfigurations/{storageConfigurationId}/details"
                                .replace("{".concat("storageConfigurationId", "}"), encodeURIComponent(String(storageConfigurationId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of storage configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageConfigurations: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/storageConfigurations";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Here you share your own storage configuration with all the other users in your tenant.
         * @summary Share your own storage configuration with tenant.
         * @param {string} storageConfigurationId The ID of the storage configuration to share
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareStorageConfiguration: function (storageConfigurationId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'storageConfigurationId' is not null or undefined
                            (0, common_1.assertParamExists)('shareStorageConfiguration', 'storageConfigurationId', storageConfigurationId);
                            localVarPath = "/api/storageConfigurations/{storageConfigurationId}:share"
                                .replace("{".concat("storageConfigurationId", "}"), encodeURIComponent(String(storageConfigurationId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.StorageConfigurationApiAxiosParamCreator = StorageConfigurationApiAxiosParamCreator;
/**
 * StorageConfigurationApi - functional programming interface
 * @export
 */
var StorageConfigurationApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.StorageConfigurationApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a new storage configuration
         * @param {CreateStorageConfiguration} [createStorageConfiguration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorageConfiguration: function (createStorageConfiguration, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createStorageConfiguration(createStorageConfiguration, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a storage configuration.
         * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageConfiguration: function (storageConfigurationId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getStorageConfiguration(storageConfigurationId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a storage configuration detail.
         * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageConfigurationDetails: function (storageConfigurationId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getStorageConfigurationDetails(storageConfigurationId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of storage configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageConfigurations: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getStorageConfigurations(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Here you share your own storage configuration with all the other users in your tenant.
         * @summary Share your own storage configuration with tenant.
         * @param {string} storageConfigurationId The ID of the storage configuration to share
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareStorageConfiguration: function (storageConfigurationId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.shareStorageConfiguration(storageConfigurationId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.StorageConfigurationApiFp = StorageConfigurationApiFp;
/**
 * StorageConfigurationApi - factory interface
 * @export
 */
var StorageConfigurationApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.StorageConfigurationApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a new storage configuration
         * @param {CreateStorageConfiguration} [createStorageConfiguration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorageConfiguration: function (createStorageConfiguration, options) {
            return localVarFp.createStorageConfiguration(createStorageConfiguration, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a storage configuration.
         * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageConfiguration: function (storageConfigurationId, options) {
            return localVarFp.getStorageConfiguration(storageConfigurationId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a storage configuration detail.
         * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageConfigurationDetails: function (storageConfigurationId, options) {
            return localVarFp.getStorageConfigurationDetails(storageConfigurationId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of storage configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageConfigurations: function (options) {
            return localVarFp.getStorageConfigurations(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Here you share your own storage configuration with all the other users in your tenant.
         * @summary Share your own storage configuration with tenant.
         * @param {string} storageConfigurationId The ID of the storage configuration to share
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareStorageConfiguration: function (storageConfigurationId, options) {
            return localVarFp.shareStorageConfiguration(storageConfigurationId, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.StorageConfigurationApiFactory = StorageConfigurationApiFactory;
/**
 * StorageConfigurationApi - object-oriented interface
 * @export
 * @class StorageConfigurationApi
 * @extends {BaseAPI}
 */
var StorageConfigurationApi = /** @class */ (function (_super) {
    __extends(StorageConfigurationApi, _super);
    function StorageConfigurationApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Create a new storage configuration
     * @param {CreateStorageConfiguration} [createStorageConfiguration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageConfigurationApi
     */
    StorageConfigurationApi.prototype.createStorageConfiguration = function (createStorageConfiguration, options) {
        var _this = this;
        return (0, exports.StorageConfigurationApiFp)(this.configuration).createStorageConfiguration(createStorageConfiguration, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a storage configuration.
     * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageConfigurationApi
     */
    StorageConfigurationApi.prototype.getStorageConfiguration = function (storageConfigurationId, options) {
        var _this = this;
        return (0, exports.StorageConfigurationApiFp)(this.configuration).getStorageConfiguration(storageConfigurationId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a storage configuration detail.
     * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageConfigurationApi
     */
    StorageConfigurationApi.prototype.getStorageConfigurationDetails = function (storageConfigurationId, options) {
        var _this = this;
        return (0, exports.StorageConfigurationApiFp)(this.configuration).getStorageConfigurationDetails(storageConfigurationId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of storage configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageConfigurationApi
     */
    StorageConfigurationApi.prototype.getStorageConfigurations = function (options) {
        var _this = this;
        return (0, exports.StorageConfigurationApiFp)(this.configuration).getStorageConfigurations(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Here you share your own storage configuration with all the other users in your tenant.
     * @summary Share your own storage configuration with tenant.
     * @param {string} storageConfigurationId The ID of the storage configuration to share
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageConfigurationApi
     */
    StorageConfigurationApi.prototype.shareStorageConfiguration = function (storageConfigurationId, options) {
        var _this = this;
        return (0, exports.StorageConfigurationApiFp)(this.configuration).shareStorageConfiguration(storageConfigurationId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return StorageConfigurationApi;
}(base_1.BaseAPI));
exports.StorageConfigurationApi = StorageConfigurationApi;
/**
 * StorageCredentialsApi - axios parameter creator
 * @export
 */
var StorageCredentialsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Create a new storage credential
         * @param {CreateStorageCredential} [createStorageCredential]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorageCredential: function (createStorageCredential, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/storageCredentials";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createStorageCredential, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a storage credential.
         * @param {string} storageCredentialId The ID of the storage credential to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageCredential: function (storageCredentialId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'storageCredentialId' is not null or undefined
                            (0, common_1.assertParamExists)('getStorageCredential', 'storageCredentialId', storageCredentialId);
                            localVarPath = "/api/storageCredentials/{storageCredentialId}"
                                .replace("{".concat("storageCredentialId", "}"), encodeURIComponent(String(storageCredentialId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of storage credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageCredentials: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/storageCredentials";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Here you share your own storage credentials with all the other users in your tenant.
         * @summary Share your own storage credentials with tenant.
         * @param {string} storageCredentialId The ID of the storage credential to share
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareStorageCredential: function (storageCredentialId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'storageCredentialId' is not null or undefined
                            (0, common_1.assertParamExists)('shareStorageCredential', 'storageCredentialId', storageCredentialId);
                            localVarPath = "/api/storageCredentials/{storageCredentialId}:share"
                                .replace("{".concat("storageCredentialId", "}"), encodeURIComponent(String(storageCredentialId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * When your storage credentials change or get updated due to security reasons you need to update them here.
         * @summary Update a storage credential\'s secrets.
         * @param {string} storageCredentialId
         * @param {UpdateStorageCredentialSecrets} [updateStorageCredentialSecrets]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorageCredentialSecrets: function (storageCredentialId, updateStorageCredentialSecrets, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'storageCredentialId' is not null or undefined
                            (0, common_1.assertParamExists)('updateStorageCredentialSecrets', 'storageCredentialId', storageCredentialId);
                            localVarPath = "/api/storageCredentials/{storageCredentialId}:updateSecrets"
                                .replace("{".concat("storageCredentialId", "}"), encodeURIComponent(String(storageCredentialId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateStorageCredentialSecrets, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.StorageCredentialsApiAxiosParamCreator = StorageCredentialsApiAxiosParamCreator;
/**
 * StorageCredentialsApi - functional programming interface
 * @export
 */
var StorageCredentialsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.StorageCredentialsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a new storage credential
         * @param {CreateStorageCredential} [createStorageCredential]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorageCredential: function (createStorageCredential, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createStorageCredential(createStorageCredential, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a storage credential.
         * @param {string} storageCredentialId The ID of the storage credential to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageCredential: function (storageCredentialId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getStorageCredential(storageCredentialId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of storage credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageCredentials: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getStorageCredentials(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Here you share your own storage credentials with all the other users in your tenant.
         * @summary Share your own storage credentials with tenant.
         * @param {string} storageCredentialId The ID of the storage credential to share
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareStorageCredential: function (storageCredentialId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.shareStorageCredential(storageCredentialId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * When your storage credentials change or get updated due to security reasons you need to update them here.
         * @summary Update a storage credential\'s secrets.
         * @param {string} storageCredentialId
         * @param {UpdateStorageCredentialSecrets} [updateStorageCredentialSecrets]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorageCredentialSecrets: function (storageCredentialId, updateStorageCredentialSecrets, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateStorageCredentialSecrets(storageCredentialId, updateStorageCredentialSecrets, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.StorageCredentialsApiFp = StorageCredentialsApiFp;
/**
 * StorageCredentialsApi - factory interface
 * @export
 */
var StorageCredentialsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.StorageCredentialsApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a new storage credential
         * @param {CreateStorageCredential} [createStorageCredential]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorageCredential: function (createStorageCredential, options) {
            return localVarFp.createStorageCredential(createStorageCredential, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a storage credential.
         * @param {string} storageCredentialId The ID of the storage credential to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageCredential: function (storageCredentialId, options) {
            return localVarFp.getStorageCredential(storageCredentialId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of storage credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageCredentials: function (options) {
            return localVarFp.getStorageCredentials(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Here you share your own storage credentials with all the other users in your tenant.
         * @summary Share your own storage credentials with tenant.
         * @param {string} storageCredentialId The ID of the storage credential to share
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareStorageCredential: function (storageCredentialId, options) {
            return localVarFp.shareStorageCredential(storageCredentialId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * When your storage credentials change or get updated due to security reasons you need to update them here.
         * @summary Update a storage credential\'s secrets.
         * @param {string} storageCredentialId
         * @param {UpdateStorageCredentialSecrets} [updateStorageCredentialSecrets]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorageCredentialSecrets: function (storageCredentialId, updateStorageCredentialSecrets, options) {
            return localVarFp.updateStorageCredentialSecrets(storageCredentialId, updateStorageCredentialSecrets, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.StorageCredentialsApiFactory = StorageCredentialsApiFactory;
/**
 * StorageCredentialsApi - object-oriented interface
 * @export
 * @class StorageCredentialsApi
 * @extends {BaseAPI}
 */
var StorageCredentialsApi = /** @class */ (function (_super) {
    __extends(StorageCredentialsApi, _super);
    function StorageCredentialsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Create a new storage credential
     * @param {CreateStorageCredential} [createStorageCredential]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageCredentialsApi
     */
    StorageCredentialsApi.prototype.createStorageCredential = function (createStorageCredential, options) {
        var _this = this;
        return (0, exports.StorageCredentialsApiFp)(this.configuration).createStorageCredential(createStorageCredential, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a storage credential.
     * @param {string} storageCredentialId The ID of the storage credential to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageCredentialsApi
     */
    StorageCredentialsApi.prototype.getStorageCredential = function (storageCredentialId, options) {
        var _this = this;
        return (0, exports.StorageCredentialsApiFp)(this.configuration).getStorageCredential(storageCredentialId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of storage credentials.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageCredentialsApi
     */
    StorageCredentialsApi.prototype.getStorageCredentials = function (options) {
        var _this = this;
        return (0, exports.StorageCredentialsApiFp)(this.configuration).getStorageCredentials(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Here you share your own storage credentials with all the other users in your tenant.
     * @summary Share your own storage credentials with tenant.
     * @param {string} storageCredentialId The ID of the storage credential to share
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageCredentialsApi
     */
    StorageCredentialsApi.prototype.shareStorageCredential = function (storageCredentialId, options) {
        var _this = this;
        return (0, exports.StorageCredentialsApiFp)(this.configuration).shareStorageCredential(storageCredentialId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * When your storage credentials change or get updated due to security reasons you need to update them here.
     * @summary Update a storage credential\'s secrets.
     * @param {string} storageCredentialId
     * @param {UpdateStorageCredentialSecrets} [updateStorageCredentialSecrets]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageCredentialsApi
     */
    StorageCredentialsApi.prototype.updateStorageCredentialSecrets = function (storageCredentialId, updateStorageCredentialSecrets, options) {
        var _this = this;
        return (0, exports.StorageCredentialsApiFp)(this.configuration).updateStorageCredentialSecrets(storageCredentialId, updateStorageCredentialSecrets, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return StorageCredentialsApi;
}(base_1.BaseAPI));
exports.StorageCredentialsApi = StorageCredentialsApi;
/**
 * TokenApi - axios parameter creator
 * @export
 */
var TokenApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Generate a JWT using an API-key, Basic Authentication or a psToken. When using Basic Authentication, and you are member of several tenants, also provide the tenant request parameter to indicate for which tenant you want to authenticate. Note that Basic Authentication will not work for SSO (Single Sign On) enabled authentication.
         * @summary Generate a JWT using an API-key, Basic Authentication or a psToken.
         * @param {string} [tenant] The name of your tenant in case you have access to multiple tenants.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJwtToken: function (tenant, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/tokens";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication BasicAuth required
                                // http basic authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication BasicAuth required
                            // http basic authentication required
                            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
                            // authentication PsTokenAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication PsTokenAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (tenant !== undefined) {
                                localVarQueryParameter['tenant'] = tenant;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * When still having a valid JWT, this endpoint can be used to extend the validity.
         * @summary Refresh a JWT using a not yet expired, still valid JWT.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshJwtToken: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/tokens:refresh";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 1:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.TokenApiAxiosParamCreator = TokenApiAxiosParamCreator;
/**
 * TokenApi - functional programming interface
 * @export
 */
var TokenApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.TokenApiAxiosParamCreator)(configuration);
    return {
        /**
         * Generate a JWT using an API-key, Basic Authentication or a psToken. When using Basic Authentication, and you are member of several tenants, also provide the tenant request parameter to indicate for which tenant you want to authenticate. Note that Basic Authentication will not work for SSO (Single Sign On) enabled authentication.
         * @summary Generate a JWT using an API-key, Basic Authentication or a psToken.
         * @param {string} [tenant] The name of your tenant in case you have access to multiple tenants.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJwtToken: function (tenant, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createJwtToken(tenant, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * When still having a valid JWT, this endpoint can be used to extend the validity.
         * @summary Refresh a JWT using a not yet expired, still valid JWT.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshJwtToken: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.refreshJwtToken(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.TokenApiFp = TokenApiFp;
/**
 * TokenApi - factory interface
 * @export
 */
var TokenApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.TokenApiFp)(configuration);
    return {
        /**
         * Generate a JWT using an API-key, Basic Authentication or a psToken. When using Basic Authentication, and you are member of several tenants, also provide the tenant request parameter to indicate for which tenant you want to authenticate. Note that Basic Authentication will not work for SSO (Single Sign On) enabled authentication.
         * @summary Generate a JWT using an API-key, Basic Authentication or a psToken.
         * @param {string} [tenant] The name of your tenant in case you have access to multiple tenants.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJwtToken: function (tenant, options) {
            return localVarFp.createJwtToken(tenant, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * When still having a valid JWT, this endpoint can be used to extend the validity.
         * @summary Refresh a JWT using a not yet expired, still valid JWT.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshJwtToken: function (options) {
            return localVarFp.refreshJwtToken(options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.TokenApiFactory = TokenApiFactory;
/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
var TokenApi = /** @class */ (function (_super) {
    __extends(TokenApi, _super);
    function TokenApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Generate a JWT using an API-key, Basic Authentication or a psToken. When using Basic Authentication, and you are member of several tenants, also provide the tenant request parameter to indicate for which tenant you want to authenticate. Note that Basic Authentication will not work for SSO (Single Sign On) enabled authentication.
     * @summary Generate a JWT using an API-key, Basic Authentication or a psToken.
     * @param {string} [tenant] The name of your tenant in case you have access to multiple tenants.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    TokenApi.prototype.createJwtToken = function (tenant, options) {
        var _this = this;
        return (0, exports.TokenApiFp)(this.configuration).createJwtToken(tenant, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * When still having a valid JWT, this endpoint can be used to extend the validity.
     * @summary Refresh a JWT using a not yet expired, still valid JWT.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    TokenApi.prototype.refreshJwtToken = function (options) {
        var _this = this;
        return (0, exports.TokenApiFp)(this.configuration).refreshJwtToken(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return TokenApi;
}(base_1.BaseAPI));
exports.TokenApi = TokenApi;
/**
 * UserApi - axios parameter creator
 * @export
 */
var UserApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Endpoint for approving a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Approve a user.
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveUser: function (userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'userId' is not null or undefined
                            (0, common_1.assertParamExists)('approveUser', 'userId', userId);
                            localVarPath = "/api/users/{userId}:approve"
                                .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint for assigning tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Assign tenant administrator rights to a user.
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTenantAdminRightsToUser: function (userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'userId' is not null or undefined
                            (0, common_1.assertParamExists)('assignTenantAdminRightsToUser', 'userId', userId);
                            localVarPath = "/api/users/{userId}:assignTenantAdministratorRights"
                                .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a user.
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: function (userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'userId' is not null or undefined
                            (0, common_1.assertParamExists)('getUser', 'userId', userId);
                            localVarPath = "/api/users/{userId}"
                                .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/users";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Endpoint for revoking tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Revoke tenant administrator rights to a user.
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeTenantAdminRightsToUser: function (userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'userId' is not null or undefined
                            (0, common_1.assertParamExists)('revokeTenantAdminRightsToUser', 'userId', userId);
                            localVarPath = "/api/users/{userId}:revokeTenantAdministratorRights"
                                .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Fields which can be updated: - greeting - two factor authentication - job title - first name - last name - mobile phone number - phone number - fax number - address lines - postal code - city - country - state
         * @summary Update a user.
         * @param {string} userId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {User} [user]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: function (userId, ifMatch, user, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'userId' is not null or undefined
                            (0, common_1.assertParamExists)('updateUser', 'userId', userId);
                            localVarPath = "/api/users/{userId}"
                                .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            if (ifMatch !== undefined && ifMatch !== null) {
                                localVarHeaderParameter['If-Match'] = String(ifMatch);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(user, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.UserApiAxiosParamCreator = UserApiAxiosParamCreator;
/**
 * UserApi - functional programming interface
 * @export
 */
var UserApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.UserApiAxiosParamCreator)(configuration);
    return {
        /**
         * Endpoint for approving a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Approve a user.
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveUser: function (userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.approveUser(userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint for assigning tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Assign tenant administrator rights to a user.
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTenantAdminRightsToUser: function (userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.assignTenantAdminRightsToUser(userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a user.
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: function (userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getUser(userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getUsers(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Endpoint for revoking tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Revoke tenant administrator rights to a user.
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeTenantAdminRightsToUser: function (userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.revokeTenantAdminRightsToUser(userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fields which can be updated: - greeting - two factor authentication - job title - first name - last name - mobile phone number - phone number - fax number - address lines - postal code - city - country - state
         * @summary Update a user.
         * @param {string} userId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {User} [user]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: function (userId, ifMatch, user, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateUser(userId, ifMatch, user, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.UserApiFp = UserApiFp;
/**
 * UserApi - factory interface
 * @export
 */
var UserApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.UserApiFp)(configuration);
    return {
        /**
         * Endpoint for approving a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Approve a user.
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveUser: function (userId, options) {
            return localVarFp.approveUser(userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint for assigning tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Assign tenant administrator rights to a user.
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTenantAdminRightsToUser: function (userId, options) {
            return localVarFp.assignTenantAdminRightsToUser(userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a user.
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: function (userId, options) {
            return localVarFp.getUser(userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: function (options) {
            return localVarFp.getUsers(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Endpoint for revoking tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Revoke tenant administrator rights to a user.
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeTenantAdminRightsToUser: function (userId, options) {
            return localVarFp.revokeTenantAdminRightsToUser(userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fields which can be updated: - greeting - two factor authentication - job title - first name - last name - mobile phone number - phone number - fax number - address lines - postal code - city - country - state
         * @summary Update a user.
         * @param {string} userId
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {User} [user]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: function (userId, ifMatch, user, options) {
            return localVarFp.updateUser(userId, ifMatch, user, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.UserApiFactory = UserApiFactory;
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
var UserApi = /** @class */ (function (_super) {
    __extends(UserApi, _super);
    function UserApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Endpoint for approving a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Approve a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    UserApi.prototype.approveUser = function (userId, options) {
        var _this = this;
        return (0, exports.UserApiFp)(this.configuration).approveUser(userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint for assigning tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Assign tenant administrator rights to a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    UserApi.prototype.assignTenantAdminRightsToUser = function (userId, options) {
        var _this = this;
        return (0, exports.UserApiFp)(this.configuration).assignTenantAdminRightsToUser(userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    UserApi.prototype.getUser = function (userId, options) {
        var _this = this;
        return (0, exports.UserApiFp)(this.configuration).getUser(userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    UserApi.prototype.getUsers = function (options) {
        var _this = this;
        return (0, exports.UserApiFp)(this.configuration).getUsers(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Endpoint for revoking tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Revoke tenant administrator rights to a user.
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    UserApi.prototype.revokeTenantAdminRightsToUser = function (userId, options) {
        var _this = this;
        return (0, exports.UserApiFp)(this.configuration).revokeTenantAdminRightsToUser(userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fields which can be updated: - greeting - two factor authentication - job title - first name - last name - mobile phone number - phone number - fax number - address lines - postal code - city - country - state
     * @summary Update a user.
     * @param {string} userId
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {User} [user]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    UserApi.prototype.updateUser = function (userId, ifMatch, user, options) {
        var _this = this;
        return (0, exports.UserApiFp)(this.configuration).updateUser(userId, ifMatch, user, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return UserApi;
}(base_1.BaseAPI));
exports.UserApi = UserApi;
/**
 * WorkgroupApi - axios parameter creator
 * @export
 */
var WorkgroupApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Retrieve a workgroup.
         * @param {string} workgroupId The ID of the workgroup to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkgroup: function (workgroupId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'workgroupId' is not null or undefined
                            (0, common_1.assertParamExists)('getWorkgroup', 'workgroupId', workgroupId);
                            localVarPath = "/api/workgroups/{workgroupId}"
                                .replace("{".concat("workgroupId", "}"), encodeURIComponent(String(workgroupId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of workgroups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkgroups: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/api/workgroups";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication ApiKeyAuth required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-API-Key", configuration)
                                // authentication JwtAuth required
                                // http bearer authentication required
                            ];
                        case 1:
                            // authentication ApiKeyAuth required
                            _a.sent();
                            // authentication JwtAuth required
                            // http bearer authentication required
                            return [4 /*yield*/, (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration)];
                        case 2:
                            // authentication JwtAuth required
                            // http bearer authentication required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.WorkgroupApiAxiosParamCreator = WorkgroupApiAxiosParamCreator;
/**
 * WorkgroupApi - functional programming interface
 * @export
 */
var WorkgroupApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.WorkgroupApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve a workgroup.
         * @param {string} workgroupId The ID of the workgroup to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkgroup: function (workgroupId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getWorkgroup(workgroupId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Retrieve a list of workgroups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkgroups: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getWorkgroups(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.WorkgroupApiFp = WorkgroupApiFp;
/**
 * WorkgroupApi - factory interface
 * @export
 */
var WorkgroupApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.WorkgroupApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve a workgroup.
         * @param {string} workgroupId The ID of the workgroup to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkgroup: function (workgroupId, options) {
            return localVarFp.getWorkgroup(workgroupId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Retrieve a list of workgroups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkgroups: function (options) {
            return localVarFp.getWorkgroups(options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.WorkgroupApiFactory = WorkgroupApiFactory;
/**
 * WorkgroupApi - object-oriented interface
 * @export
 * @class WorkgroupApi
 * @extends {BaseAPI}
 */
var WorkgroupApi = /** @class */ (function (_super) {
    __extends(WorkgroupApi, _super);
    function WorkgroupApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Retrieve a workgroup.
     * @param {string} workgroupId The ID of the workgroup to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkgroupApi
     */
    WorkgroupApi.prototype.getWorkgroup = function (workgroupId, options) {
        var _this = this;
        return (0, exports.WorkgroupApiFp)(this.configuration).getWorkgroup(workgroupId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Retrieve a list of workgroups.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkgroupApi
     */
    WorkgroupApi.prototype.getWorkgroups = function (options) {
        var _this = this;
        return (0, exports.WorkgroupApiFp)(this.configuration).getWorkgroups(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return WorkgroupApi;
}(base_1.BaseAPI));
exports.WorkgroupApi = WorkgroupApi;
